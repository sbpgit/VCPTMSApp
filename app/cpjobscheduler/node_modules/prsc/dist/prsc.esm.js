function n(n,t){return{success:!0,offset:n,value:t}}function t(t){return n(t,void 0)}function e(n,t,e=!1){return{success:!1,offset:n,expected:t,fatal:e}}function r(t){return(r,u)=>{const o=u+t.length;return r.slice(u,o)===t?n(o,t):e(u,[t])}}function u(t,r){return(u,o)=>{const c=u.codePointAt(o);if(void 0!==c&&c>=t&&c<=r){const t=String.fromCodePoint(c);return n(o+t.length,t)}return e(o,[`${String.fromCodePoint(t)}-${String.fromCodePoint(r)}`])}}function o(n){return(r,u)=>{let o=n;for(;o>0;){const n=r.codePointAt(u);if(void 0===n)return e(u,["any character"]);u+=String.fromCodePoint(n).length,o-=1}return t(u)}}function c(t,e){return(r,u)=>{const o=t(r,u);return o.success?n(o.offset,e(o.value)):o}}function f(n){return c(n,()=>{})}function s(n,t,r){return(u,o)=>{const c=n(u,o);return c.success?t(c.value)?c:e(o,r):c.offset===o?e(o,r):c}}function i(n){return(t,r)=>{let u=null;for(const e of n){const n=e(t,r);if(n.success)return n;if(null===u||n.offset>u.offset?u=n:n.offset===u.offset&&(u.expected=u.expected.concat(n.expected)),n.fatal)break}return u||e(r,[])}}function l(t){return(e,r)=>{const u=t(e,r);return u.success||u.fatal?u:n(r,null)}}function a(t){return(e,r)=>{let u=[],o=r;for(;;){const n=t(e,o);if(!n.success){if(n.fatal)return n;break}if(u.push(n.value),n.offset===o)break;o=n.offset}return n(o,u)}}function d(n){return c(n,n=>n.filter(n=>void 0!==n))}function v(t,e,r){return(u,o)=>{const c=t(u,o);if(!c.success)return c;const f=e(u,c.offset);return f.success?n(f.offset,r(c.value,f.value)):f}}function p(n){return v(n,a(n),(n,t)=>[n].concat(t))}function x(n,t){return n}function g(n,t){return t}function y(n,t){return v(n,t,g)}function h(n,t){return v(n,t,x)}function P(n,t,e,r=!1){return y(n,r?k(h(t,e)):h(t,e))}function m(t){return(e,r)=>{const u=t(e,r);return u.success?n(u.offset,e.slice(r,u.offset)):u}}function C(t){return(e,r)=>{const u=t(e,r);return u.success?n(r,u.value):u}}function S(n,r){return(u,o)=>n(u,o).success?e(o,r):t(o)}function b(n,t,e){return y(S(t,e),n)}function k(n){return(t,r)=>{const u=n(t,r);return u.success?u:e(u.offset,u.expected,!0)}}const A=(n,r)=>0===r?t(r):e(r,["start of input"]),$=(n,r)=>n.length===r?t(r):e(r,["end of input"]);function j(n){return v(n,$,x)}function q(n){const t=[];let e=n.next();for(;!e.done;)t.push(e.value),e=n.next();return[t,e.value]}function w(n){return function*(t,e){const r=n(t,e);return r.success&&(yield r.value),r}}function z(n,t){return function*(e,r){const u=yield*n(e,r);return u.success?yield*t(e,u.offset):u}}function B(n){return function*(t,e){const r=n(t,e);let u=r.next();for(;!u.done;){const n=u.value;void 0!==n&&(yield n),u=r.next()}return u.value}}function D(n){return function*(e,r){for(;;){const[u,o]=q(n(e,r));if(!o.success)return o.fatal?o:t(r);if(yield*u,r===o.offset)return t(r);r=o.offset}}}function E(n){return function*(e,r){const[u,o]=q(n(e,r));return o.success?(yield*u,o):o.fatal?o:t(r)}}function F(n){return function*(t,e){const r=yield*n(t,e);return r.success?$(t,r.offset):r}}export{q as collect,j as complete,f as consume,k as cut,P as delimited,$ as end,e as error,b as except,s as filter,d as filterUndefined,x as first,h as followed,c as map,S as not,t as ok,n as okWithValue,l as optional,i as or,C as peek,p as plus,y as preceded,u as range,m as recognize,g as second,o as skipChars,a as star,A as start,w as streaming,F as streamingComplete,B as streamingFilterUndefined,E as streamingOptional,D as streamingStar,z as streamingThen,v as then,r as token};
//# sourceMappingURL=prsc.esm.js.map
