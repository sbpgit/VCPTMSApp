{"version":3,"file":"prsc.esm.js","sources":["../src/parser-combinators.ts","../src/streaming.ts"],"sourcesContent":["/**\n * The result of parsing - either success (with an offset at which to resume parsing the next thing)\n * or failure. If a failure is fatal, parsing should not continue to try alternative options.\n *\n * A ParseResult may contain a value that represents the parsed input.\n *\n * @public\n */\nexport type ParseResult<T> =\n\t| { success: true; offset: number; value: T }\n\t| { success: false; offset: number; expected: string[]; fatal: boolean };\n\n/**\n * A parser is a function that tries to match whatever it expects at the given offset in the input\n * string. Returns a ParseResult.\n *\n * @public\n */\nexport type Parser<T> = (input: string, offset: number) => ParseResult<T>;\n\n/**\n * Creates a successful ParseResult containing the given value.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n * @param value  - The value resulting from applying the parser\n */\nexport function okWithValue<T>(offset: number, value: T): ParseResult<T> {\n\treturn { success: true, offset, value };\n}\n\n/**\n * Creates a successful ParseResult with an undefined value. Use this to signal success in cases\n * where no value is required.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n */\nexport function ok(offset: number): ParseResult<undefined> {\n\treturn okWithValue(offset, undefined);\n}\n\n/**\n * Creates an unsuccessful ParseResult (parse error) at the given offset.\n *\n * @public\n *\n * @param offset   - The offset in the input at which matching failed\n * @param expected - An array of strings indicating things that were expected at offset\n * @param fatal    - If true, no other branches should be tried as a result of this error\n */\nexport function error<T>(\n\toffset: number,\n\texpected: string[],\n\tfatal: boolean = false\n): ParseResult<T> {\n\treturn { success: false, offset, expected, fatal };\n}\n\n/**\n * Creates a Parser that matches the given string.\n *\n * @public\n *\n * @param token - The expected string\n */\nexport function token(token: string): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst offsetAfter = offset + token.length;\n\t\tif (input.slice(offset, offsetAfter) === token) {\n\t\t\treturn okWithValue(offsetAfter, token);\n\t\t}\n\t\treturn error(offset, [token]);\n\t};\n}\n\n/**\n * Creates a Parser that matches a single character from a range of codepoints.\n *\n * @public\n *\n * @param firstCodePoint - The first code point to accept\n * @param lastCodePoint  - The last code point to accept (inclusive)\n */\nexport function range(firstCodePoint: number, lastCodePoint: number): Parser<string> {\n\treturn (input: string, offset: number) => {\n\t\tconst cp = input.codePointAt(offset);\n\t\tif (cp !== undefined && cp >= firstCodePoint && cp <= lastCodePoint) {\n\t\t\tconst char = String.fromCodePoint(cp);\n\t\t\treturn okWithValue(offset + char.length, char);\n\t\t}\n\t\treturn error(offset, [\n\t\t\t`${String.fromCodePoint(firstCodePoint)}-${String.fromCodePoint(lastCodePoint)}`,\n\t\t]);\n\t};\n}\n\n/**\n * Creates a Parser that skips the given number of characters.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * @public\n *\n * @param nCodepoints - number of characters to skip\n */\nexport function skipChars(nCodepoints: number): Parser<void> {\n\treturn (input: string, offset: number) => {\n\t\tlet i = nCodepoints;\n\t\twhile (i > 0) {\n\t\t\tconst cp = input.codePointAt(offset);\n\t\t\tif (cp === undefined) {\n\t\t\t\treturn error(offset, ['any character']);\n\t\t\t}\n\t\t\toffset += String.fromCodePoint(cp).length;\n\t\t\ti -= 1;\n\t\t}\n\t\treturn ok(offset);\n\t};\n}\n\n/**\n * Creates a Parser that applies the given function to each value generated by the given parser.\n *\n * @public\n *\n * @param parser - Parser to map over\n * @param map    - Function to transform values generated by parser\n */\nexport function map<T, U>(parser: Parser<T>, map: (v: T) => U): Parser<U> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, map(res.value));\n\t};\n}\n\n/**\n * Creates a Parser that applies the given parser but discards the resulting value.\n *\n * @public\n *\n * @param parser - Parser to apply\n */\nexport function consume<T>(parser: Parser<T>): Parser<void> {\n\treturn map(parser, () => undefined);\n}\n\n/**\n * Creates a Parser that uses the given filter predicate to check values generated by the given\n * parser. Values that pass the predicate are passed through, those that don't return a parse error\n * instead.\n *\n * @public\n *\n * @param parser   - Parser to filter\n * @param filter   - Predicate function over the inner parser's values\n * @param expected - Expected values for parse errors generated when the filter rejects a value\n */\nexport function filter<T>(\n\tparser: Parser<T>,\n\tfilter: (v: T) => boolean,\n\texpected: string[]\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\tif (res.offset === offset) {\n\t\t\t\treturn error(offset, expected);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tif (!filter(res.value)) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a Parser that applies each of the given parsers in turn until one matches, then returns\n * that parser's result. If no parser matches, an error is returned reflecting the furthest offset\n * reached in the input string. If any parser returns a fatal error, no further branches are tried.\n *\n * @public\n *\n * @param parsers - Parsers to attempt to apply\n */\nexport function or<T>(parsers: Parser<T>[]): Parser<T> {\n\treturn (input, offset) => {\n\t\tlet lastError: ParseResult<T> | null = null;\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (lastError === null || res.offset > lastError.offset) {\n\t\t\t\tlastError = res;\n\t\t\t} else if (res.offset === lastError.offset) {\n\t\t\t\tlastError.expected = lastError.expected.concat(res.expected);\n\t\t\t}\n\t\t\tif (res.fatal) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn lastError || error(offset, []);\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser optionally. It returns the inner parser's\n * result if succesful, and otherwise indicates success at the starting offset with a `null` value.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to attempt to apply\n */\nexport function optional<T>(parser: Parser<T>): Parser<T | null> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success && !res.fatal) {\n\t\t\treturn okWithValue(offset, null);\n\t\t}\n\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser zero or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to apply repeatedly\n */\nexport function star<T>(parser: Parser<T>): Parser<T[]> {\n\treturn (input, offset) => {\n\t\tlet ts: T[] = [];\n\t\tlet nextOffset = offset;\n\t\twhile (true) {\n\t\t\tconst res = parser(input, nextOffset);\n\t\t\tif (!res.success) {\n\t\t\t\tif (res.fatal) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tts.push(res.value);\n\t\t\tif (res.offset === nextOffset) {\n\t\t\t\t// Did not advance\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextOffset = res.offset;\n\t\t}\n\n\t\treturn okWithValue(nextOffset, ts);\n\t};\n}\n\n/**\n * Creates a parser that discards undefined values from the array produced by the\n * given parser.\n *\n * Useful in combination with `star`, `or` and `consume`:\n *\n * ```\n * const a: Parser<string> = token('a');\n * const b: Parser<void> = consume(token('b'));\n * const abs: Parser<(string | void)[]> = star(or<string | void>([a, b]));\n * const as: Parser<string[]> = filterUndefined(abs);\n * ```\n *\n * @public\n *\n * @param parser - Parser to apply, should produce an array that may contain undefined entries.\n */\nexport function filterUndefined<T>(parser: Parser<(T | void)[]>): Parser<T[]> {\n\treturn map(parser, (vs) => vs.filter((v) => v !== undefined) as T[]);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning success only if both\n * succeed. The given join function is used to combine the values from both parsers into the single\n * value to return. If either parser fails, the failure is returned as-is.\n *\n * @public\n *\n * @param parser1 - First parser to apply\n * @param parser2 - Parser to apply after the first one is successful\n * @param join    - Function used to combine the values of both parsers\n */\nexport function then<T1, T2, T>(\n\tparser1: Parser<T1>,\n\tparser2: Parser<T2>,\n\tjoin: (value1: T1, value2: T2) => T\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst r1 = parser1(input, offset);\n\t\tif (!r1.success) {\n\t\t\treturn r1;\n\t\t}\n\t\tconst r2 = parser2(input, r1.offset);\n\t\tif (!r2.success) {\n\t\t\treturn r2;\n\t\t}\n\t\treturn okWithValue(r2.offset, join(r1.value, r2.value));\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser one or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values. The parser is required to match at\n * least once, so an initial failure is returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply repeatedly\n */\nexport function plus<T>(parser: Parser<T>): Parser<T[]> {\n\treturn then(parser, star(parser), (v, vs) => [v].concat(vs));\n}\n\n/**\n * Returns the first of the given two arguments. Useful as a `join` function for `then`. See also\n * `followed`.\n *\n * @public\n *\n * @param x - Argument to return\n * @param y - Argument to ignore\n */\nexport function first<T1, T2>(x: T1, y: T2): T1 {\n\treturn x;\n}\n\n/**\n * Returns the second of the given two arguments. Useful as a `join` function for `then`. See also\n * `preceded`.\n *\n * @public\n *\n * @param x - Argument to ignore\n * @param y - Argument to return\n */\nexport function second<T1, T2>(x: T1, y: T2): T2 {\n\treturn y;\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result of the\n * second if the first succeeds.\n *\n * Equivalent to `then(before, parser, second)`.\n *\n * @public\n *\n * @param before - First parser to apply, value is discarded\n * @param parser - Second parser to apply, value is kept\n */\nexport function preceded<TBefore, T>(before: Parser<TBefore>, parser: Parser<T>): Parser<T> {\n\treturn then(before, parser, second);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result value of\n * the first at the offset of the second if both succeed. If either parser fails the error is\n * returned as-is.\n *\n * Equivalent to `then(parser, after, first)`.\n *\n * @public\n *\n * @param parser - First parser to apply, value is kept\n * @param before - Second parser to apply, value is discarded\n */\nexport function followed<T, TAfter>(parser: Parser<T>, after: Parser<TAfter>): Parser<T> {\n\treturn then(parser, after, first);\n}\n\n/**\n * Creates a Parser that applies the given parsers in sequence, returning the result value of the\n * middle parser at the offset of the third if all are successful. If any parser fails, the error is\n * returned as-is.\n *\n * Optionally makes errors by the second and third parsers fatal if `cutAfterOpen` is `true`.\n *\n * @public\n *\n * @param open         - First parser to apply, value is discarded\n * @param inner        - Second parser to apply, value is kept\n * @param close        - Third parser to apply, value is discarded\n * @param cutAfterOpen - If `true`, errors returned by the second and third parsers are considered\n *                       fatal, causing parsers using this to stop trying other branches.\n */\nexport function delimited<TOpen, T, TClose>(\n\topen: Parser<TOpen>,\n\tinner: Parser<T>,\n\tclose: Parser<TClose>,\n\tcutAfterOpen: boolean = false\n): Parser<T> {\n\tconst rest = cutAfterOpen ? cut(followed(inner, close)) : followed(inner, close);\n\treturn preceded(open, rest);\n}\n\n/**\n * Creates a Parser that applies the given parser. If successful, the inner parser's value is\n * discarded and the substring that was consumed from the input is returned as value instead. Errors\n * are returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and replaced by the consumed input.\n */\nexport function recognize<T>(parser: Parser<T>): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, input.slice(offset, res.offset));\n\t};\n}\n\n/**\n * Creates a Parser that applies the given parser without consuming any input. That is, if the inner\n * parser is successful, success is returned (with the resulting value) at the starting offset,\n * effectively making the parser consume no input.\n *\n * Errors returned by the inner parser are returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and any progress made in input is reset.\n */\nexport function peek<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(offset, res.value);\n\t};\n}\n\n/**\n * Creates a Parser that succeeds at the starting offset if the given parser fails and vice-versa.\n *\n * @public\n *\n * @param parser   - The parser to apply\n * @param expected - Expected values for parse errors generated when the inner parser succeeds\n */\nexport function not<T>(parser: Parser<T>, expected: string[]): Parser<void> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn ok(offset);\n\t\t}\n\t\treturn error(offset, expected);\n\t};\n}\n\n/**\n * Creates a Parser that matches only if the first Parser matches input at the starting position,\n * but the second Parser does not.\n *\n * @public\n *\n * @param match    - Parser that should match\n * @param except   - Parser that should not match\n * @param expected - Expected values for parse errors generated when the except parser succeeds\n */\nexport function except<T, U>(match: Parser<T>, except: Parser<U>, expected: string[]): Parser<T> {\n\treturn preceded(not(except, expected), match);\n}\n\n/**\n * Creates a Parser that turns errors returned by the inner parser into fatal errors. Parsers such\n * as `or` and `star` will not continue to attempt additional matches if a parser returns a fatal\n * error, and will usually return the error instead.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function cut<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn error(res.offset, res.expected, true);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * A parser that only succeeds at the start of the input string.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const start: Parser<void> = (_input, offset) =>\n\toffset === 0 ? ok(offset) : error(offset, ['start of input']);\n\n/**\n * A parser that only succeeds if the end of the input string is reached.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const end: Parser<void> = (input, offset) =>\n\tinput.length === offset ? ok(offset) : error(offset, ['end of input']);\n\n/**\n * Creates a Parser that applies the given parser and only succeeds (returning the inner parser's\n * result) if parsing concludes at the end of the input string.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function complete<T>(parser: Parser<T>): Parser<T> {\n\treturn then(parser, end, first);\n}\n","import { end, ok, Parser, ParseResult } from './parser-combinators';\n\n/**\n * Helper to collect both the yielded values and the returned value from a generator.\n *\n * @public\n *\n * @param gen - Generator to collect from\n */\nexport function collect<T, R>(gen: Generator<T, R>): [T[], R] {\n\tconst values: T[] = [];\n\tlet it = gen.next();\n\twhile (!it.done) {\n\t\tvalues.push(it.value);\n\t\tit = gen.next();\n\t}\n\treturn [values, it.value];\n}\n\n/**\n * A StreamingParser is similar to a Parser, but instead of returning a value when parsing is\n * complete it can parse incrementally and yield values as they are produced. The generator returns\n * a ParseResult when iteration is done which indicates whether parsing was successful.\n *\n * @public\n */\nexport type StreamingParser<T> = (\n\tinput: string,\n\toffset: number\n) => Generator<T, ParseResult<unknown>>;\n\n/**\n * Creates a StreamingParser which applies the given Parser and yields the value produced if it\n * matches.\n *\n * @public\n *\n * @param parser - The Parser to apply\n */\nexport function streaming<T>(parser: Parser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst res = parser(input, offset);\n\t\tif (res.success) {\n\t\t\tyield res.value;\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a StreamingParser which applies the given two StreamingParsers in sequence.\n *\n * Unlike `then`, this does not combine values using a function, but instead simply yields the\n * values produced by both parsers as they produce them.\n *\n * @public\n *\n * @param parser1 - First StreamingParser to apply\n * @param parser2 - StreamingParser to apply if the first one is successful\n */\nexport function streamingThen<T, U>(\n\tparser1: StreamingParser<T>,\n\tparser2: StreamingParser<U>\n): StreamingParser<T | U> {\n\treturn function* (input: string, offset: number) {\n\t\tconst res1 = yield* parser1(input, offset);\n\t\tif (!res1.success) {\n\t\t\treturn res1;\n\t\t}\n\t\treturn yield* parser2(input, res1.offset);\n\t};\n}\n\n/**\n * Creates a StreamingParser which discards undefined values yielded by the given StreamingParser.\n *\n * @public\n *\n * @param parser - The StreamingParser to filter\n */\nexport function streamingFilterUndefined<T>(parser: StreamingParser<T | void>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst gen = parser(input, offset);\n\t\tlet it = gen.next();\n\t\twhile (!it.done) {\n\t\t\tconst value = it.value;\n\t\t\tif (value !== undefined) {\n\t\t\t\tyield value;\n\t\t\t}\n\t\t\tit = gen.next();\n\t\t}\n\t\treturn it.value;\n\t};\n}\n\n/**\n * Creates a StreamingParser that tries to apply the given StreamingParser zero or more times in\n * sequence. Values produced during each iteration are only yielded whenever the inner parser\n * matches successfully.\n *\n * @public\n *\n * @param parser - StreamingParser to apply repeatedly\n */\nexport function streamingStar<T>(parser: StreamingParser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\twhile (true) {\n\t\t\tconst [values, result] = collect(parser(input, offset));\n\t\t\tif (!result.success) {\n\t\t\t\tif (result.fatal) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\treturn ok(offset);\n\t\t\t}\n\n\t\t\tyield* values;\n\n\t\t\tif (offset === result.offset) {\n\t\t\t\t// Did not advance\n\t\t\t\treturn ok(offset);\n\t\t\t}\n\t\t\toffset = result.offset;\n\t\t}\n\t};\n}\n\n/**\n * Creates a StreamingParser that tries to apply the given parser optionally. It only yields the\n * values produced by the inner parser if it matches successfully, and does not yield anything\n * otherwise.\n *\n * @public\n *\n * @param parser - StreamingParser to attempt to apply\n */\nexport function streamingOptional<T>(parser: StreamingParser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst [values, result] = collect(parser(input, offset));\n\t\tif (!result.success) {\n\t\t\tif (result.fatal) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn ok(offset);\n\t\t}\n\n\t\tyield* values;\n\n\t\treturn result;\n\t};\n}\n\n/**\n * Creates a StreamingParser that applies the given parser and directly yields values produced by\n * it, and then only succeeds if parsing concludes at the end of the input string.\n *\n * @public\n *\n * @param parser - StreamingParser to apply\n */\nexport function streamingComplete<T>(parser: StreamingParser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst res = yield* parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn end(input, res.offset);\n\t};\n}\n"],"names":["okWithValue","offset","value","success","ok","undefined","error","expected","fatal","token","input","offsetAfter","length","slice","range","firstCodePoint","lastCodePoint","cp","codePointAt","char","String","fromCodePoint","skipChars","nCodepoints","i","map","parser","res","consume","filter","or","parsers","lastError","concat","optional","star","ts","nextOffset","push","filterUndefined","vs","v","then","parser1","parser2","join","r1","r2","plus","first","x","y","second","preceded","before","followed","after","delimited","open","inner","close","cutAfterOpen","cut","recognize","peek","not","except","match","start","_input","end","complete","collect","gen","values","it","next","done","streaming","streamingThen","res1","streamingFilterUndefined","streamingStar","result","streamingOptional","streamingComplete"],"mappings":"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"}