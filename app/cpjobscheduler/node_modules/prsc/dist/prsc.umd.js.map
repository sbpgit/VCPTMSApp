{"version":3,"file":"prsc.umd.js","sources":["../src/parser-combinators.ts","../src/streaming.ts"],"sourcesContent":["/**\n * The result of parsing - either success (with an offset at which to resume parsing the next thing)\n * or failure. If a failure is fatal, parsing should not continue to try alternative options.\n *\n * A ParseResult may contain a value that represents the parsed input.\n *\n * @public\n */\nexport type ParseResult<T> =\n\t| { success: true; offset: number; value: T }\n\t| { success: false; offset: number; expected: string[]; fatal: boolean };\n\n/**\n * A parser is a function that tries to match whatever it expects at the given offset in the input\n * string. Returns a ParseResult.\n *\n * @public\n */\nexport type Parser<T> = (input: string, offset: number) => ParseResult<T>;\n\n/**\n * Creates a successful ParseResult containing the given value.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n * @param value  - The value resulting from applying the parser\n */\nexport function okWithValue<T>(offset: number, value: T): ParseResult<T> {\n\treturn { success: true, offset, value };\n}\n\n/**\n * Creates a successful ParseResult with an undefined value. Use this to signal success in cases\n * where no value is required.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n */\nexport function ok(offset: number): ParseResult<undefined> {\n\treturn okWithValue(offset, undefined);\n}\n\n/**\n * Creates an unsuccessful ParseResult (parse error) at the given offset.\n *\n * @public\n *\n * @param offset   - The offset in the input at which matching failed\n * @param expected - An array of strings indicating things that were expected at offset\n * @param fatal    - If true, no other branches should be tried as a result of this error\n */\nexport function error<T>(\n\toffset: number,\n\texpected: string[],\n\tfatal: boolean = false\n): ParseResult<T> {\n\treturn { success: false, offset, expected, fatal };\n}\n\n/**\n * Creates a Parser that matches the given string.\n *\n * @public\n *\n * @param token - The expected string\n */\nexport function token(token: string): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst offsetAfter = offset + token.length;\n\t\tif (input.slice(offset, offsetAfter) === token) {\n\t\t\treturn okWithValue(offsetAfter, token);\n\t\t}\n\t\treturn error(offset, [token]);\n\t};\n}\n\n/**\n * Creates a Parser that matches a single character from a range of codepoints.\n *\n * @public\n *\n * @param firstCodePoint - The first code point to accept\n * @param lastCodePoint  - The last code point to accept (inclusive)\n */\nexport function range(firstCodePoint: number, lastCodePoint: number): Parser<string> {\n\treturn (input: string, offset: number) => {\n\t\tconst cp = input.codePointAt(offset);\n\t\tif (cp !== undefined && cp >= firstCodePoint && cp <= lastCodePoint) {\n\t\t\tconst char = String.fromCodePoint(cp);\n\t\t\treturn okWithValue(offset + char.length, char);\n\t\t}\n\t\treturn error(offset, [\n\t\t\t`${String.fromCodePoint(firstCodePoint)}-${String.fromCodePoint(lastCodePoint)}`,\n\t\t]);\n\t};\n}\n\n/**\n * Creates a Parser that skips the given number of characters.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * @public\n *\n * @param nCodepoints - number of characters to skip\n */\nexport function skipChars(nCodepoints: number): Parser<void> {\n\treturn (input: string, offset: number) => {\n\t\tlet i = nCodepoints;\n\t\twhile (i > 0) {\n\t\t\tconst cp = input.codePointAt(offset);\n\t\t\tif (cp === undefined) {\n\t\t\t\treturn error(offset, ['any character']);\n\t\t\t}\n\t\t\toffset += String.fromCodePoint(cp).length;\n\t\t\ti -= 1;\n\t\t}\n\t\treturn ok(offset);\n\t};\n}\n\n/**\n * Creates a Parser that applies the given function to each value generated by the given parser.\n *\n * @public\n *\n * @param parser - Parser to map over\n * @param map    - Function to transform values generated by parser\n */\nexport function map<T, U>(parser: Parser<T>, map: (v: T) => U): Parser<U> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, map(res.value));\n\t};\n}\n\n/**\n * Creates a Parser that applies the given parser but discards the resulting value.\n *\n * @public\n *\n * @param parser - Parser to apply\n */\nexport function consume<T>(parser: Parser<T>): Parser<void> {\n\treturn map(parser, () => undefined);\n}\n\n/**\n * Creates a Parser that uses the given filter predicate to check values generated by the given\n * parser. Values that pass the predicate are passed through, those that don't return a parse error\n * instead.\n *\n * @public\n *\n * @param parser   - Parser to filter\n * @param filter   - Predicate function over the inner parser's values\n * @param expected - Expected values for parse errors generated when the filter rejects a value\n */\nexport function filter<T>(\n\tparser: Parser<T>,\n\tfilter: (v: T) => boolean,\n\texpected: string[]\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\tif (res.offset === offset) {\n\t\t\t\treturn error(offset, expected);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tif (!filter(res.value)) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a Parser that applies each of the given parsers in turn until one matches, then returns\n * that parser's result. If no parser matches, an error is returned reflecting the furthest offset\n * reached in the input string. If any parser returns a fatal error, no further branches are tried.\n *\n * @public\n *\n * @param parsers - Parsers to attempt to apply\n */\nexport function or<T>(parsers: Parser<T>[]): Parser<T> {\n\treturn (input, offset) => {\n\t\tlet lastError: ParseResult<T> | null = null;\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (lastError === null || res.offset > lastError.offset) {\n\t\t\t\tlastError = res;\n\t\t\t} else if (res.offset === lastError.offset) {\n\t\t\t\tlastError.expected = lastError.expected.concat(res.expected);\n\t\t\t}\n\t\t\tif (res.fatal) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn lastError || error(offset, []);\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser optionally. It returns the inner parser's\n * result if succesful, and otherwise indicates success at the starting offset with a `null` value.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to attempt to apply\n */\nexport function optional<T>(parser: Parser<T>): Parser<T | null> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success && !res.fatal) {\n\t\t\treturn okWithValue(offset, null);\n\t\t}\n\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser zero or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to apply repeatedly\n */\nexport function star<T>(parser: Parser<T>): Parser<T[]> {\n\treturn (input, offset) => {\n\t\tlet ts: T[] = [];\n\t\tlet nextOffset = offset;\n\t\twhile (true) {\n\t\t\tconst res = parser(input, nextOffset);\n\t\t\tif (!res.success) {\n\t\t\t\tif (res.fatal) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tts.push(res.value);\n\t\t\tif (res.offset === nextOffset) {\n\t\t\t\t// Did not advance\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextOffset = res.offset;\n\t\t}\n\n\t\treturn okWithValue(nextOffset, ts);\n\t};\n}\n\n/**\n * Creates a parser that discards undefined values from the array produced by the\n * given parser.\n *\n * Useful in combination with `star`, `or` and `consume`:\n *\n * ```\n * const a: Parser<string> = token('a');\n * const b: Parser<void> = consume(token('b'));\n * const abs: Parser<(string | void)[]> = star(or<string | void>([a, b]));\n * const as: Parser<string[]> = filterUndefined(abs);\n * ```\n *\n * @public\n *\n * @param parser - Parser to apply, should produce an array that may contain undefined entries.\n */\nexport function filterUndefined<T>(parser: Parser<(T | void)[]>): Parser<T[]> {\n\treturn map(parser, (vs) => vs.filter((v) => v !== undefined) as T[]);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning success only if both\n * succeed. The given join function is used to combine the values from both parsers into the single\n * value to return. If either parser fails, the failure is returned as-is.\n *\n * @public\n *\n * @param parser1 - First parser to apply\n * @param parser2 - Parser to apply after the first one is successful\n * @param join    - Function used to combine the values of both parsers\n */\nexport function then<T1, T2, T>(\n\tparser1: Parser<T1>,\n\tparser2: Parser<T2>,\n\tjoin: (value1: T1, value2: T2) => T\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst r1 = parser1(input, offset);\n\t\tif (!r1.success) {\n\t\t\treturn r1;\n\t\t}\n\t\tconst r2 = parser2(input, r1.offset);\n\t\tif (!r2.success) {\n\t\t\treturn r2;\n\t\t}\n\t\treturn okWithValue(r2.offset, join(r1.value, r2.value));\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser one or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values. The parser is required to match at\n * least once, so an initial failure is returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply repeatedly\n */\nexport function plus<T>(parser: Parser<T>): Parser<T[]> {\n\treturn then(parser, star(parser), (v, vs) => [v].concat(vs));\n}\n\n/**\n * Returns the first of the given two arguments. Useful as a `join` function for `then`. See also\n * `followed`.\n *\n * @public\n *\n * @param x - Argument to return\n * @param y - Argument to ignore\n */\nexport function first<T1, T2>(x: T1, y: T2): T1 {\n\treturn x;\n}\n\n/**\n * Returns the second of the given two arguments. Useful as a `join` function for `then`. See also\n * `preceded`.\n *\n * @public\n *\n * @param x - Argument to ignore\n * @param y - Argument to return\n */\nexport function second<T1, T2>(x: T1, y: T2): T2 {\n\treturn y;\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result of the\n * second if the first succeeds.\n *\n * Equivalent to `then(before, parser, second)`.\n *\n * @public\n *\n * @param before - First parser to apply, value is discarded\n * @param parser - Second parser to apply, value is kept\n */\nexport function preceded<TBefore, T>(before: Parser<TBefore>, parser: Parser<T>): Parser<T> {\n\treturn then(before, parser, second);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result value of\n * the first at the offset of the second if both succeed. If either parser fails the error is\n * returned as-is.\n *\n * Equivalent to `then(parser, after, first)`.\n *\n * @public\n *\n * @param parser - First parser to apply, value is kept\n * @param before - Second parser to apply, value is discarded\n */\nexport function followed<T, TAfter>(parser: Parser<T>, after: Parser<TAfter>): Parser<T> {\n\treturn then(parser, after, first);\n}\n\n/**\n * Creates a Parser that applies the given parsers in sequence, returning the result value of the\n * middle parser at the offset of the third if all are successful. If any parser fails, the error is\n * returned as-is.\n *\n * Optionally makes errors by the second and third parsers fatal if `cutAfterOpen` is `true`.\n *\n * @public\n *\n * @param open         - First parser to apply, value is discarded\n * @param inner        - Second parser to apply, value is kept\n * @param close        - Third parser to apply, value is discarded\n * @param cutAfterOpen - If `true`, errors returned by the second and third parsers are considered\n *                       fatal, causing parsers using this to stop trying other branches.\n */\nexport function delimited<TOpen, T, TClose>(\n\topen: Parser<TOpen>,\n\tinner: Parser<T>,\n\tclose: Parser<TClose>,\n\tcutAfterOpen: boolean = false\n): Parser<T> {\n\tconst rest = cutAfterOpen ? cut(followed(inner, close)) : followed(inner, close);\n\treturn preceded(open, rest);\n}\n\n/**\n * Creates a Parser that applies the given parser. If successful, the inner parser's value is\n * discarded and the substring that was consumed from the input is returned as value instead. Errors\n * are returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and replaced by the consumed input.\n */\nexport function recognize<T>(parser: Parser<T>): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, input.slice(offset, res.offset));\n\t};\n}\n\n/**\n * Creates a Parser that applies the given parser without consuming any input. That is, if the inner\n * parser is successful, success is returned (with the resulting value) at the starting offset,\n * effectively making the parser consume no input.\n *\n * Errors returned by the inner parser are returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and any progress made in input is reset.\n */\nexport function peek<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(offset, res.value);\n\t};\n}\n\n/**\n * Creates a Parser that succeeds at the starting offset if the given parser fails and vice-versa.\n *\n * @public\n *\n * @param parser   - The parser to apply\n * @param expected - Expected values for parse errors generated when the inner parser succeeds\n */\nexport function not<T>(parser: Parser<T>, expected: string[]): Parser<void> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn ok(offset);\n\t\t}\n\t\treturn error(offset, expected);\n\t};\n}\n\n/**\n * Creates a Parser that matches only if the first Parser matches input at the starting position,\n * but the second Parser does not.\n *\n * @public\n *\n * @param match    - Parser that should match\n * @param except   - Parser that should not match\n * @param expected - Expected values for parse errors generated when the except parser succeeds\n */\nexport function except<T, U>(match: Parser<T>, except: Parser<U>, expected: string[]): Parser<T> {\n\treturn preceded(not(except, expected), match);\n}\n\n/**\n * Creates a Parser that turns errors returned by the inner parser into fatal errors. Parsers such\n * as `or` and `star` will not continue to attempt additional matches if a parser returns a fatal\n * error, and will usually return the error instead.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function cut<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn error(res.offset, res.expected, true);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * A parser that only succeeds at the start of the input string.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const start: Parser<void> = (_input, offset) =>\n\toffset === 0 ? ok(offset) : error(offset, ['start of input']);\n\n/**\n * A parser that only succeeds if the end of the input string is reached.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const end: Parser<void> = (input, offset) =>\n\tinput.length === offset ? ok(offset) : error(offset, ['end of input']);\n\n/**\n * Creates a Parser that applies the given parser and only succeeds (returning the inner parser's\n * result) if parsing concludes at the end of the input string.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function complete<T>(parser: Parser<T>): Parser<T> {\n\treturn then(parser, end, first);\n}\n","import { end, ok, Parser, ParseResult } from './parser-combinators';\n\n/**\n * Helper to collect both the yielded values and the returned value from a generator.\n *\n * @public\n *\n * @param gen - Generator to collect from\n */\nexport function collect<T, R>(gen: Generator<T, R>): [T[], R] {\n\tconst values: T[] = [];\n\tlet it = gen.next();\n\twhile (!it.done) {\n\t\tvalues.push(it.value);\n\t\tit = gen.next();\n\t}\n\treturn [values, it.value];\n}\n\n/**\n * A StreamingParser is similar to a Parser, but instead of returning a value when parsing is\n * complete it can parse incrementally and yield values as they are produced. The generator returns\n * a ParseResult when iteration is done which indicates whether parsing was successful.\n *\n * @public\n */\nexport type StreamingParser<T> = (\n\tinput: string,\n\toffset: number\n) => Generator<T, ParseResult<unknown>>;\n\n/**\n * Creates a StreamingParser which applies the given Parser and yields the value produced if it\n * matches.\n *\n * @public\n *\n * @param parser - The Parser to apply\n */\nexport function streaming<T>(parser: Parser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst res = parser(input, offset);\n\t\tif (res.success) {\n\t\t\tyield res.value;\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a StreamingParser which applies the given two StreamingParsers in sequence.\n *\n * Unlike `then`, this does not combine values using a function, but instead simply yields the\n * values produced by both parsers as they produce them.\n *\n * @public\n *\n * @param parser1 - First StreamingParser to apply\n * @param parser2 - StreamingParser to apply if the first one is successful\n */\nexport function streamingThen<T, U>(\n\tparser1: StreamingParser<T>,\n\tparser2: StreamingParser<U>\n): StreamingParser<T | U> {\n\treturn function* (input: string, offset: number) {\n\t\tconst res1 = yield* parser1(input, offset);\n\t\tif (!res1.success) {\n\t\t\treturn res1;\n\t\t}\n\t\treturn yield* parser2(input, res1.offset);\n\t};\n}\n\n/**\n * Creates a StreamingParser which discards undefined values yielded by the given StreamingParser.\n *\n * @public\n *\n * @param parser - The StreamingParser to filter\n */\nexport function streamingFilterUndefined<T>(parser: StreamingParser<T | void>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst gen = parser(input, offset);\n\t\tlet it = gen.next();\n\t\twhile (!it.done) {\n\t\t\tconst value = it.value;\n\t\t\tif (value !== undefined) {\n\t\t\t\tyield value;\n\t\t\t}\n\t\t\tit = gen.next();\n\t\t}\n\t\treturn it.value;\n\t};\n}\n\n/**\n * Creates a StreamingParser that tries to apply the given StreamingParser zero or more times in\n * sequence. Values produced during each iteration are only yielded whenever the inner parser\n * matches successfully.\n *\n * @public\n *\n * @param parser - StreamingParser to apply repeatedly\n */\nexport function streamingStar<T>(parser: StreamingParser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\twhile (true) {\n\t\t\tconst [values, result] = collect(parser(input, offset));\n\t\t\tif (!result.success) {\n\t\t\t\tif (result.fatal) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\treturn ok(offset);\n\t\t\t}\n\n\t\t\tyield* values;\n\n\t\t\tif (offset === result.offset) {\n\t\t\t\t// Did not advance\n\t\t\t\treturn ok(offset);\n\t\t\t}\n\t\t\toffset = result.offset;\n\t\t}\n\t};\n}\n\n/**\n * Creates a StreamingParser that tries to apply the given parser optionally. It only yields the\n * values produced by the inner parser if it matches successfully, and does not yield anything\n * otherwise.\n *\n * @public\n *\n * @param parser - StreamingParser to attempt to apply\n */\nexport function streamingOptional<T>(parser: StreamingParser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst [values, result] = collect(parser(input, offset));\n\t\tif (!result.success) {\n\t\t\tif (result.fatal) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn ok(offset);\n\t\t}\n\n\t\tyield* values;\n\n\t\treturn result;\n\t};\n}\n\n/**\n * Creates a StreamingParser that applies the given parser and directly yields values produced by\n * it, and then only succeeds if parsing concludes at the end of the input string.\n *\n * @public\n *\n * @param parser - StreamingParser to apply\n */\nexport function streamingComplete<T>(parser: StreamingParser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst res = yield* parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn end(input, res.offset);\n\t};\n}\n"],"names":["okWithValue","offset","value","success","ok","undefined","error","expected","fatal","map","parser","input","res","star","ts","nextOffset","push","then","parser1","parser2","join","r1","r2","first","x","y","second","preceded","before","followed","after","not","cut","end","length","collect","gen","values","it","next","done","open","inner","close","cutAfterOpen","match","except","filter","vs","v","parsers","lastError","concat","firstCodePoint","lastCodePoint","cp","codePointAt","char","String","fromCodePoint","slice","nCodepoints","i","_input","result","res1","token","offsetAfter"],"mappings":"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"}