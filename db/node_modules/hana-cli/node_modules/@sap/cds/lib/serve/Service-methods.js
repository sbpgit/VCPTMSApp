
module.exports = (srv) => {
  for (const each of srv.operations) {
    add_handler_for (srv, each)
  }
  for (const each of srv.entities) {
    for (const a in each.actions) {
      add_handler_for (srv, each.actions[a])
    }
  }
}

const add_handler_for = (srv, def) => {
  const event = def.name.match(/\w*$/)[0]

  // Use existing methods as handler implementations
  const method = srv[event]
  if (method) {
    if (method._is_stub || method.name in srv.__proto__.__proto__) return
    srv.on (event, function ({params,data}) {
      const args = []; if (def.parent) args.push (def.parent)
      for (let p in params) args.push(params[p])
      for (let p in data) args.push(data[p])
      return method.apply (this,args)
    })
  }

  // Add stub methods to send request via typed API
  const stub = srv[event] = function (...args) {
    const req = { event, data:{} }, $ = args[0]
    const target = this.entities [ $ && $.name ? $.name.match(/\w*$/)[0] : $ ]
    if (target) {                        //> bound action/function?
      req.target = target; args.shift() // first argument is the target entity name
      req.params = [ args.shift() ]    // second argument is the target's primary key
    }
    const {params} = target ? target.actions[event] : def
    if (params) req.data =  _named(args,params) || _positional(args,params)
    return this.send (req)
  }
  stub._is_stub = true
}


const _named = (args, declared) => {
  if (args.length > 1) return
  const a = args[0]
  if (! a || typeof a !== 'object') return
  if (Object.keys(a).every (k => k in declared)) return a
}

const _positional = (args, declared) => Object.keys(declared).reduce (
  (data,k,i) => { data[k] = args[i]; return data }, {}
)
