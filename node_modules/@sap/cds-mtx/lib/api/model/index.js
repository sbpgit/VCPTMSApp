const Tenant = require('../../tenant/index');
const readContent = require('./read_content');
const { activate, deactivate, reset, activateCsn } = require('./activate');
const GlobalConnections = require('../../helper/global_connections');
const SecurityHelper = require('../../helper/security_helper');
const HttpHelper = require('../../helper/http_helper');
const { SCOPES } = require('../../../config/constants');

const Logger = require('../../helper/logger');
const logger = Logger('MODEL');

const updateCustomContent = require('./update_content');

module.exports = () => function () {

    this.on('READ', 'content', readContent);

    this.on('activate', async context => {
        try {
            return await activate(context, false);
        } catch (error) {
            HttpHelper.handleError(context, error);
        }
    });

    this.on('deactivate', async context => {
        try {
            return await deactivate(context, false);
        } catch (error) {
            HttpHelper.handleError(context, error);
        }
    });

    this.on('reset', async context => {
        try {
            return await reset(context, false);
        } catch (error) {
            HttpHelper.handleError(context, error);
        }
    });

    this.on('activateCsn', async context => {
        try {
            return await activateCsn(context, false);
        } catch (error) {
            HttpHelper.handleError(context, error);
        }
    });

    this.on('asyncActivate', async context => {
        try {
            return await activate(context, true);
        } catch (error) {
            HttpHelper.handleError(context, error);
        }
    });

    this.on('asyncDeactivate', async context => {
        try {
            return await deactivate(context, true);
        } catch (error) {
            HttpHelper.handleError(context, error);
        }
    });

    this.on('asyncReset', async context => {
        try {
            return await reset(context, true);
        } catch (error) {
            HttpHelper.handleError(context, error);
        }
    });

    this.on('upgrade', async context => {
        HttpHelper.checkAnyScopeAndRespond(context, 'DEPLOYMENT');

        const tenantIds = context.data.tenants;
        const autoUndeploy = context.data.autoUndeploy;
        const advancedOptions = context.data.advancedOptions;

        try {
            return await Tenant.updateBaseModelSync({}, tenantIds, autoUndeploy, advancedOptions, context);
        } catch (error) {
            HttpHelper.handleError(context, error);
        }
    });

    this.on('asyncUpgrade', async (context) => {
        HttpHelper.checkAnyScopeAndRespond(context, 'DEPLOYMENT');

        // Major-TODO: We should use "tenantIds" consistently in our APIs
        const tenantIds = context.data.tenants;
        const autoUndeploy = context.data.autoUndeploy;
        const advancedOptions = context.data.advancedOptions;

        const callbackSettings = HttpHelper.getCallbackSettingsFromHeaders(context._.req);
        const authHeader = HttpHelper.getAuthFromHeaders(context._.req);

        const tenantId = SecurityHelper.getTenant(context);

        const { mtxCallbackUrl } = callbackSettings || {};

        try {
            const jobId = await Tenant.updateBaseModelAsync(tenantId, context, tenantIds, autoUndeploy, advancedOptions, authHeader, mtxCallbackUrl);
            context._.res.setHeader('Location', `/mtx/v1/model/status/${jobId}`);
            return context.reply({ jobID: jobId });
        } catch (error) {
            HttpHelper.handleError(context, error);
        }
    });

    this.on('READ', 'status', async context => {

        // Major-TODO: The (non-)capitalization of "ID" should be consistent in our APIs
        const { jobID: jobId } = context.data;
        const tenantId = SecurityHelper.getTenant(context);
        const allowOtherTenants = SecurityHelper.requestAllowed(null, tenantId, true);

        try {
            return await GlobalConnections.jobExecutor.getStatus(jobId, tenantId, allowOtherTenants);
        } catch (error) {
            HttpHelper.handleError(context, error);
        }
    });

    this.on('READ', 'logs', async context => {
        const jobId = context.data.jobID;
        // const tenantId = context.data.tenantId; // NOSONAR
        const tenantIdOfJob = SecurityHelper.getTenant(context);

        try {
            const status = await GlobalConnections.jobExecutor.getStatus(jobId, tenantIdOfJob);
            return status.result.tenants[tenantIdOfJob].buildLogs;
        } catch (error) {
            HttpHelper.handleError(context, error);
        }
    });

    this.before('*', 'customTenantContent', async context => {
        const tenantId = SecurityHelper.getTenant(context);

        const newTenant = `TENANT-${tenantId}-META`;
        if (context.attr) { // cds 3
            context.attr.identityZone = newTenant;
        } else {
            context.tenant = newTenant;
            context.user.tenant = newTenant; // Major-TODO: remove
        }
    });

    this.after('READ', 'customTenantContent', (result) => {
        for (const file of result) {
            file.content = file.content.toString('utf8');
        }
    });

    this.on('updateCustomTenantContent', updateCustomContent);

};
