const cds = require('../../cds');
const Tenant = require('../../tenant/index');
const Logger = require('../../helper/logger');
const logger = Logger('PROVISIONING');
const HttpHelper = require('../../helper/http_helper');
const EventTypeMissingError = require('../../errors/event_type_missing_error');
const TenantRequestHelper = require('../../helper/tenant_request_helper');

function _getSubscribedTenantId(context, statement) {
    const { data: { subscribedTenantId }, query } = context;
    return subscribedTenantId || TenantRequestHelper.getValueFromSingleKeyQuery(query[statement]);
}

module.exports = () => function () {
    this.on('READ', 'tenant', context => {
        HttpHelper.checkAnyScopeAndRespond(context, 'SUBSCRIPTION');

        const subscribedTenantId = _getSubscribedTenantId(context, 'SELECT');
        if (subscribedTenantId) {
            return Tenant.getMetadata(subscribedTenantId);
        }
        return Tenant.getAllWithMetadata();
    });

    this.on('CREATE', 'tenant', context => {
        context.reject(405);
    });

    this.on('DELETE', 'tenant', async context => {
        logger.debug(`DELETE tenant with:`, context.data);

        HttpHelper.checkAnyScopeAndRespond(context, 'SUBSCRIPTION');

        const subscribedTenantId = _getSubscribedTenantId(context, 'DELETE');
        if (!subscribedTenantId) {
            if (context._.res) {
                context._.res.status(400, 'No tenant');
            }
            return null;
        }
        const callbackSettings = HttpHelper.getCallbackSettingsFromHeaders(context._.req);
        const authHeader = HttpHelper.getAuthFromHeaders(context._.req);
        const jobID = await Tenant.delete(subscribedTenantId, null, context,
            callbackSettings,
            authHeader);
        if (callbackSettings) {
            // asynchronous call requires 'accepted'
            context._.res.status(202);
        }
        return jobID ? { jobID } : { };
    });

    this.on('UPDATE', 'tenant', async context => {
        logger.debug(`UPDATE tenant with:`, context.data);

        HttpHelper.checkAnyScopeAndRespond(context, 'SUBSCRIPTION');

        if (!context.data.eventType) {
            throw new EventTypeMissingError();
        }

        if (context.data.eventType === 'CREATE') {
            logger.debug(`Request headers: `, context._.req ? context._.req.headers : 'undefined');

            const subscribedTenantId = context.data.subscribedTenantId;
            const callbackSettings = HttpHelper.getCallbackSettingsFromHeaders(context._.req);
            const authHeader = HttpHelper.getAuthFromHeaders(context._.req);

            // add application url to payload from header (compatibility)
            const appUrl = HttpHelper.getAppUrlFromHeaders(context._.req);
            if (appUrl) {
                TenantRequestHelper.addSubscriptionUrl(context.data, appUrl);
            }

            const urlOrJobId = await Tenant.create(subscribedTenantId, context,
                callbackSettings,
                authHeader);
            if (callbackSettings) {
                // asynchronous call requires 'accepted'
                context._.res.status(202);
                return { jobID: urlOrJobId };
            } else {
                return urlOrJobId;
            }
        }

        return {};
    });

    this.before('dependencies', context => {
        HttpHelper.checkAnyScopeAndRespond(context, 'SUBSCRIPTION');
    });

    this.on('dependencies', (context) => {
        const { dependencies = [] } = cds.env.mtx;
        const returnedDependencies = dependencies.map(dependency => ({ 'xsappname': dependency }))
        logger.info(`Dependent applications/services:`, returnedDependencies);
        return returnedDependencies;
    });
};
