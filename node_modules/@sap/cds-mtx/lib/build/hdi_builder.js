const fs = require('fs');
const path = require('path');
const Logger = require('../helper/logger');
const FileSystemHelper = require('../helper/file_system_helper');
const parser = require('./hdi_migrationtable_util');
const BuildError = require('../errors/build_error');
const cds = require('@sap/cds');

const {
    COMPILED_FILES,
    BASE_MODEL_MIGRATION_FILTER,
    BASE_MODEL_FOLDER_FILTER,
    BASE_MODEL_NAME,
    BASE_MODEL_NATIVE_HANA_FILTER,
    BASE_MODEL_FILES_FILTER } = require('../../config/constants');

const BuildHelper = require('../helper/build_helper');

class HdiBuilder {

    constructor(tenantId) {
        this._compileBaseDirs = [];
        this._tenantId = tenantId;
        this.logger = Logger('Builder');
    }

    get projectPath() {
        return this._compileBaseDirs[0];
    }

    async _prepareCompileDir() {
        if (this._compileBaseDirs.length) {
            return { compileBaseDir: this._compileBaseDirs[0] };
        }

        const compileBaseDir = await FileSystemHelper.mkdirTemp();
        this._compileBaseDirs.push(compileBaseDir);

        await fs.promises.mkdir(path.join(compileBaseDir, 'db'));
        await fs.promises.mkdir(path.join(compileBaseDir, 'srv'));

        this.logger.debug(`Prepare compile dir for ${this._tenantId}: ${compileBaseDir}`);
        return { compileBaseDir };
    }

    /**
     * Writes all files from the map to the build space, creates a build space if necessary
     * @param files Files to write
     * @param intersectionWith List to check for intersection
     * @returns {Promise<void>}
     */
    async writeModelFiles(files) {
        await this._prepareCompileDir();
        return FileSystemHelper.writeFilesFromMap(files, this._compileBaseDirs[0]);
    }

    _isNativeHanaFile(filename) {
        return BASE_MODEL_NATIVE_HANA_FILTER.test(filename);
    }

    _isModelFile(filename) {
        return BASE_MODEL_FILES_FILTER.test(filename);
    }

    _adaptDbFolder(filename) {
        const substitutions = [
            [/^.+?\/src\//, 'db/src/'],
            [/^.+?\/data\//, 'db/data/'],
            [/^.+?\/csv\//, 'db/csv/'],
            [/^.+?\/last-dev\//, 'db/last-dev/']
        ];
        for (const [exp, replacement] of substitutions) {
            const regex = new RegExp(exp);
            if (regex.test(filename)) {
                return filename.replace(regex, replacement);
            }
        }
        return filename;
    }

    _setupBaseModelStructure(files) {
        const basemodelFiles = new Map();
        const basemodelFolders = new Set();

        for (const [filename, content] of files) {
            if (this._isNativeHanaFile(filename)) {
                // move hana files to right folder in project, do not store in node_modules/_base/
                basemodelFiles.set(this._adaptDbFolder(filename), content.toString('utf-8'));
            } else if (this._isModelFile(filename)) {
                const prefixedPath = path.join('node_modules', BASE_MODEL_NAME, filename);
                basemodelFiles.set(prefixedPath, content.toString('utf-8'));
                if (BASE_MODEL_FOLDER_FILTER.test(filename) && !/^node_modules\/.*/.test(filename)) {
                    basemodelFolders.add(path.dirname(filename));
                }
            } else {
                // warning
            }
        }

        return { basemodelFiles, basemodelFolders };
    }

    _intersectionList (files, intersectionKeys) {
        return new Map(Array.from(files).filter( entry => intersectionKeys.includes(entry[0]) ));
    }

    async setupProject(basemodelFiles, migrationFiles, extensionFiles) {
        await this._prepareCompileDir();

        const { basemodelFiles: movedBasemodelFiles, basemodelFolders } = this._setupBaseModelStructure(basemodelFiles);

        await this.writeModelFiles(movedBasemodelFiles);

        if (migrationFiles) {
            // to allow undeployment, list has to be filtered with the base model
            const filteredMigrationFiles = this._intersectionList(migrationFiles,
                [...Array.from(basemodelFiles.keys()), 'db/last-dev/csn.json']);
            await this.writeModelFiles(filteredMigrationFiles);
        }

        if (extensionFiles) {
            await this.writeModelFiles(extensionFiles);
        }

        return { basemodelFolders, basemodelFiles: movedBasemodelFiles, migrationFiles, extensionFiles };
    }

    /**
     * Merges the hdbmigrationtable files and writes them back to the build space
     * @param tenantMigrationFiles
     * @param newBasemodelMigrationFiles
     * @returns {Promise<void>}
     */
    async mergeMigrationFiles(tenantMigrationFiles, newBasemodelMigrationFiles) {

        const hmtResultFiles = new Map(Array.from(newBasemodelMigrationFiles).filter(([filename]) => /\/.*\.hdbmigrationtable/.test(filename)));
        for (const [filename, content] of tenantMigrationFiles) {
            if (/\/.*\.hdbmigrationtable/.test(filename)) {
                const tenantHmt = parser.parse(content);
                this.logger.debug(`Migrations from tenant for ${filename}: ${tenantHmt.migrations}`);

                if (newBasemodelMigrationFiles.get(filename)) {
                    const newBaseHmt = parser.parse(newBasemodelMigrationFiles.get(filename));
                    this.logger.debug(`Migrations from new basemodel for ${filename}: ${newBaseHmt.migrations}`);

                    const buildResultHmt = await parser.read(path.join(this.getBaseDir(), filename));

                    // merge tenantMigration file with base migration file and build result migration file
                    const finalHmt = tenantHmt.merge(newBaseHmt, buildResultHmt.table, false); // TODO activate in next rel
                    this.logger.debug(`Merged migrations for ${filename}: ${finalHmt.migrations}`);
                    this.logger.debug(`Merged table statement for ${filename}: ${finalHmt.table}`);

                    hmtResultFiles.set(filename, finalHmt.toString());
                } else {
                    // no need to merge, file exists only for tenant
                    // assuming that we do not allow hdbmigrationtable generation for extensions for no, files have to be
                    // ignored in this case
                    // TODO LATER we need the information from the build/diff if the file can be ignored
                    //hmtResultFiles.set(migrationFile[0], migrationFile[1]);
                }
            }
        }
        await this.writeModelFiles(hmtResultFiles);
        return hmtResultFiles;
    }

    getBaseDir() {
        return this.projectPath;
    }

    /**
     * Map of migration files, both hdbmigrationtable and last-dev/csn.json
     * @returns {Promise<*>}
     */
    async getMigrationFiles() {
        return FileSystemHelper.readAllFilesInDirectory(this.getBaseDir(), { filterExp: BASE_MODEL_MIGRATION_FILTER });
    }

    async destroy() {
        for (const compileBaseDir of this._compileBaseDirs) {
            this.logger.debug(`Cleaning compile dir: ${compileBaseDir}`);
            await fs.promises.rmdir(compileBaseDir, { recursive: true });
        }
    }

    async build(basemodelFolders, logCollector) {

        if (this.logger.hasLevel(this.logger.LOG_LEVELS && this.logger.LOG_LEVELS.debug)) {
            const allFiles = await FileSystemHelper.readAllFilesInDirectory(this.getBaseDir(), { skipContent: true });
            this.logger.debug(`Files to build: ${Array.from(allFiles.keys())}`);
        }

        try {
            const { dbDir, hana, languages, services, edmx, csnString, csnObject, odataCsnString, i18n } = await BuildHelper.build(this._compileBaseDirs[0], basemodelFolders, this._tenantId, logCollector);
            const compiledFiles = new Map([[COMPILED_FILES.CSN_NODE, csnString], [COMPILED_FILES.CSN, csnString], [COMPILED_FILES.ODATA_CSN, odataCsnString], ...edmx]);
            if (i18n) {
                // might be empty with older cds versions
                compiledFiles.set(COMPILED_FILES.I18N, i18n);
            }
            return { compiledFiles, csnObject, dbDir, languages, services, hana };
        } catch (error) {
            throw new BuildError(error);
        }
    }

    async toEdmx(service, version, locale) {

        const csn = await cds.load(path.join(this.getBaseDir(), 'csn.json'));

        const options = {
            version: version, // 'v2'|'v4'
            service: service
        };

        const odataCsn = cds.compile.for.odata(csn);
        const edmx = cds.compile.to.edmx(odataCsn, options);
        return cds.localize(odataCsn, locale, edmx);
    }

    async toEdmxFromOdataCsn(service, version, locale) {

        const odataCsn = require(path.join(this.getBaseDir(), 'odata_csn.json'));

        const options = {
            version: version, // 'v2'|'v4'
            service: service
        };

        const edmx = cds.compile.to.edmx(odataCsn, options);

        // only used for fallback
        odataCsn._i18nfolders = [ path.join(this.getBaseDir(), '_i18n') ];
        return cds.localize(odataCsn, locale, edmx);
    }
}

module.exports = HdiBuilder;
