const path = require('path');
const FileSystemHelper = require('../../helper/file_system_helper');
const Logger = require('../../helper/logger');
const logger = Logger('HDI_COMMON_PERSISTENCE');
const SessionHelper = require('../../helper/session_helper');
const { TENANT_META_TABLE_NAMES, GLOBAL_DATA_META_TENANT, META_TENANT_REGEX } = require('../../../config/constants');
const HdiContainerManager = require('./hdi_container_manager');
const HdiDeployment = require('../../tenant/deployment/hdi_deployment');

class HdiCommonPersistence {

    static async createTenant(tenantId, instanceManager, templateDir, { expectedTables = [], instanceManagerOptions = {} }) {

        const instanceData = await HdiContainerManager.createContainer(tenantId, instanceManager, instanceManagerOptions);

        const tablesToRedeploy = await this._redeployNeeded(tenantId, instanceData.credentials.schema, expectedTables);

        if (tablesToRedeploy.length > 0) {
            const options = { ignoreHdiOptions: true }; // skip hdi option from env for meta tenants

            logger.debug(`Redeployment is needed for tenant: ${tenantId}`);
            const dbDir = await HdiCommonPersistence.setupDeploymentDir(templateDir, tablesToRedeploy);
            await FileSystemHelper.copy(templateDir, dbDir);
            await HdiDeployment.deployModel(dbDir, instanceData, options);
        } else {
            logger.debug(`Redeployment is not needed for tenant: ${tenantId}`);
        }

        return instanceData;
    }

    // copy only selectively per requested table
    static async setupDeploymentDir(templateDir, tablesToDeploy) {
        templateDir = path.resolve(__dirname, '../../..', templateDir);
        const tempDir = await FileSystemHelper.mkdirTemp();
        const dbDir = path.join(tempDir, 'db');

        logger.debug(`"db" directory is: ${dbDir}`);

        await FileSystemHelper.mkdirp(dbDir);

        for (const tableName of tablesToDeploy) {
            await FileSystemHelper.copy(path.join(templateDir, tableName), dbDir, { overwrite: false });
        }

        await FileSystemHelper.copy(path.join(templateDir, 'src'), path.join(dbDir, 'src'), { overwrite: false });

        const undeploySource = path.join(templateDir, 'undeploy.json');
        if (await FileSystemHelper.pathExists(undeploySource)) {
            await FileSystemHelper.copy(undeploySource, path.join(dbDir, 'undeploy.json'), { overwrite: false });
        }

        return dbDir;
    }

    static async tenantExists(tenantId, instanceManager) {
        return await instanceManager.get(tenantId) !== null;
    }

    static async _redeployNeeded(tenantId, schema, expectedTables) {
        logger.debug(`Check if redeployment is needed for tenant: ${tenantId}`);

        if (expectedTables.length === 0) {
            return expectedTables;
        }

        const client = await SessionHelper.acquire(tenantId);

        try {
            const tables = await client.execute('SELECT TABLE_NAME FROM TABLES WHERE SCHEMA_NAME = ?', [schema]);
            logger.debug(`Tables found: `, tables);
            if (!tables) {
                return expectedTables;
            }
            const tableNames = tables.map(table => table.TABLE_NAME);

            const tablesToRedeploy = new Set();

            expectedTables.forEach(expectedTable => {
                if (!tableNames.includes(expectedTable)) {
                    tablesToRedeploy.add(expectedTable);
                }
            });

            await this._checkColumnTypeChanges(client, expectedTables, schema, tablesToRedeploy);

            return Array.from(tablesToRedeploy.keys());
        } finally {
            await SessionHelper.release(client);
        }
    }

    static async _checkColumnTypeChanges(client, expectedTables, schema, tablesToRedeploy) {

        const existingTypes = await client.execute('SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE_NAME, LENGTH FROM TABLE_COLUMNS ' +
            'WHERE SCHEMA_NAME = ?', [schema]);

        const expectedTypes = [
                {
                    TABLE_NAME: TENANT_META_TABLE_NAMES.CUSTOM_TENANT_CONTENT,
                    COLUMN_NAME: 'NAME',
                    DATA_TYPE_NAME: 'NVARCHAR',
                    LENGTH: 500
                },
                {
                    TABLE_NAME: TENANT_META_TABLE_NAMES.CUSTOM_TENANT_CONTENT,
                    COLUMN_NAME: 'CONTENT',
                    DATA_TYPE_NAME: 'NCLOB'
                },
                {
                    TABLE_NAME: TENANT_META_TABLE_NAMES.TENANT_FILES,
                    COLUMN_NAME: 'CONTENT',
                    DATA_TYPE_NAME: 'NCLOB'
                },
                {
                    TABLE_NAME: TENANT_META_TABLE_NAMES.TENANT_FILES,
                    COLUMN_NAME: 'FILENAME',
                    DATA_TYPE_NAME: 'NVARCHAR',
                    LENGTH: 500
                }
            ];

        for (const expectedType of expectedTypes) {
            for (const field of Object.keys(expectedType)) {
                const existingType = existingTypes.find(type => (type.COLUMN_NAME === expectedType.COLUMN_NAME)
                    && (type.TABLE_NAME === expectedType.TABLE_NAME)
                    && (expectedTables.includes(type.TABLE_NAME)));
                if (existingType && existingType[field] !== expectedType[field]) {
                    logger.log(`Datatype of ${expectedType.TABLE_NAME} has changed, redeployment will be done`);
                    tablesToRedeploy.add(expectedType.TABLE_NAME);
                }
            }
        }
    }

}

module.exports = HdiCommonPersistence;
