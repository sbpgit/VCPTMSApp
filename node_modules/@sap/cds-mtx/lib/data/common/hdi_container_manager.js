const Logger = require('../../helper/logger');
const logger = Logger('HDI_CONTAINER_MANAGER');
const MAX_ATTEMPTS = 3;
const { GLOBAL_DATA_META_TENANT } = require('../../../config/constants');

const cds = require('@sap/cds');
const TenantCorruptedError = require('../../errors/tenant_corrupted_error');
const TenantCreationError = require('../../errors/tenant_creation_error');

class HdiContainerManager {

    static _getInstanceManagerOptionsFromEnv() {
        try {
            const provisioningParameters = cds.env.get('mtx.provisioning.container');
            if (provisioningParameters) {
                return provisioningParameters;
            }
        } catch (error) {
            logger.error(error);
        }
        return {};
    }

    static async createContainer(tenantId, instanceManager, instanceManagerOptions = {}) {
        let instanceData;
        let bindingsMissing = false;
        try {
            instanceData = await instanceManager.get(tenantId);
        } catch(error) {
            bindingsMissing = error.message.startsWith('Instance, but no bindings');
            bindingsMissing ? logger.debug(error) : logger.error(error);
        }

        const effectiveInstanceManagerOptions =
            (instanceManagerOptions && Object.keys(instanceManagerOptions).length) ? instanceManagerOptions
                : HdiContainerManager._getInstanceManagerOptionsFromEnv();

        const attemptContainerCreation = async (attempt = 1) => {
            if (attempt > MAX_ATTEMPTS) {
                logger.info(`Creating tenant has failed ${MAX_ATTEMPTS} times. Aborting container creation.`);
                throw new TenantCreationError(tenantId);
            } else if (attempt > 1) {
                logger.info(`Retrying tenant creation (attempt ${attempt} of ${MAX_ATTEMPTS})â€¦`);
            }

            logger.debug(`Instance manager options:`, effectiveInstanceManagerOptions);

            try {
                instanceData = await instanceManager.create(tenantId, effectiveInstanceManagerOptions);
                logger.info(`Successfully created new tenant with ID ${tenantId}`);
            } catch (error) {
                logger.error(error);
                await this._validateContainer(tenantId, instanceData, instanceManager, true);
                await attemptContainerCreation(attempt + 1);
            }
        };

        const { MTX_ROLLBACK_CORRUPTED_CONTAINER } = process.env
        const deleteIfCorrupted = MTX_ROLLBACK_CORRUPTED_CONTAINER && MTX_ROLLBACK_CORRUPTED_CONTAINER.toLowerCase() === 'true';
        const containerIsValid = await this._validateContainer(tenantId, instanceData, instanceManager, deleteIfCorrupted, bindingsMissing);
        if (!containerIsValid) {
            await attemptContainerCreation()
        }
        return instanceData;
    }

    static async _validateContainer(tenantId, instanceData, instanceManager, deleteIfCorrupted, hasNoBindings) {
        const hasValidSchema = instanceData && instanceData.credentials && instanceData.credentials.schema;
        const hasValidStatus = instanceData && instanceData.status !== 'CREATION_FAILED';

        if (hasValidSchema && hasValidStatus) {
            logger.debug(`Tenant ${tenantId} exists and is healthy`);
        }  else if (instanceData) {
            logger.info(`Faulty tenant ${tenantId} exists with status ${instanceData.status}`);
            logger.debug(`Data returned from instance manager:`, instanceData);

            if (!instanceData.credentials) {
                logger.debug(`Credentials missing for created tenant`);
            }
            if (instanceData.credentials && !instanceData.credentials.schema) {
                logger.debug(`Tenant schema missing`);
            }

            if (!hasValidStatus || deleteIfCorrupted || tenantId === GLOBAL_DATA_META_TENANT) {
                logger.info(`Deleting corrupted tenant with ID ${tenantId}`);
                await instanceManager.delete(tenantId);
            } else {
                throw new TenantCorruptedError(tenantId);
            }
        } else if (hasNoBindings && deleteIfCorrupted) {
            logger.info(`Deleting tenant with ID ${tenantId} due to missing bindings`);
            await instanceManager.delete(tenantId);
        } else {
            logger.debug(`Tenant does not exist`);
        }
        return hasValidSchema && hasValidStatus;
    }
}

module.exports = HdiContainerManager;
