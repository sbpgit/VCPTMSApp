const Logger = require('../../helper/logger');
const logger = Logger('HDI_APPLICATION_DATA_PERSISTENCE');
const SessionHelper = require('../../helper/session_helper');
const HdiCommonPersistence = require('../common/hdi_common_persistence');
const path = require('path');
const TenantRequestHelper = require('../../helper/tenant_request_helper');
const InstanceManagerFactory = require('../../helper/cf/instance_manager_factory');
const Env = require('../../helper/cf/env');
const { GLOBAL_DATA_META_TENANT, META_TABLES, UPDATE_TYPE } = require('../../../config/constants');
const HdiContainerManager = require('../common/hdi_container_manager');
const TenantOffboardingError = require('../../errors/tenant_offboarding_error');
const JobNotFoundError = require('../../errors/job_not_found_error');
const TenantMissingError = require('../../errors/tenant_missing_error');
const Job = require('../../jobs/job');
const cds = require('@sap/cds');

const TEMPLATE_DIR = path.join(__dirname, 'templates', 'hdi_application_data_persistence');

const REGULAR_JOB_CLEANUP_AGE = 60 * 60 * 1000;
const STALE_JOB_CLEANUP_AGE = 7 * 24 * 60 * 60 * 1000;

class HdiApplicationDataPersistence {

    static async _getInstanceManager() {
        return InstanceManagerFactory.get();
    }

    static get _globalMetaTenantId() {
        return Env.getValueOrDefault('GLOBAL_DATA_META_TENANT', GLOBAL_DATA_META_TENANT);
    }

    static async initGlobalMetaTenantIfNeeded() {
        const instanceManager = await this._getInstanceManager();
        logger.debug(`Creating global meta tenant if needed ${this._globalMetaTenantId}`);
        await HdiCommonPersistence.createTenant(this._globalMetaTenantId, instanceManager, TEMPLATE_DIR, { expectedTables: META_TABLES });

        // cleanup finished and failed jobs after 60 min
        const cleanupAgeRegular = cds.env.get('mtx.jobs.cleanup.regular') || REGULAR_JOB_CLEANUP_AGE;
        // cleanup stale running and queued jobs after 7 days
        const cleanupAgeStale = cds.env.get('mtx.jobs.cleanup.stale') || STALE_JOB_CLEANUP_AGE;

        await HdiApplicationDataPersistence.cleanupJobs(cleanupAgeRegular);

        const {RUNNING, QUEUED} = Job.EXECUTION_STATUS;
        await HdiApplicationDataPersistence.cleanupJobs(cleanupAgeStale, [RUNNING, QUEUED]);
    }

    static async logUpdate(tenantId, domain, updateType) {
        logger.debug(`Log update for: ${tenantId} in: ${this._globalMetaTenantId}`);

        const client = await SessionHelper.acquire(this._globalMetaTenantId);
        try {
            const timestamp = new Date();
            const timestampIso = timestamp.toISOString();
            const parameters = [tenantId, domain, timestampIso, updateType, tenantId, domain, updateType];

            // as soon as we skip the cds 3 compatibility, this has to be switched to cds transactions

            try {
                await client.begin();

                if ([UPDATE_TYPE.CREATE, UPDATE_TYPE.DELETE].includes(updateType)) {
                    // Delete entries for create and delete events
                    await client.execute(`DELETE FROM TENANT_UPDATES WHERE TENANT_ID = ? AND DOMAIN = ? AND TYPE IN (?, ?)`,
                        [tenantId, domain, UPDATE_TYPE.DELETE, UPDATE_TYPE.CREATE]);
                }

                await client.execute('UPSERT TENANT_UPDATES(TENANT_ID, DOMAIN, TIMESTAMP, TYPE) VALUES(?, ?, ?, ?) ' +
                    'WHERE TENANT_ID = ? AND DOMAIN = ? AND TYPE = ?', parameters);

                await client.commit();

                logger.info(`Logged update for tenant ${tenantId} (${domain}, ${updateType}) at ${timestamp.toUTCString()}`);
            } catch (error) {
                await client.rollback();
                throw error;
            }

            const UpdateEventEmitter = require('../../event/update_event_emitter');
            logger.debug(`Directly emit update event for tenant ${tenantId}`);
            UpdateEventEmitter.emitUpdate(tenantId, timestamp, updateType);
        } finally {
            await SessionHelper.release(client);
        }

    }

    static async loadUpdates(domain) {

        try {
            const client = await SessionHelper.acquire(this._globalMetaTenantId);

            try {
                const result = await client.execute('SELECT TENANT_ID, TIMESTAMP, TYPE FROM TENANT_UPDATES WHERE DOMAIN = ?', [domain]);
                return result || [];
            } finally {
                await SessionHelper.release(client);
            }

        } catch (e) {
            logger.info(`No __META__ tenant accessible yet (this might be ok): %s`, e);
            return [];
        }

    }

    static async onboardTenant(tenantId, tenantMetadata) {
        logger.info(`Onboarding tenant ${tenantId}`);
        const instanceManagerOptions = TenantRequestHelper.getInstanceManagerOptions(tenantMetadata);
        const instanceManager = await this._getInstanceManager();
        return await HdiCommonPersistence.createTenant(tenantId, instanceManager, undefined, { instanceManagerOptions });
    }

    static async refreshConnection(tenantId) {
        await SessionHelper.refresh(tenantId);
    }

    static async getTables(tenantId) {
        const client = await SessionHelper.acquire(tenantId);
        try {
            const instanceManager = await this._getInstanceManager();
            const instanceData = await instanceManager.get(tenantId);
            return await client.execute(
                `SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE_NAME
                 FROM TABLE_COLUMNS
                 WHERE SCHEMA_NAME = ?
                 ORDER BY TABLE_NAME`
            , [instanceData.credentials.schema]) || [];
        } finally {
            await SessionHelper.release(client);
        }
    }

    static async offboardTenant(tenantId) {
        try {
            const instanceManager = await this._getInstanceManager();
            await instanceManager.delete(tenantId);
            await this._deleteUpdate(tenantId, { all: true });
        } catch (error) {
            if (error.statusCode === 404 || error.code === 404) { // offboarding is idempotent
                logger.info(`Tenant ${tenantId} does not exist`);
            } else {
                logger.error(error);
                throw new TenantOffboardingError(tenantId, error.message);
            }
        }
    }

    static async _deleteUpdate(tenantId, { domain = null, all = false }) {

        try {
            const client = await SessionHelper.acquire(this._globalMetaTenantId);

            try {
                let statement = 'DELETE FROM TENANT_UPDATES WHERE TENANT_ID = ? AND DOMAIN = ?';
                let parameters = [tenantId, domain];

                if (all) {
                    statement = 'DELETE FROM TENANT_UPDATES WHERE TENANT_ID = ?';
                    parameters = [tenantId];
                }

                await client.execute(statement, parameters);
                logger.debug(`Deleted update timestamp for tenant: ${tenantId} (${domain})`);
            } finally {
                await SessionHelper.release(client);
            }
        } catch (e) {
            logger.error(e);
        }
    }

    static async getExtendedTenantIdsFrom(tenantIds, domain) {
        const client = await SessionHelper.acquire(this._globalMetaTenantId);
        try {
            const tenants = await client.execute('SELECT TENANT_ID FROM TENANT_UPDATES WHERE DOMAIN = ? AND TYPE = ?', [domain, UPDATE_TYPE.EXTENSION]);
            return tenants && tenants.map(({TENANT_ID}) => TENANT_ID).filter(tenantId => tenantIds.includes(tenantId)) || [];
        } finally {
            await SessionHelper.release(client);
        }
    }

    static async isExtended(tenantId, domain) {
        const client = await SessionHelper.acquire(this._globalMetaTenantId);
        try {
            const result = await client.execute('SELECT TENANT_ID, TIMESTAMP FROM TENANT_UPDATES ' +
                'WHERE TENANT_ID = ? AND DOMAIN = ? AND TYPE = ?', [tenantId, domain, UPDATE_TYPE.EXTENSION]);
            return result && result.length > 0;
        } finally {
            await SessionHelper.release(client);
        }
    }

    static async getTimestamps(tenantId, domain) {
        try {
            const client = await SessionHelper.acquire(this._globalMetaTenantId);

            try {
                const result = await client.execute('SELECT TENANT_ID, TIMESTAMP FROM TENANT_UPDATES WHERE TENANT_ID = ? AND DOMAIN = ?', [tenantId, domain]);
                logger.debug(`Found model timestamp`, result);
                return result && result.length > 0 ? result.map(({TIMESTAMP}) => TIMESTAMP) : []
            } finally {
                await SessionHelper.release(client);
            }
        } catch (error) {
            logger.error(error);
            return null;
        }
    }

    static async getInstanceData(tenantId) {
        const instanceManager = await this._getInstanceManager();
        const instanceData = await instanceManager.get(tenantId);
        if (!instanceData) {
            return null; // We don't want to create a non-existing tenant here
        }
        // Validates the tenant and recreates it if `MTX_ROLLBACK_CORRUPTED_CONTAINER` is set
        return await HdiContainerManager.createContainer(tenantId, instanceManager);
    }

    static async getAllTenants() {
        return (await this._getInstanceManager()).getAll();
    }

    static async tenantExists(tenantId) {
        return HdiCommonPersistence.tenantExists(tenantId, await this._getInstanceManager());
    }

    static async getContainerData(tenantId) {
        const data = await (await this._getInstanceManager()).get(tenantId);
        if (!data) throw new TenantMissingError(tenantId);
        return data;
    }

    static async upsertJobStatus(job) {
        const { jobId, tenantId, status, result, limit = new Date() } = job;
        const timestamp = limit.toISOString();
        const resultString = result ? JSON.stringify(result) : '';
        const statement = 'UPSERT JOBS(JOB_ID, TENANT_ID, STATUS, RESULT, TIMESTAMP) values (?, ?, ?, ?, ?) WHERE JOB_ID = ? AND TENANT_ID = ?';
        const params = [jobId, tenantId, status, resultString, timestamp, jobId, tenantId];

        try {
            return await this._executeStatement(statement, params);
        } catch (error) {
            logger.error(`Failed to persist job status for job ${jobId}`);
        }
    }

    static async getAllJobs(tenantId) {
        let statement = tenantId ? 'SELECT TENANT_ID, JOB_ID, STATUS, RESULT, TIMESTAMP FROM JOBS WHERE TENANT_ID = ?'
                                 : 'SELECT TENANT_ID, JOB_ID, STATUS, RESULT, TIMESTAMP FROM JOBS';
        let params = tenantId ? [ tenantId ] : [];

        try {
            const result = await this._executeStatement(statement, params);

            const allJobs = [];
            for (const oneResult of result) {
                allJobs.push({
                    jobId: oneResult.JOB_ID,
                    tenantId: oneResult.TENANT_ID,
                    jobStatus: oneResult.STATUS,
                    result: (oneResult.RESULT && oneResult.RESULT.length) ? JSON.parse(oneResult.RESULT.toString('utf-8')) : null,
                    timestamp: oneResult.TIMESTAMP,
                    processId: -1
                });
            }

            return allJobs;
        } catch (e) {
            logger.error(e);
            return null;
        }
    }

    static async getJobStatus(jobId, tenantId, allowAll) {
        const statement = `SELECT STATUS, RESULT, TIMESTAMP FROM JOBS WHERE JOB_ID = ? ${!allowAll ? 'AND TENANT_ID = ?' : ''}`;
        const params = !allowAll ? [jobId, tenantId] : [jobId];

        try {
            const [job] = await this._executeStatement(statement, params);
            return {
                jobStatus: job.STATUS,
                result: job.RESULT ? JSON.parse(job.RESULT.toString('utf-8')) : null,
                timestamp: job.TIMESTAMP,
                processId: -1
            };
        } catch (e) {
            logger.error(e);
            throw new JobNotFoundError(jobId);
        }
    }

    static async deleteJobStatus(jobId, tenantId) {
        const statement = 'DELETE FROM JOBS WHERE JOB_ID = ? AND TENANT_ID = ?';
        const params = [ jobId, tenantId ];
        return this._executeStatement(statement, params);
    }

    static async cleanupJobs(offsetMillis = 30000, status = [Job.EXECUTION_STATUS.FINISHED, Job.EXECUTION_STATUS.FAILED]) {
        const oldestTimestamp = new Date(Date.now() - offsetMillis).toISOString();
        const statusList = status.map(s => `'${s}'`).join(',');

        const statement = `DELETE FROM JOBS WHERE TIMESTAMP < TO_TIMESTAMP(?) AND STATUS IN (${statusList})`;
        const params = [oldestTimestamp];
        const result = await this._executeStatement(statement, params);
        logger.debug(`Cleaned up job ${result} entries older than ${oldestTimestamp} with status ${statusList}`);
        return result;
    }

    static async _executeStatement(statement, params) {
        let client;
        try {
            client = await SessionHelper.acquire(this._globalMetaTenantId);
            return client.execute(statement, params);
        } finally {
            if (client) {
                await SessionHelper.release(client);
            }
        }
    }
}

module.exports = HdiApplicationDataPersistence;
