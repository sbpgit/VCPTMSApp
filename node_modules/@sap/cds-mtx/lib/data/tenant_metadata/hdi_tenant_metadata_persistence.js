const TenantMetadataPersistence = require('./tenant_metadata_persistence');
const TenantRequestHelper = require('../../helper/tenant_request_helper');
const path = require('path');
const HdiCommonPersistence = require('../common/hdi_common_persistence');
const SessionHelper = require('../../helper/session_helper');

const {
    MODEL_TYPE,
    METADATA_TYPE,
    BASE_MODEL_NAME,
    TENANT_META_TABLE_NAMES,
    BASE_MODEL_FOLDER_FILTER,
    BASE_MODEL_NATIVE_HANA_FILTER,
    BASE_MODEL_FILES_FILTER,
    BASE_MODEL_EXTENSION_PROJECT_FILTER
} = require('../../../config/constants');
const TenantOffboardingError = require('../../errors/tenant_offboarding_error');
const FileSystemHelper = require('../../helper/file_system_helper');

const TEMPLATE_DIR = path.join(__dirname, 'templates', 'hdi_tenant_metadata_tables');

const DELETE_FILES_STATEMENT = 'DELETE FROM TENANT_FILES WHERE TYPE = ? AND DOMAIN = ?';
const INSERT_FILES_STATEMENT = 'INSERT INTO TENANT_FILES (FILENAME, TYPE, CONTENT, DOMAIN) VALUES (?, ?, ?, ?)';
const MODEL_FILE_QUERY = 'SELECT FILENAME, CONTENT, TYPE FROM TENANT_FILES WHERE TYPE = ? AND DOMAIN = ?';
const CONTENT_FILE_QUERY = 'SELECT CONTENT FROM TENANT_FILES WHERE TYPE = ? AND FILENAME = ? AND DOMAIN = ? LIMIT 1';
const CONTENT_METADATA_QUERY = 'SELECT CONTENT FROM TENANT_METADATA WHERE ID = ? AND DOMAIN = ? LIMIT 1';

class HdiTenantMetadataPersistence extends TenantMetadataPersistence {

    constructor(options, instanceManager, baseModel, domain) {
        super(options, domain, 'HDI_TENANT_METADATA_PERSISTENCE');
        this._instanceManager = instanceManager;
        this._baseModel = baseModel;
    }

    async init(tenantId, tenantMetadata, retry) {
        const created = await this.onboardMetaTenant(tenantId, tenantMetadata, retry);
        await this.begin(tenantId);
        return created;
    }

    async begin(tenantId) {
        this.logger.debug(`Begin session for: ${tenantId}`);
        const tenantMetaID = HdiTenantMetadataPersistence._prefixTenant(tenantId);
        this._tenantId = tenantId;
        this._client = await SessionHelper.acquire(tenantMetaID);
        this.logger.debug(`Session started for: ${tenantId}`);
    }

    async destroy() {
        if (this._client) {
            await SessionHelper.release(this._client);
        }
    }

    async _createTenant(tenantMetaID, instanceManager, templateDir, tenantMetaTables, instanceManagerOptions) {
        return HdiCommonPersistence.createTenant(tenantMetaID, instanceManager, templateDir, { expectedTables: tenantMetaTables, instanceManagerOptions });
    }

    async onboardMetaTenant(tenantId, tenantMetadata) {
        this.logger.info(`Onboarding meta tenant for tenant ${tenantId}`);
        const instanceManagerOptions = TenantRequestHelper.getInstanceManagerOptions(tenantMetadata);
        const tenantMetaID = HdiTenantMetadataPersistence._prefixTenant(tenantId);
        await this._createTenant(tenantMetaID, this._instanceManager, TEMPLATE_DIR, Object.values(TENANT_META_TABLE_NAMES), instanceManagerOptions);
    }

    async _saveExecute(statement, parameter) {
        return this._client.saveExecute(statement, parameter);
    }

    static async refreshConnection(tenantId) {
        const tenantMetaID = HdiTenantMetadataPersistence._prefixTenant(tenantId);
        await SessionHelper.refresh(tenantMetaID);
    }

    async saveBaseModel() {
        const baseModel = new Map();

        this.logger.debug('Inserting base model');

        const files = [];
        for (const [filename, content] of this._baseModel.sourceFiles) {
            const unixFilename = FileSystemHelper.unixPath(filename);
            this.logger.debug('Basemodel file to upload: ', unixFilename);
            files.push([unixFilename, MODEL_TYPE.base, content, this.domain]);
            baseModel.set(unixFilename, content);
        }

        await this._saveFileList(MODEL_TYPE.base, files)

        this.logger.debug('Base model inserted');
        return baseModel;
    }

    async offboardMetaTenant(tenantId) {
        this.logger.info(`Offboarding meta tenant ${tenantId}`);

        const tenantMetaID = HdiTenantMetadataPersistence._prefixTenant(tenantId);

        try {
            await this._instanceManager.delete(tenantMetaID);
        } catch (error) {
            if (error.statusCode === 404 || error.code === 404) { // offboarding is idempotent
                this.logger.debug(error);
            } else {
                throw new TenantOffboardingError(tenantId, error.message);
            }
        }
        this.logger.info(`Offboarded meta tenant ${tenantId}`);
    }

    async getBaseModelFilesRaw() {
        const params = [MODEL_TYPE.base, this.domain];
        const files = await this._client.execute(MODEL_FILE_QUERY, params);
        return new Map(files.map(({FILENAME, CONTENT}) => [FILENAME, CONTENT.toString('utf-8')]));
    }

    async getExtensionFiles() {
        const params = [MODEL_TYPE.extension, this.domain];
        const files = await this._client.execute(MODEL_FILE_QUERY, params);
        return new Map(files.map(({FILENAME, CONTENT}) => [FILENAME, CONTENT.toString('utf-8')]));
    }

    async saveMigrationFiles(files) {

        const fileList = [];
        for (const [filename, content] of files) {
            const unixFilename = FileSystemHelper.unixPath(filename);
            fileList.push([unixFilename, MODEL_TYPE.migration, content, this.domain]);
        }

        await this._saveFileList(MODEL_TYPE.migration, fileList);
    }

    async getMigrationFiles() {
        const params = [MODEL_TYPE.migration, this.domain];

        const files = await this._client.execute(MODEL_FILE_QUERY, params);
        const filesMap = new Map();

        files.forEach(file => {
            filesMap.set(file.FILENAME, file.CONTENT.toString('utf-8'));
        });

        return filesMap;
    }

    async saveCompiledFiles(files) {

        const fileList = [];
        for (const [filename, content] of files) {
            const unixFilename = FileSystemHelper.unixPath(filename);
            fileList.push([unixFilename, MODEL_TYPE.compiled, content, this.domain]);
        }

        await this._saveFileList(MODEL_TYPE.compiled, fileList);
    }

    async _saveFileList(fileType, fileList) {

        await this._client.begin();
        try {
            await this._client.execute(DELETE_FILES_STATEMENT, [fileType, this.domain]);
            if (fileList.length > 0) {
                await this._client.execute(INSERT_FILES_STATEMENT, fileList);
            }
            await this._client.commit();
        } catch (error) {
            await this._client.rollback();
            throw error;
        }
    }

    async saveExtension(extensionFiles, undeployExtension = false) {
        this.logger.debug(`Saving extension for tenant: ${this._tenantId}`);

        if (undeployExtension) {
            this.logger.debug('Deleting old extension');

            await this._client.execute(DELETE_FILES_STATEMENT, [MODEL_TYPE.extension, this.domain]);
        }

        const upsertSql = 'UPSERT TENANT_FILES (FILENAME, TYPE, CONTENT, DOMAIN) VALUES (?, ?, ?, ?) WHERE FILENAME = ? AND TYPE = ? AND DOMAIN = ?';

        const extensionFileList = [];
        for (const [filename, content] of extensionFiles) {
            const unixFilename = FileSystemHelper.unixPath(filename);
            this.logger.debug('Extension file to upload: ', unixFilename);
            extensionFileList.push([unixFilename, MODEL_TYPE.extension, content, this.domain, unixFilename, MODEL_TYPE.extension, this.domain]);
        }
        if (extensionFileList.length > 0) {
            await this._saveExecute(upsertSql, extensionFileList);
        }
    }

    async getModelContent(modelFilename) {
        const unixFilename = FileSystemHelper.unixPath(modelFilename);
        this.logger.debug(`Converted to: ${unixFilename}`);
        const properties = [MODEL_TYPE.compiled, unixFilename, this.domain];
        const [savedModel] = await this._client.execute(CONTENT_FILE_QUERY, properties);
        if (!savedModel) return null;
        const { CONTENT } = savedModel;
        return typeof CONTENT !== 'string' ? CONTENT.toString('utf-8') : CONTENT;
    }

    async saveOnboardingMetadata(metadata) {
        this.logger.debug(`Save metadata for tenant: ${this._tenantId}`, metadata);
        await this._saveMetadata(METADATA_TYPE.onboarding, metadata, this.domain);
    }

    async getTenantAppname() {
        const metadata = await this.getOnboardingMetadata();
        return metadata.subscriptionAppName;
    }

    async getOnboardingMetadata() {
        const { CONTENT } = await this._getMetadata(METADATA_TYPE.onboarding, this.domain);
        return CONTENT ? JSON.parse(CONTENT) : {};
    }

    async _getMetadata(id, domain) {
        try {
            const result = await this._client.execute(CONTENT_METADATA_QUERY, [id, domain]);
            return result && result[0] || {};
        } catch (error) {
            this.logger.error(`Failed to query metadata for tenant '${id}' (domain: ${domain}): ${error}`);
            throw error;
        }
    }

    async saveLanguages(languages) {
        const languagesArray = Array.from(languages);
        this.logger.debug(`Save languages for tenant ${this._tenantId}: `, languagesArray);
        await this._saveMetadata(METADATA_TYPE.languages, languagesArray, this.domain);
    }

    async getLanguages() {
        this.logger.debug('Loading languages');
        const { CONTENT } = await this._getMetadata(METADATA_TYPE.languages, this.domain);
        this.logger.debug('Languages loaded');
        return CONTENT ? JSON.parse(CONTENT) : {};
    }

    async saveServices(services) {
        const servicesArray = Array.from(services);
        this.logger.debug(`Save services for tenant: ${this._tenantId} : `, servicesArray);
        await this._saveMetadata(METADATA_TYPE.services, servicesArray, this.domain);
    }

    async getServices() {
        const { CONTENT } = await this._getMetadata(METADATA_TYPE.services, this.domain);
        return CONTENT ? JSON.parse(CONTENT) : {};
    }

    async saveUndeployWhitelist(whitelist, undeploy) {
        this.logger.debug(`Save undeploy whitelist for tenant ${this._tenantId}: `, whitelist);

        let effectiveWhitelist = whitelist;

        if (!undeploy) {
            const existingWhitelist = await this.getUndeployWhitelist(this.domain);
            effectiveWhitelist = this._mergeWhitelists(whitelist, existingWhitelist);
        }

        await this._saveMetadata(METADATA_TYPE.undeploy, effectiveWhitelist, this.domain);
    }

    _mergeWhitelists(whitelist, existingWhitelist) {
        return Array.from(new Set(whitelist.concat(existingWhitelist)));
    }

    async getUndeployWhitelist() {
        const result = await this._getMetadata(METADATA_TYPE.undeploy, this.domain);
        const { CONTENT } = result || [];
        return CONTENT ? JSON.parse(CONTENT) : [];
    }

    async _saveMetadata(id, data, domain) {
        const statement = 'UPSERT TENANT_METADATA (ID, CONTENT, DOMAIN) VALUES(?, ?, ?) WHERE ID = ? AND DOMAIN = ?';
        await this._client.execute(statement, [id, JSON.stringify(data), domain, id, domain]);
    }
}

module.exports = HdiTenantMetadataPersistence;
