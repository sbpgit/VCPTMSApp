const fs = require('fs');
const Logger = require('../../helper/logger');
const { COMPILED_FILES } = require('../../../config/constants');
const ModelNotFoundError = require('../../errors/model_not_found_error');
const ServiceMissingError = require('../../errors/service_missing_error');

const META_SUFFIX = '-META';

class TenantMetadataPersistence {

    constructor(options, domain, loggerComponent) {
        this._compileBaseDirs = [];
        this.logger = Logger(loggerComponent);
        this._globalSidecarMetaTenant = options.globalSidecarMetaTenant;
        this._domain = domain;
    }

    get domain() {
        if (!this._domain) {
            throw new Error('Domain must not be undefined');
        }
        return this._domain;
    }

    async destroy() {
        for (const compileBaseDir of this._compileBaseDirs) {
            this.logger.debug(`Cleaning compile dir: ${compileBaseDir}`);
            await fs.promises.rmdir(compileBaseDir, { recursive: true });
        }
    }

    async begin(tenantId) {
        this._tenantId = tenantId;
    }

    async onboardTenant(tenantId, options) {
        this._notImplemented();
    }

    async getModel(tenantId, type, attributes = {}) {
        const modelFilenames = this._getModelFilenames(type, attributes);
        this.logger.debug(`Model filenames are:`, modelFilenames);

        for (const modelFilename of modelFilenames) {
            const modelContent = await this.getModelContent(modelFilename);
            if (modelContent) {
                this.logger.debug(`Actual model filename is: ${modelFilename}`);
                return modelContent;
            }
        }

        throw new ModelNotFoundError(tenantId, type, modelFilenames, this.domain);
    }

    async getBaseModelFilesForExtensionProject() {
        this._notImplemented();
    }

    async getBaseModelFilesRaw() {
        this._notImplemented();
    }

    async getMigrationFiles() {
        this._notImplemented();
    }

    async saveMigrationFiles() {
        this._notImplemented();
    }

    _notImplemented() {
        throw new Error('Not implemented');
    }

    async getExtensionFiles() {
        this._notImplemented();
    }

    _intersectionList (files, intersectionKeys) {
        return new Map(Array.from(files).filter( entry => intersectionKeys.includes(entry[0]) ));
    }

    async getModelFilesRaw(includeExtensions) {
        const basemodelFiles = await this.getBaseModelFilesRaw();
        const migrationFiles = await this.getMigrationFiles();
        const extensionFiles = includeExtensions ? await this.getExtensionFiles() : new Map();
        return { basemodelFiles, migrationFiles, extensionFiles };
    }

    async saveLanguages() {
        this._notImplemented();
    }

    async saveServices() {
        this._notImplemented();
    }

    async saveCompiledFiles() {
        this._notImplemented();
    }

    async saveUndeployWhitelist() {
        this._notImplemented();
    }

    async saveBaseModel() {
        this._notImplemented();
    }

    async saveBuildResults(compiledFiles, hanaFiles, services, languages, migrationFiles, undeployExtension) {
        await this.saveLanguages(languages);
        await this.saveServices(services);
        await this.saveCompiledFiles(compiledFiles);
        await this.saveMigrationFiles(migrationFiles);
        await this.saveUndeployWhitelist(hanaFiles, undeployExtension);
    }

    _getModelFilenames(type, {service, language} = {}) {
        if (type === 'csn') {
            // compatibility: try odata_csn first, then fallback to csn
            return [COMPILED_FILES.ODATA_CSN, COMPILED_FILES.CSN];
        }
        if (type === 'edmx') {
            if (!service) {
                throw new ServiceMissingError();
            }
            const filename = `${service + (language ? `_${language}` : '')}.xml`;
            const edmxFiles = [filename];
            if (language) {
                const defaultLanguageFilename = `${service}.xml`;
                edmxFiles.push(defaultLanguageFilename);
            }
            return edmxFiles;
        }
        if (type === 'collectedSources') {
            return [COMPILED_FILES.CSN_NODE];
        }
        return [];
    }

    static _prefixTenant(tenantId) {
        return `TENANT-${tenantId}${META_SUFFIX}`;
    }
}

module.exports = TenantMetadataPersistence;
