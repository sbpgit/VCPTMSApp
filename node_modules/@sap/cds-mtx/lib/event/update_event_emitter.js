const Logger = require('../helper/logger');
const { EventEmitter } = require('events');
const { UPDATE_TYPE } = require('../../config/constants');

class UpdateEventEmitter extends EventEmitter {

    constructor() {
        super();
        this._updateCache = new Map();
    }

    get logger() {
        return this._logger = this._logger || Logger('UPDATE_EVENTS');
    }

    getEventName(type) {
        if ([UPDATE_TYPE.EXTENSION, UPDATE_TYPE.BASE].includes(type)) {
            return this.events.TENANT_UPDATED;
        } else if ([UPDATE_TYPE.DELETE].includes(type)) {
            return this.events.TENANT_DELETED;
        } else if ([UPDATE_TYPE.CREATE].includes(type)) {
            return this.events.TENANT_CREATED;
        }
        return this.events.TENANT_UPDATED;
    }

    async emitUpdate(tenantId, timestamp, type) {
        this.logger.debug(`Emit update ${type} for ${tenantId} with timestamp ${timestamp}`);
        this.emit(this.getEventName(type), tenantId);
        const cacheKey = `${tenantId}#${type}`;
        this._updateCache.set(cacheKey, timestamp);
    }


    _compare(loaded) {
        for (const { TENANT_ID, TIMESTAMP, TYPE } of loaded) {
            const timestamp = new Date(TIMESTAMP);
            const cacheKey = `${TENANT_ID}#${TYPE}`;
            if (this._updateCache.has(cacheKey)) {
                const oldTimestamp = this._updateCache.get(cacheKey);
                if (timestamp > oldTimestamp) {
                    this.emitUpdate(TENANT_ID, timestamp, TYPE);
                }
            } else {
                this._updateCache.set(cacheKey, timestamp);
                this.emitUpdate(TENANT_ID, timestamp, TYPE);
            }
        }
    }


    async run() {
        try {
            // this.logger.debug('Running tenant update check');
            const GlobalConnections = require('../helper/global_connections');
            const domain = GlobalConnections.getDomain();
            const loadedUpdates = await GlobalConnections.applicationDataPersistence.loadUpdates(domain);
            this._compare(loadedUpdates);
        } catch (error) {
            this.logger.error(error);
        }
    }

    get events() {
        return {
            TENANT_UPDATED: 'tenantUpdated',
            TENANT_DELETED: 'tenantDeleted',
            TENANT_CREATED: 'tenantCreated'
        };
    }
}

module.exports = new UpdateEventEmitter();
