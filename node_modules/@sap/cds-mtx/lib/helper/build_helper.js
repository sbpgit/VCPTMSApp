const cds = require('../cds');
const Logger = require('./logger');
const path = require('path');
const BuildResult = require('./build_helper_result');
const { uuid } = require('@sap/cds-foss');

const NO_BUILDTASKS_MESSAGE = 'Inconsistent project state - No build-tasks found';

const BUILD_TASK_JAVA = 'java-cf';
const BUILD_TASK_NODE = 'node-cf';
const BUILD_TASK_HANA = 'hana';

class BuildHelper {

    static _getDefaultBuildOptions(projectPath) {
        return {
            root: projectPath,
            for: {
                'hana': {
                    skipPackageJsonGeneration: true,
                    skipManifestGeneration: true
                },
                'node-cf': {
                    outputMode: 'resultOnly',
                    edmxGeneration: true
                },
                'java-cf': {
                    outputMode: 'resultOnly',
                    contentDefaultCsn: true,
                    contentLanguageBundles: true
                }
            }
        };
    }

    static async build(projectPath, basemodelFolders, tenantId, logCollector) {

        const buildLogger = Logger(`BUILD-${tenantId || `shared-${uuid()}`}`, logCollector);

        const buildOptions = BuildHelper._getDefaultBuildOptions(projectPath);

        const BuildTaskEngine = cds.build.BuildTaskEngine;

        const tasks = await this._getBuildTasks(buildOptions, basemodelFolders, buildLogger);
        let buildResult;

        const buildTaskEngine = new BuildTaskEngine(buildLogger);
        try {
            if (cds.env && cds.env.build) {
                cds.env.build.target = 'gen';
            }

            buildResult = await buildTaskEngine.processTasks(tasks, buildOptions);
        } catch (e) {
            this._alignLocation(e, projectPath, buildLogger);
            throw e;
        }

        const fullBuildResult = new BuildResult();

        for (const taskResult of buildResult) {
            await fullBuildResult.addTaskResult(taskResult);
        }

       return fullBuildResult;
    }

    static async _getBuildTasks(buildOptions, basemodelFolders, logger) {

        // save original basemodel task config
        let originalTaskConfig = null;
        if (cds.env.build && cds.env.build.tasks) {
            originalTaskConfig = JSON.parse(JSON.stringify(cds.env.build.tasks));
        }

        const BuildTaskFactory = cds.build.BuildTaskFactory;

        let buildTasks = await new BuildTaskFactory(logger).getTasks(buildOptions);

        buildTasks = JSON.parse(JSON.stringify(buildTasks));

        if (buildTasks.length < 1) {
            logger.error(NO_BUILDTASKS_MESSAGE);
            return [];
        }

        // removing existing mtx build task
        buildTasks = buildTasks.filter(task => task.for === BUILD_TASK_HANA || task.for === BUILD_TASK_JAVA || task.for === BUILD_TASK_NODE);

        this._addExtensionToModel(buildTasks, originalTaskConfig, basemodelFolders);
        logger.debug(`Effective build tasks are: ${JSON.stringify(buildTasks)}`);

        return buildTasks;
    }

    static _hasBuildModelConfig(existingTaskConfig, buildTaskName) {
        if (existingTaskConfig) {
            const buildTask = existingTaskConfig.find((task) => {
                return (task.for === buildTaskName);
            });
            return !!(buildTask && buildTask.options && buildTask.options.model);
        }
        return false;
    }


    static _addExtensionToModel(buildTasks, existingTaskConfig, basemodelFolders) {
        buildTasks.forEach(buildTask => {
            if (!buildTask.options.model) {
                buildTask.options.model = [];
            }

            if (!Array.isArray(buildTask.options.model)) {
                buildTask.options.model = [buildTask.options.model];
            }

            // check existing model options and use them
            if (this._hasBuildModelConfig(existingTaskConfig, buildTask.for)) {
                buildTask.options.model = buildTask.options.model.map(model => `node_modules/_base/${model}`);
            } else {
                buildTask.options.model = Array.from(basemodelFolders).map(model => `node_modules/_base/${model}`);
            }

            if (buildTask.for === BUILD_TASK_HANA) {
                buildTask.options.model.unshift('db');
                buildTask.options.model.unshift('srv');
                // buildTask.options.build = { mtxOriginalSrc: `node_modules/_base/${buildTask.src}` };
                buildTask.src = 'db';
            }
            if ([BUILD_TASK_NODE, BUILD_TASK_JAVA].includes(buildTask.for)) {
                buildTask.options.model.unshift('srv');
                buildTask.options.model.unshift('db');
                buildTask.src = 'srv';
            }
        });
    }


    static _alignLocation(error, projectPath, logger) {
        if (!error.errors) {
            return;
        }

        error.errors.forEach(err => {
            ['file', 'filename'].forEach(file => {
                if (err.location && err.location[file]) {
                    try {
                        const absolutePath = path.resolve(process.cwd(), err.location[file]);
                        const relativeToProject = path.relative(projectPath, absolutePath);
                        err.location[file] = `./${relativeToProject}`;
                        logger.debug(`Align message location: ${err.location[file]}`);
                    } catch (e) { /* ignore */ }
                }
            });
            this._alignLocation(err, projectPath, logger);
        });
    }

    static _mergeMigrationContent(fileFromBuild, fileContentFromTenant) {
        // TODO use build migration file parser here
    }
}

module.exports = BuildHelper;
