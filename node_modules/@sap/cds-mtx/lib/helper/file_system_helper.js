const fs = require('fs');
const { fse } = require('@sap/cds-foss');
const path = require('path');
const Logger = require('./logger');
const tempDir = fs.realpathSync(require('os').tmpdir());

class FileSystemHelper {

    static get logger() {
        return this._logger = this._logger || Logger('FILE_SYSTEM_HELPER');
    }

    static async writeFilesFromMap(files, baseDir) {
        for (const [filename, content] of files) {
            const unixFilename = FileSystemHelper.unixPath(filename);
            const absoluteFilename = path.resolve(baseDir, unixFilename);

            if (absoluteFilename.includes(baseDir)) {
                this.logger.debug(`Writing file: ${absoluteFilename}`);
                await fs.promises.mkdir(path.dirname(absoluteFilename), { recursive: true });
                await fs.promises.writeFile(absoluteFilename, content);
            } else {
                this.logger.debug(`Do not write file outside of target: ${absoluteFilename}`);
            }
        }
    }

    static async getAllDirectories(dir) {
        const dirs = async (dirPath = ".") => {
            try {
                const isDirectory = (await fs.promises.stat(dirPath)).isDirectory();
                if (isDirectory) {
                    const filenames = await fs.promises.readdir(dirPath)
                    const subdirectories = await Promise.all(filenames.map(p => dirs(path.join(dirPath, p))))
                    return [].concat(dirPath, ...subdirectories);
                }
                return [];
            } catch (error) {
                // ignore
            }
        }
        return dirs(dir);
    }

    static async readAllFilesInDirectory(directory, { baseFolder, fileStructure, filterExp, skipContent, unixPath } = {}) {
        baseFolder = baseFolder || directory;
        fileStructure = fileStructure || new Map();

        if (! await this.pathExists(directory)) {
            return fileStructure;
        }

        const filenames = await fs.promises.readdir(directory);
        for (const file of filenames) {
            const filePath = path.join(directory, file);
            if ((await fs.promises.stat(filePath)).isDirectory()) {
                fileStructure = await this.readAllFilesInDirectory(filePath, { baseFolder, fileStructure, filterExp, skipContent, unixPath });
            } else {
                const relativeFilePath = path.relative(baseFolder, filePath);
                if (!filterExp || filterExp.test(relativeFilePath)) {
                    const content = skipContent ? '' : await fs.promises.readFile(filePath, { encoding: 'utf8' });
                    fileStructure.set(unixPath ? FileSystemHelper.unixPath(relativeFilePath) : relativeFilePath, content);
                }
            }
        }
        return fileStructure;
    }

    static async copy(from, to, options) {
        return fse.copy(from, to, options);
    }

    static async mkdirTemp() {
        return fs.promises.mkdtemp(`${tempDir}${path.sep}`);
    }

    static async mkdirp(path) {
        return fs.promises.mkdir(path, { recursive: true });
    }

    static async pathExists(path) {
        return fs.promises.access(path).then(() => true).catch(() => false);
    }

    static async getExistingFolder(directories) {
        for (const directory of directories) {
            if (await this.pathExists(directory)) return directory;
        }
    }

    static unixPath(filename) {
        return filename.replace(/\\/g, '/');
    }
}

module.exports = FileSystemHelper;
