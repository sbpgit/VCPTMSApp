const SecurityHelper = require('./security_helper');
const https = require('https');
const URL = require('url').URL;
const Logger = require('./logger');
const ScopeError = require('../errors/scope_error');

class HttpHelper {

    static get logger() {
        return this._logger = this._logger || Logger('HTTP_HELPER');
    }

    static checkFor304(request, eTag) {
        return request.headers && request.headers['if-none-match'] === eTag;
    }

    static getETag(timestamps) {
        const seed = timestamps ? timestamps.join('|') : 'initial';
        const hash = SecurityHelper.hash(seed);
        return `"${hash}"`;
    }

    static checkIfPaaSAuthenticated(context) {
        const authenticatedTenantId = SecurityHelper.getTenant(context);

        // applies for all tenants, check if authenticated for PaaS tenant
        if (!SecurityHelper.requestAllowed(null, authenticatedTenantId)) {
            const e = new Error('Unauthorized');
            HttpHelper.assignErrorStatus(context, e, 401);
            return context.reject(e);
        }
    }

    static checkAnyScopeAndRespond(context, scopes) {
        scopes = (Array.isArray(scopes) ? scopes : [scopes]);
        scopes = scopes.reduce((res, scope) => {
            return res.concat(SecurityHelper.getConfiguredScopes(scope) || scope);
        }, []);
        if (!scopes.some(scope => SecurityHelper.checkScope(context, scope))) {
            const error = new ScopeError(scopes[0]);
            this.handleError(context, error);
        }
    }

    static _logRequest(requestOptions) {
        const { method, headers, host, path } = requestOptions;
        const filteredHeaders = JSON.parse(JSON.stringify(headers));
        const { authorization } = filteredHeaders;
        if (authorization) {
            filteredHeaders.authorization = `${authorization.substring(0, 20)}...`;
        }

        HttpHelper.logger.debug(`Sending request ${method} request to ${host}${path}`
            + `with headers\n${JSON.stringify(filteredHeaders)}`);
    }

    static async sendJsonRequest(method, url, auth, addHeaders = {}, body = null) {
        const { hostname, pathname, searchParams } = new URL(url);

        const allHeaders = {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        };

        Object.assign(allHeaders, addHeaders);

        return new Promise((resolve, reject) => {
            const requestOptions = {
                host: hostname,
                path: pathname + ((searchParams && (Array.from(searchParams).length > 0)) ? `?${( searchParams.toString() )}`: ''),
                method: method,
                auth: auth,
                headers: allHeaders,
                json: true
            };
            let result = '';

            HttpHelper._logRequest(requestOptions);

            const req = https.request(requestOptions, res => {

                if (res.statusCode < 200 || res.statusCode > 299) {
                    reject(new Error(`Response status ${res.statusCode}: ${res.statusMessage}`));
                }

                res.on('data', data => {
                    result += data;
                });
                res.on('end', () => {
                    const requestResult = result.toString('utf-8');
                    resolve(requestResult);
                });
            });
            req.on('error', (error) => {
                return reject(error);
            });
            if (body) {
                HttpHelper.logger.debug('Sending body: %s', body);
                req.write(body);
            }
            req.end();
        });
    }

    static getCallbackSettingsFromHeaders(req) {
        if (req) {
            const mtxCallbackUrl = req.headers['mtx_status_callback'];
            const callbackUrl = req.headers['status_callback'];
            const noCallback = req.headers['mtx_async_no_callback'];
            if (callbackUrl || mtxCallbackUrl || noCallback) {
                return {callbackUrl, mtxCallbackUrl, noCallback};
            }
        }
        return undefined;
    }

    static getAppUrlFromHeaders(req) {
        return req && req.headers && req.headers['application_url']
    }

    static getAuthFromHeaders(req) {
        return req && req.headers && req.headers['mtx_status_callback'] && req.headers['authorization'];
    }

    static handleError(context, error) {
        context._.res && context._.res.status(error.code || error.statusCode || 500);
        context.reject(error);
    }
}

module.exports = HttpHelper;
