const cds = require('../cds');
const crypto = require('crypto');
const Logger = require("./logger");
const { support, ERRORS } = require('../../config/supportability');
const { SCOPES } = require('../../config/constants');

class SecurityHelper {

    static get logger() {
        return this._logger = this._logger || Logger('SECURITY_HELPER');
    }

    static getXsappname() {
        const uaaCredentials = this.getUaaCredentials();
        if (!uaaCredentials) {
            throw new Error(`No UAA credentials found`);
        }
        const xsappname = uaaCredentials.xsappname;
        if (!xsappname) {
            throw new Error(`Failed to get 'xsappname' from UAA credentials`);
        }
        return xsappname;
    }

    static insertXsappname(xsappname, scopes) {
        return scopes.map(scope => scope.replace('$XSAPPNAME', xsappname));
    }

    static getAllRequiredScopes() {
        const xsappname = this.getXsappname();
        return Object.keys(SCOPES)
            .reduce((result, kind) => result.concat(this.insertXsappname(
                xsappname,
                kind in this.CONFIGURABLE_SCOPE_KEYS
                    ? this.getConfiguredScopes(kind)
                    : [SCOPES[kind]]
                )), []);
    }

    static getAllRequiredScopesForRequest() {
        return encodeURIComponent(this.getAllRequiredScopes().reduce((result, scope) => (result && result + ' ' || result) + scope, ''));
    }

    static get CONFIGURABLE_SCOPE_KEYS() {
        return {
            SUBSCRIPTION: 'subscription-scope',
            DEPLOYMENT:   'deployment-scope'
        };
    }

    static get DEFAULT_SCOPES() {
        // this could be done as cds env default
        return {
            SUBSCRIPTION: [SCOPES.SUBSCRIPTION],
            DEPLOYMENT:   [SCOPES.DEPLOYMENT]
        };
    }

    static getConfiguredScopes(scopeKind) {
        const scopeKey = this.CONFIGURABLE_SCOPE_KEYS[scopeKind];
        const scopeConfig = cds.env.mtx && cds.env.mtx.security && cds.env.mtx.security[scopeKey];
        if (scopeConfig) {
            let configuredScopes = Array.isArray(scopeConfig) ? scopeConfig : [scopeConfig];
            configuredScopes = configuredScopes.filter(scope => scope.trim().length);
            if (configuredScopes.length) {
                return configuredScopes;
            }
        }
        return this.DEFAULT_SCOPES[scopeKind];
    }

    static checkScope(context, scope) {
        const authInfo = this._getAuthInfo(context);

        if (authInfo && authInfo.checkScope(scope) /* cds 3 */ || context.user && context.user.is(scope) /* cds 4 */) {
            this.logger.debug(`User has the relevant scope: ${scope}`);
            return true;
        }

        this.logger.error(`User doesn't have the relevant scope: ${scope}`);
        return false;
    }

    static _getAuthInfo(context) {
        return context._ && context._.req && context._.req.authInfo;
    }

    static getSubdomain(context) {
        const authInfo = this._getAuthInfo(context);
        return authInfo && authInfo.getSubdomain() || context.user.subdomain;
    }

    static getTenant(context) {
        const authInfo = this._getAuthInfo(context);
        return authInfo && authInfo.identityZone || context.tenant || context.user && context.user.tenant;
    }

    static async checkAuthorization(context, parameterTenantId = null) {
        const authenticatedTenantId = this.getTenant(context);
        const requestedTenantId = parameterTenantId || authenticatedTenantId;
        this.logger.debug(`Checking authorization for parameterId: ${parameterTenantId}; requestedId: ${requestedTenantId}; authenticatedId: ${authenticatedTenantId}`);

        if (!this.requestAllowed(requestedTenantId, authenticatedTenantId)) {
            const error = new Error('Unauthorized');
            const code = 401;
            context._.res.status(code);
            error.code = code;
            error.statusCode = code; // needed for cds 3 compatibility
            throw error;
        }

        return requestedTenantId;
    }

    static requestAllowed(requestedTenantId, authenticatedTenantId, suppressErrors = false) {
        const { identityzoneid } = this.getUaaCredentials() || {};
        const allowed = !!authenticatedTenantId && [requestedTenantId, identityzoneid].includes(authenticatedTenantId);
        if (!suppressErrors && !allowed) {
            this.logger.error(`The request is not allowed as the XSUAA credentials' 'identityzoneid' doesn't match the authenticated tenant ID.`);
        }
        return allowed;
    }

    static getUaaCredentials() {
        if (!cds.env.requires) {
            support(ERRORS.uaaEnvRequiresMissing, this.logger);
            return null;
        }
        const { uaa } = cds.env.requires;
        if (!uaa) {
            support(ERRORS.uaaBindingMissing, this.logger);
            return null;
        }
        const { kind } = uaa;
        if (kind === 'xsuaa') {
            return uaa.credentials;
        }
        support(ERRORS.uaaBindingNotXSUAA, this.logger);
        return false;
    }

    static hash(seed) {
        const md5sum = crypto.createHash('md5');
        return md5sum.update(seed).digest('hex');
    }
}

module.exports = SecurityHelper;
