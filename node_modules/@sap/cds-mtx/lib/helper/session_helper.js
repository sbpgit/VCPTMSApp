const cds = require('../cds');
const Logger = require('./logger');
const logger = Logger('SESSION');

/**
 * MtxHanaClient wraps the hana client to keep compatibility.
 * When switching to a hard dependency to cds 4, all direct sql calls should be made via cds.
 * FIXME: CDS 4
 */
class MtxHanaClient {

    constructor(client) {
        this.hanaClient = client;
    }

    /**
     * Needed to handle large uploads. for some reason, the hana client switched off the auto-commit when exceeding
     * a certain content size.
     * @param statement
     * @param parameters
     * @returns {Promise<void>}
     */
    async saveExecute(statement, parameters) {
        if (this.hanaClient._dbc && this.hanaClient._dbc.getAutoCommit) {
            const autoCommitSetting = this.hanaClient._dbc.getAutoCommit();
            this.hanaClient._dbc.setAutoCommit(false);
            try {
                await this.execute(statement, parameters);
                await this.hanaClient.commit();
            } catch (error) {
                await this.hanaClient.rollback();
                throw error;
            } finally {
                this.hanaClient._dbc.setAutoCommit(autoCommitSetting);
            }
        } else if (this.hanaClient.getAutoCommit) {
            // more recent cds versions
            const autoCommitSetting = this.hanaClient.getAutoCommit();
            this.hanaClient.setAutoCommit(false);
            try {
                await this.execute(statement, parameters);
                await this.hanaClient.commit();
            } catch (error) {
                await this.hanaClient.rollback();
                throw error;
            } finally {
                this.hanaClient.setAutoCommit(autoCommitSetting);
            }

        } else {
            // compatibility with older cds versions
            await this.execute(statement, parameters);
        }
    }

    async commit() {
        await this.hanaClient.commit();
        if (this.setAutoCommit) {
            // this wrapper is only used by mtx, setting autocommit to true after commit is expected
            this.setAutoCommit(true);
        }
    }

    async begin() {
        if (this.hanaClient.begin) {
            return this.hanaClient.begin();
        } else {
            // internally begin does setAutoCommit(false)
            return this.setAutoCommit(false);
        }
    }

    async rollback() {
        await this.hanaClient.rollback();
        if (this.setAutoCommit) {
            // this wrapper is only used by mtx, setting autocommit to true after rollback is expected
            this.setAutoCommit(true);
        }
    }

    /**
     * Wraps hana client execute with promise and keeps up the compatibility handling prepared statements
     * @param statement
     * @param parameter
     * @returns {Promise<Promise<*>|*>}
     */
    async execute(statement, parameter) { // NOSONAR
        if (this.hanaClient.prepare) {
            return new Promise((resolve, reject) => {
                if (parameter) {
                    this.hanaClient.prepare(statement, function (err, stmt) { // NOSONAR
                        if (err) {
                            return reject(err)
                        }
                        stmt.exec(parameter, function (err, rows) { // NOSONAR
                            stmt.drop(() => {
                            })
                            if (err) {
                                err.code = String(err.code); // compatible return code
                                return reject(err)
                            }
                            return resolve(rows)
                        })
                    })
                } else {
                    this.hanaClient.exec(statement, function (err, rows) { // NOSONAR
                        if (err) {
                            err.code = String(err.code);
                            return reject(err)
                        }
                        return resolve(rows)
                    })
                }
            });
        } else {
            return this.hanaClient.execute(statement, parameter);
        }
    }

    setAutoCommit(autoCommit) {
        if (this.hanaClient._dbc && this.hanaClient._dbc.setAutoCommit) {
            return this.hanaClient._dbc.setAutoCommit(autoCommit);
        } else if (this.hanaClient.setAutoCommit) {
            return this.hanaClient.setAutoCommit(autoCommit);
        }
        // do nothing if not supported
        return false;
    }

    getAutoCommit() {
        if (this.hanaClient._dbc && this.hanaClient._dbc.getAutoCommit) {
            return this.hanaClient._dbc.getAutoCommit();
        } else if (this.hanaClient.getAutoCommit) {
            return this.hanaClient.getAutoCommit();
        }
        // not important if not supported
        return false;
    }

}

class SessionHelper {

    static isVersion4(version) {
        if (!version) throw new Error('Internal error: No cds version');
        const versionArray = version.split('.');
        return Number.parseInt(versionArray[0]) >= 4;
    }

    static getAcquireOptions(version, tenantId) {
        if (this.isVersion4(version, tenantId)) {
            return { tenant: tenantId, user: {tenant: tenantId} }; // Major-TODO: remove tenant from user
        }
        return {attr: {identityZone: tenantId} }
    }

    static async acquire(tenantId) {
        const hanaClient = await cds.db.acquire(this.getAcquireOptions(cds.version, tenantId));
        return new MtxHanaClient(hanaClient);
    }

    static async release(client) {
        return client && cds.db.release(client.hanaClient || client);
    }

    static async disconnect(tenantId) {
        return cds.db.disconnect(tenantId, true);
    }

    static async ensureConnected() {
        if (!cds.db) {
            logger.debug('Connection lost, reconnecting');
            await cds.connect();
        }
        return cds.db;
    }

    static async refresh(tenantId) {
        try {
            await SessionHelper.disconnect(tenantId);
            await SessionHelper.ensureConnected();
        } catch (e) {
            //might occur if no connection happened to tenant before it gets deleted
            logger.debug(e);
        }
    }
}

module.exports = SessionHelper;
