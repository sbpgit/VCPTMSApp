const path = require('path');
const cds = require('./cds');
const EventEmitter = require('./event/update_event_emitter');
const Logger = require('./helper/logger');
const jwt = require('./jwt');
const express = require('express');
const TenantRequestHelper = require('./helper/tenant_request_helper');
const GlobalConnections = require('./helper/global_connections');
const JobExecutor = require('./jobs/job_executor');

let interval;

class Index {

    // basic mt provisioning api
    static provisioning(options) {
        return cds.serve('ProvisioningService', options)
            .from(path.join(__dirname, 'api', 'provisioning'))
            .with(require('./api/provisioning')(cds))
            .at('/mtx/v1/provisioning')
            .to('rest');
    }

    // internal provisioning service for java runtime
    static internalProvisioning(options) {
        return cds.serve('SidecarProvisioningService', options)
            .from(path.join(__dirname, 'api', 'provisioning', 'internal'))
            .with(require('./api/provisioning/internal')(cds))
            .at('/mtx/v1/internal/provisioning')
            .to('rest');
    }

    // model api for standalone sidecar
    static metadata(options) {
        return cds.serve(path.join(__dirname, 'api', 'metadata'), options)
            .with(require('./api/metadata')(cds))
            .at('/mtx/v1/metadata')
            .to('rest');
    }

    // extensibility api
    static model(options) {
        return cds.serve(path.join(__dirname, 'api', 'model'), options)
            .with(require('./api/model')(cds))
            .at('/mtx/v1/model')
            .to('rest');
    }

    // v2 model api
    static modelprovider(options) {
        return cds.serve(path.join(__dirname, 'api', 'v2', 'model'), options)
            .with(require('./api/v2/model')(cds))
            .at('/mtx/v2/model')
            .to('rest');
    }

    // diagnose api
    static diagnose(options) {
        return cds.serve(path.join(__dirname, 'api', 'diagnose'), options)
            .with(require('./api/diagnose')(cds))
            .at('/mtx/v1/diagnose')
            .to('rest');
    }

    // internal services

    static tenant(options) {
        return cds.serve(path.join(__dirname, 'services', 'tenant'), options);
    }

    static get logger() {
        return this._logger = this._logger || Logger('FACTORY');
    }

}

const getJwtToken = async function(req, res) {
    try {
        const jwtToken = await jwt.requestJwtToken(req);
        res.send(jwtToken);
    } catch (error) {
        Index.logger.error(error);
        if (error.constructor.name === 'PasscodeAuthenticationError' || error.constructor.name === 'EmptyResponseError') {
            res.status(401).send(error);
        } else {
            res.status(500).send(error);
        }
    }
};

let isInjected = false;

const factory = () => {
    return {
        run: async () => {
            Index.logger.debug('Tenant service API configured');
            await (Index.tenant());
        },
        in: async (app, serveOptions) => {

            if (isInjected) return;
            isInjected = true;

            // temporary fix for payload limit problem
            app.use('/mtx/*', express.json({ limit: '500mb' }));

            if (cds.env.mtx && cds.env.mtx.api && cds.env.mtx.api.provisioning) {
                Index.logger.debug('Provisioning API configured');
                await (Index.provisioning(serveOptions)).in(app);
                await (Index.internalProvisioning(serveOptions)).in(app);
            }

            if (cds.env.mtx && cds.env.mtx.api && cds.env.mtx.api.metadata) {
                Index.logger.debug('Metadata API configured');
                await (Index.metadata(serveOptions)).in(app);
            }

            if (cds.env.mtx && cds.env.mtx.api && cds.env.mtx.api.model) {
                Index.logger.debug('Model API configured');
                await (Index.model(serveOptions)).in(app);
            }

            if (cds.env.mtx && cds.env.mtx.api && cds.env.mtx.api.modelprovider) {
                Index.logger.debug('Model Provider API configured');
                await (Index.modelprovider(serveOptions)).in(app);
            }

            if (cds.env.mtx && cds.env.mtx.api && cds.env.mtx.api.diagnose) {
                Index.logger.debug('Diagnosis API configured');
                await (Index.diagnose(serveOptions)).in(app);
            }

            Index.logger.debug('Tenant service API configured');
            await Index.tenant(serveOptions);

            if (!process.env.MTX_DISABLE_META_TENANT_CREATION) {
                await GlobalConnections.applicationDataPersistence.initGlobalMetaTenantIfNeeded();
                await GlobalConnections.createMetadataPersistenceFactory();
            }

            const disableUpdateCheck = cds.env.mtx && cds.env.mtx.disableUpdateCheck;
            const intervalTimeout = cds.env.mtx && cds.env.mtx.intervalTimeout || 10000;
            if (!interval && !disableUpdateCheck) {
                interval = setInterval(async() => {
                    try {
                        await EventEmitter.run();
                    } catch (error) {
                        Index.logger.error(error);
                    }
                }, intervalTimeout);
            }

            EventEmitter.on(EventEmitter.events.TENANT_DELETED, async (tenantId) => {
                Index.logger.debug(`Tenant ${tenantId} deleted, refreshing connection pool`);
                (await GlobalConnections.getTenantMetadataPersistenceFactory()).refreshConnection(tenantId);
                await GlobalConnections.applicationDataPersistence.refreshConnection(tenantId);
            });

            // add endpoint for jwt token determination here
            app.get('/mtx/v1/oauth/token', getJwtToken);
        },

        inject: (cds) => {
            const _cds = require('./cds');
            _cds.inject(cds);
        },

        events: EventEmitter.events,

        eventEmitter: EventEmitter,

        isExtended: async(tenantId) => {
            return await require('./tenant').isExtended(tenantId);
        },

        getCsn: async(tenantId) => {
            const loadedModel = await require('./tenant').getModel(tenantId, 'collectedSources');
            return JSON.parse(loadedModel);
        },

        getEdmx: async(tenantId, service, language, odataVersion) => {
            return await require('./tenant').getEdmx(tenantId, { service, language, odataVersion });
        },

        activate: async(tenantId, content, options) => {
            return require('./tenant').activate(tenantId, content, options);
        },

        getSaasUtil: () => {
            return {
                setSubscriptionUrl: (req, subscriptionUrl) => {
                    TenantRequestHelper.addSubscriptionUrl(req.data, subscriptionUrl);
                }
            }
        },

        shutdown: async () => {
            clearInterval(interval);
            JobExecutor.shutdown();
        }
    }
};

module.exports = factory;
