const cds = require('@sap/cds');
const { uuid } = require('@sap/cds-foss');

const Logger = require('../helper/logger');
const GlobalConnections = require('../helper/global_connections');
const Job = require('./job');
const CallbackJob = require('./callback_job');
const QueueOverflowError = require('../errors/queue_overflow_error');
const JobNotFoundError = require('../errors/job_not_found_error');
const JobAccessError = require('../errors/job_access_error');

const DEFAULT_JOB_REMOVAL_TIMEOUT = 30 * 60 * 1000;
const DEFAULT_MAX_QUEUE_SIZE = 1000;
const DEFAULT_PARALLEL_JOBS = 2;

class JobExecutor {

    static clear() {
        this._logger = Logger('JOB_EXECUTOR');
        this._queues = new Map();
        this._maxQueueLength = cds.env.get('mtx.jobs.queueSize') || cds.env.get('mtx.jobqueue.size') || DEFAULT_MAX_QUEUE_SIZE;
        this._jobs = new Map();
        this._jobsRunning = [];
        this._jobRemovalTimeout = cds.env.get('mtx.jobs.removalTimeout') || DEFAULT_JOB_REMOVAL_TIMEOUT;
        this._locks = [];
        this._maxParallelJobs = cds.env.get('mtx.jobs.maxParallelExecutions') || DEFAULT_PARALLEL_JOBS;

        this._jobRemovals = new Map();
    }

    static async diagnose() {

        function formatArgs(args) {
            return args.map(arg => require('util').inspect(arg, { depth: 1 }));
        }

        const jobs = await GlobalConnections.applicationDataPersistence.getAllJobs();
        const jobsInMemory = [...this._jobs.values()].map(job => ({
            jobId: job.jobId,
            tenantId: job.tenantId,
            status: job.status,
            processId: job.processId,
            error: job.error,
            result: job.result,
            jobFunction: job.jobFunction.name,
            jobFunctionArgs: formatArgs(job.functionArgs)
        }));
        const jobsPersisted = jobs.filter(job => !jobsInMemory.find(inMemoryJob => job.jobId === inMemoryJob.jobId));

        return {
            maxQueueLength: this._maxQueueLength,
            jobs: Array.from(this._jobs.keys()),
            jobsWaiting: JSON.stringify(this._queues),
            jobsRunning: this._jobsRunning,
            jobsInMemory,
            jobsPersisted
        }
    }

    static async asyncPool(poolSize, payloads, fn) {
        const pending = [], all = [];
        for (const payload of payloads) {
            const execute = fn.constructor.name === 'AsyncFunction' ? fn(payload) : Promise.resolve().then(() => fn(payload));
            all.push(execute);

            const executeAndRemove = execute.then(() =>
                pending.splice(pending.indexOf(executeAndRemove), 1)
            );
            pending.push(executeAndRemove);
            if (pending.length >= poolSize) {
                await Promise.race(pending);
            }
        }
        return Promise.allSettled(all);
    }

    static nextTick(callback) {
        return new Promise((resolve, reject) => {
            process.nextTick(() => {
                try {
                    resolve(callback())
                } catch (error) {
                    reject(error)
                }
            })
        })
    }

    static async _runNext(lock) {
        if (lock && !this._queues[lock]) this._queues[lock] = [];
        const pullWaitingLock = () => (Object.entries(this._queues).find(([,q]) => q.length > 0) || [])[0]
        lock = lock && this._queues[lock].length > 0 ? lock : pullWaitingLock();
        if (!lock) return;
        if (this._jobsRunning.length >= this._maxParallelJobs) return;
        if (this._locks.includes(lock)) return;

        this._locks.push(lock);
        const jobIdToRunNext = this._queues[lock].shift();
        const jobToRunNext = this._jobs.get(jobIdToRunNext);
        this._jobsRunning.push(jobIdToRunNext);
        this._logger.debug(`Running job with ID ${jobIdToRunNext}`);
        await this._runJob(jobToRunNext);
    }

    static async _runJob(jobToRunNext) {
        await jobToRunNext.setJobStatus(Job.EXECUTION_STATUS.RUNNING);
        const { jobId, tenantId } = jobToRunNext;

        try {
            await jobToRunNext.run();
            this._logger.debug(`Job ${jobId} succeeded`);
        } catch (error) {
            this._logger.error(`Job ${jobId} failed with error `, error);
        } finally {
            const jobRunningIndex = this._jobsRunning.find(job => job.jobId === jobId)
            this._jobsRunning.splice(jobRunningIndex, 1);
            const lockIndex = this._locks.find(lockId => lockId === tenantId)
            this._locks.splice(lockIndex, 1);
            this.nextTick(() => this._runNext(tenantId));

            // remove job after timeout
            const jobRemoval = setTimeout(async () => {
                this._jobs.delete(jobId);
                await GlobalConnections.applicationDataPersistence.deleteJobStatus(jobId, tenantId);
                this._logger.debug(`Removed job with id ${jobId}`);
                this._jobRemovals.delete(jobId);
            }, this._jobRemovalTimeout);
            this._jobRemovals.set(jobId, jobRemoval);
        }
    }

    static async submit(tenantId, context, jobFunction, args = [], { awaitResult = false, callback = null } = {} ) {
        if (!this._queues[tenantId]) {
            this._queues[tenantId] = [];
        }

        const queueLength = Object.values(this._queues).reduce((result, queue) => result.concat(queue), []).length;
        if (queueLength >= this._maxQueueLength) {
            throw new QueueOverflowError(queueLength, this._maxQueueLength);
        }

        args = Array.isArray(args) ? args : [args]
        const job = !callback
            ? new Job(uuid(), tenantId, context, jobFunction, args)
            : new CallbackJob(uuid(), tenantId, context, jobFunction, args, callback);

        const { jobId } = job;
        this._logger.debug(`New job submitted with ID ${jobId}`);
        this._jobs.set(jobId, job);
        this._queues[tenantId].push(jobId);
        await GlobalConnections.applicationDataPersistence.upsertJobStatus(job);
        //awaitResult ? await this.nextTick((() => this._runNext(tenantId))) : this.nextTick(() => this._runNext(tenantId));
        this.nextTick(() => this._runNext(tenantId));
        return jobId;
    }

    static async getStatus(jobId, tenantId, allowAll) {
        this._logger.debug(`Get job status of ${jobId}`);
        let job = this._jobs.get(jobId);

        // check job found in cache
        if (job && job.tenantId !== tenantId && !allowAll) {
            throw new JobAccessError();
        }

        if (!job) {
            this._logger.debug('Job not found in cache, checking database');
            job = await GlobalConnections.applicationDataPersistence.getJobStatus(jobId, tenantId, allowAll);
            if (job) {
                job.error = job.jobStatus === Job.EXECUTION_STATUS.FAILED ? job.result : null;
            }
        }

        if (!job) {
            throw new JobNotFoundError(jobId);
        }

        return {
            processId: job.processId,
            status: job.jobStatus,
            progress: (job.jobStatus === Job.EXECUTION_STATUS.RUNNING)  ? job.functionStatus : null,
            result: job.result,
            error: job.error ? job.error.toString() : undefined
        };
    }

    static shutdown() {
        [...this._jobRemovals.values()].forEach(clearTimeout);
        this._jobRemovals.clear();
    }
}

JobExecutor.clear();

module.exports = JobExecutor;
