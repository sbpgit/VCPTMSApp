const Checker = require('./checker_base');
const Logger = require('../helper/logger');
const logger = Logger('ALLOWLIST_CHECKER');

const LABELS = {
    'service': 'Service',
    'entity': 'Entity',
}


const LEGACY_ENTITY_WHITELIST = 'entity-whitelist';
const LEGACY_SERVICE_WHITELIST = 'service-whitelist';
const EXTENSION_ALLOWLIST = 'extension-allowlist';
const NEW_FIELDS = 'new-fields';
const NEW_ENTITIES = 'new-entities';

class Allowlist {
    constructor(mtxConfig, fullCsn) {
       this.allowlist = Allowlist._setupPermissionList(mtxConfig, fullCsn);
    }

    get all() {
        return this.allowlist.all;
    }

    get entity() {
        return this.allowlist.entity;
    }

    get service() {
        return this.allowlist.service;
    }

    getList(kind) {
        return this.allowlist[kind];
    }

    getPermission(kind, name) {
        function findInList(list, name) {
            if (list) {
                const splitName = name.split('.');
                while (splitName.length > 0) {
                    const nameOrPrefix = splitName.join('.');
                    if (list[nameOrPrefix]) {
                        return list[nameOrPrefix];
                    }
                    splitName.pop();
                }
                return list['*'] ? list['*'] : null;
            }
            return null;
        }
        return findInList(this.allowlist[kind], name) || findInList(this.allowlist['all'], name);
    }

    isAllowed(kind, name) {
        return !!this.getPermission(kind, name);
    }

    static _setupPermissionList(mtxConfig, fullCsn) {

        const result = {};

        // create from legacy lists
        let {entityWhitelist, serviceWhitelist} = Allowlist._getLegacyLists(mtxConfig);

        // create from new lists
        const allowlistNewFormat = mtxConfig[EXTENSION_ALLOWLIST];

        Allowlist._addLegacyLists(result, serviceWhitelist, entityWhitelist);

        if (allowlistNewFormat) {

            // seperate into single entities /services for better processing
            for (const permission of allowlistNewFormat) {
                if (permission.for) {
                    for (const name of permission.for) {
                        if (permission.kind) { // kind is specfied
                            result[permission.kind] = result[permission.kind] || {};
                            result[permission.kind][name] = permission;
                        } else { // check kind
                            if (fullCsn.definitions[name]) {
                                result[fullCsn.definitions[name].kind] = result[fullCsn.definitions[name].kind] || {}
                                result[fullCsn.definitions[name].kind][name] = permission;
                            } else { // allow all
                                result.all = result .all || {};
                                result.all[name] = permission;
                            }
                        }
                    }
                }
            }
        }
        return result;
    }

    static _addLegacyLists(result, serviceWhitelist, entityWhitelist) {
        if (serviceWhitelist) {
            result.service = result.service || {};
            for (const service of serviceWhitelist) {
                result.service[service] = {};
            }
        }

        if (entityWhitelist) {
            result.entity = result.entity || {};
            for (const entity of entityWhitelist) {
                result.entity[entity] = {};
            }
        }
        return result;
    }

    static _getLegacyLists(mtxConfig) {
        let entityWhitelist = mtxConfig[LEGACY_ENTITY_WHITELIST];
        let serviceWhitelist = mtxConfig[LEGACY_SERVICE_WHITELIST];

        if (entityWhitelist && !Array.isArray(entityWhitelist)) {
            entityWhitelist = [entityWhitelist];
        }

        if (serviceWhitelist && !Array.isArray(serviceWhitelist)) {
            serviceWhitelist = [serviceWhitelist];
        }
        return {entityWhitelist, serviceWhitelist};
    }
}

class AllowlistChecker extends Checker {

    static _setupPermissionList(mtxConfig, fullCsn) {
        return new Allowlist(mtxConfig, fullCsn);
    }

    static async check(reflectedExtensionCsn, fullCsn, extensionFiles, compileDir, mtxConfig) {

        logger.info('Checking allowlist rules');

        const allowList = this._setupPermissionList(mtxConfig, fullCsn);

        logger.debug(`Using allowlists\n${JSON.stringify(allowList)}`); // TODO toString()

        const warnings = [];

        // check entities
        if (reflectedExtensionCsn.extensions && allowList) {
            for (const extension of reflectedExtensionCsn.extensions) {
                this._checkEntity(extension, reflectedExtensionCsn, fullCsn, compileDir, allowList, warnings);
            }
        }

        // check services
        const foundServiceExt = {};
        reflectedExtensionCsn.forall((element) => {
            return ['entity', 'element', 'function', 'action'].includes(element.kind);
        }, (element, name, parent) => {
            if (allowList) {
                this._checkService(reflectedExtensionCsn, fullCsn, element, parent,
                    {extensionFiles, compileDir}, allowList, warnings, foundServiceExt); // NOSONAR
            }
        });
        this._addServiceLimitWarnings(foundServiceExt, allowList, compileDir, warnings);

        return warnings;
    }

    static _checkEntity(extension, extCsn, fullCsn, compileDir, allowlist, warnings) {
        const extendedEntity = extension.extend;
        if (extendedEntity && !allowlist.isAllowed('entity', extendedEntity)) {
            if (fullCsn && fullCsn.definitions &&
                (!extCsn.definitions[extendedEntity] || extCsn.definitions[extendedEntity].kind !== 'entity')) {
                const elementFromBase = fullCsn.definitions[extendedEntity];
                const kind = elementFromBase ? elementFromBase.kind : null;

                if (kind === 'entity') {
                    this._addColumnWarnings(extension, warnings, compileDir, allowlist.getList(kind), kind);
                    this._addElementWarnings(extension, warnings, compileDir, allowlist.getList(kind), kind);
                }
            }
        } else if (extendedEntity) {
            this._addEntityLimitWarnings(extension, warnings, compileDir, allowlist, 'entity');
        }
    }

    static _addElementWarnings(extension, warnings, compileDir, allowlist, kind) {
        if (extension.elements) {
            for (const element in extension.elements) {
                warnings.push(this._createAllowlistWarning(extension.extend, extension.elements[element], compileDir, allowlist, LABELS[kind]));
            }
        }
    }

    static _addColumnWarnings(extension, warnings, compileDir, allowlist, kind) {
        // loop columns + elements
        if (extension.columns) {
            for (const column of extension.columns) {
                warnings.push(this._createAllowlistWarning(extension.extend, column, compileDir, allowlist, LABELS[kind]));
            }
        }
    }

    static _addEntityLimitWarnings(extension, warnings, compileDir, allowlist, kind) {

        const limit = allowlist.getPermission(kind, extension.extend)[NEW_FIELDS];

        if (!limit) {
            return;
        }

        if ( ((extension.columns ? extension.columns.length : 0)
            + (extension.elements ? Object.keys(extension.elements).length : 0)) <= limit) {
            return;
        }

        // loop columns + elements
        if (extension.columns) {
            for (const column of extension.columns) {
                warnings.push(this._createLimitWarning(extension.extend, column, compileDir, limit, LABELS[kind]));
            }
        }

        if (extension.elements) {
            for (const element in extension.elements) {
                warnings.push(this._createLimitWarning(extension.extend, extension.elements[element], compileDir, limit, LABELS[kind]));
            }
        }
    }

    static _addServiceLimitWarnings(foundServiceExt, allowlist, compileDir,  warnings) {

        if (!allowlist) {
            return;
        }

        for (const service in foundServiceExt) {
            let extLimit = allowlist.getPermission('service', service)[NEW_ENTITIES];
            if (extLimit && extLimit <= foundServiceExt[service].length) {
                // loop all extension for one service
                for (const element of foundServiceExt[service]) {
                    warnings.push(this._createLimitWarning(service, element, compileDir, extLimit, LABELS['service']));
                }
            }
        }
    }

    static _getParentName(element) {
        if (element.name) {
            const splitEntityName = element.name.split('.');
            if (splitEntityName.length > 1) {
                splitEntityName.pop();
                return splitEntityName.join('.');
            }
        }
        return null;
    }

    static _isDefinedInExtension(reflectedCsn, name) {
        return (reflectedCsn.definitions ? !!reflectedCsn.definitions[name] : false)
    }

    static _isDefinedInBasemodel(fullCsn, name) {
        return (!!this._getFromBasemodel(fullCsn, name));
    }

    static _getFromBasemodel(fullCsn, name) {
        return fullCsn.definitions[name];
    }

    static _checkService(reflectedExtensionCsn, fullCsn, element, parent, extension, allowlist, warnings, foundExt) {

        if (parent && parent.kind && (parent.kind !== 'service')) {
            return;
        }

        let parentName;
        if (!parent) {
            parentName = this._getParentName(element);
        } else {
            parentName = this._getEntityName(parent);
        }

        // definition of element in extension itself
        if (!parentName) {
            return;
        }

        // check if parent is defined in extension itself
        if (this._isDefinedInExtension(reflectedExtensionCsn, parentName)) {
            return;
        }

        // check if parent is defined in basemodel
        if (!this._isDefinedInBasemodel(fullCsn, parentName)) {
            return;
        }

        if (allowlist.isAllowed('service', parentName)) {
            foundExt[parentName] = foundExt[parentName] || [];
            foundExt[parentName].push(element);
            return;
        }

        warnings.push(this._createAllowlistWarning(parentName, element, extension.compileDir, allowlist.service, LABELS['service']));
    }

    static _createAllowlistWarning(entityName, element, compileDir, allowlist = {}, label) {
        const originFile = this._localizeFile(element.$location.file, compileDir);

        return  label + ' '
                + entityName
                + ' must not be extended. See '
                + '(line:' + element.$location.line + ', col:' + element.$location.col + ')'
                + ' in ' + originFile
                + '. Check ' + label + ' allowlist: '
                + ((Object.keys(allowlist).length > 0) ? Object.keys(allowlist) : '<empty list>');
    }

    static _createLimitWarning(entityName, element, compileDir, limit, label) {
        const originFile = this._localizeFile(element.$location.file, compileDir);

        return `Extension limit of ${limit} for ${label} ${entityName} has been exceeded`
            + `(line: ${element.$location.line}, col:  ${element.$location.col})`
            + ` in ${originFile}`;
    }

    static _getEntityName(entity) {
        return entity.extend ? entity.extend :entity.name;
    }
}

module.exports = AllowlistChecker;
