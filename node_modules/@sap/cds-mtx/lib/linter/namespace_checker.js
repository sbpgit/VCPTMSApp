const Checker = require('./checker_base');
const Logger = require('../helper/logger');
const logger = Logger('NAMESPACE_CHECKER');


class NamespaceChecker extends Checker {

    static async check(extensionCsn, fullCsn, compileDir, mtxConfig) {

        logger.info('Checking namespace rules');

        let elementPrefixes = mtxConfig['element-prefix'] || [];
        let namespaceBlacklist = mtxConfig['namespace-blacklist'] || mtxConfig['namespace-blocklist'] || [];

        if(elementPrefixes.length < 1 && namespaceBlacklist.length < 1) {
            return [];
        }

        if(!Array.isArray(elementPrefixes)) {
            elementPrefixes = [ elementPrefixes ];
        }

        if(!Array.isArray(namespaceBlacklist)) {
            namespaceBlacklist = [ namespaceBlacklist ];
        }

        const warnings = [];

        if (extensionCsn.extensions) { // forall switches back to definitions if extensions are undefined
            extensionCsn.forall(()=>true, (element, name, parent) => {
                element.name = name; // TODO check if bug
                this._checkElement(element, parent, elementPrefixes, compileDir, warnings);
            }, extensionCsn.extensions);
        }

        extensionCsn.forall((element) => {
            return ['entity', 'function', 'action'].includes(element.kind);
        }, (entity) => {
            this._checkEntity(entity, extensionCsn, fullCsn, elementPrefixes, compileDir, warnings);
        });

        extensionCsn.forall('service', (service) => {
            this._checkNamespace(service, namespaceBlacklist, compileDir, warnings);
        });

        extensionCsn.forall('entity', (entity) => {
            this._checkNamespace(entity, namespaceBlacklist, compileDir, warnings);
        });

        return warnings;
    }


    static _checkElement(element, parent, elementPrefixes, compileDir, warnings) {
        if (elementPrefixes.length < 1) {
            return;
        }

        if (!parent) {
            return;
        }

        for (const elementPrefix of elementPrefixes) {
            if (!parent.extend || element.name.startsWith(elementPrefix)) {
                return;
            }
        }

        warnings.push(this._createPrefixWarning(element, compileDir, elementPrefixes));
    }

    static _checkEntity(element, reflectedCsn, reflectedFullCsn, elementPrefixes, compileDir, warnings) {
        if (elementPrefixes.length < 1) {
            return;
        }

        if (!this._hasEnclosingEntity(reflectedCsn, element)) {
            return;
        }

        const parent = this._getEnclosingEntity(reflectedCsn, element);

        // parent exists in extension
        if (parent) {
            return;
        }

        // check full csn for parent - if it exists, continue
        const parentFromFullCsn = this._getEnclosingEntity(reflectedFullCsn, element);
        if (!parentFromFullCsn) {
            return;
        }

        // checks nested element - TODO determine real parent and split off parent name
        const nestedElementName = this._getNestedEntityName(element); // ,parent

        for (const elementPrefix of elementPrefixes) {
            if (nestedElementName.startsWith(elementPrefix)) {
                return;
            }
        }

        warnings.push(this._createPrefixWarning(element, compileDir, elementPrefixes));
    }

    static _hasEnclosingEntity(reflectedCsn, element) {
        const plainEntityName = element.name.replace(reflectedCsn.namespace + '.', '');
        const splitEntityName = plainEntityName.split('.');
        if (splitEntityName.length > 1) {
            return true;
        }
        return false;
    }

    static _getEnclosingEntity(reflectedCsn, element) {
        const splitEntityName = element.name.split('.');
        if (splitEntityName.length > 1) {
            splitEntityName.pop();
            return reflectedCsn.definitions[splitEntityName.join('.')];
        }
        return null;
    }

    static _getNestedEntityName(element) {
        const splitEntityName = element.name.split('.');
        splitEntityName.shift();
        return splitEntityName.join('.');
    }

    static _checkNamespace(element, namespaceBlacklist, compileDir, warnings) {
        for (const namespace of namespaceBlacklist) {
            if (element.name.startsWith(namespace)) {
                warnings.push(this._createNamespaceWarning(element, compileDir, namespace));
            }
        }
    }


    static _createPrefixWarning(element, compileDir, prefixRule) {
        const originFile = this._localizeFile(element.$location.file, compileDir);

        return 'Element '
                + element.name
                + ' from '
                + originFile
                + ' (line:' + element.$location.line + ', col:' + element.$location.col + ')'
                + ' does not adhere to prefix rule: '
                + prefixRule;
    }


    static _createNamespaceWarning(element, compileDir, namespace) {
        const originFile = this._localizeFile(element.$location.file, compileDir);

        return 'Element '
            + element.name
            + ' from '
            + originFile
            + ' (line:' + element.$location.line + ', col:' + element.$location.col + ')'
            + ' uses a forbidden namespace: ' + namespace;
    }


}

module.exports = NamespaceChecker;
