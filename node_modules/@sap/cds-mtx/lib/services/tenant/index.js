const cds = require('@sap/cds');

const HdiBuilder = require('../../build/hdi_builder');
const GlobalConnections = require('../../helper/global_connections');
const getDomain = GlobalConnections.getDomain;
const SessionHelper = require('../../helper/session_helper');
const Logger = require('../../helper/logger');
const TenantMetadata = require('./tenant_cache');

const { GLOBAL_DATA_META_TENANT, META_TENANT_REGEX, MT_LIB_TENANT_REGEX, UPDATE_TYPE } = require('../../../config/constants');
const FileSystemHelper = require('../../helper/file_system_helper');
const path = require('path')
const LogCollector = require('../../helper/log_collector');

class TenantPersistenceServiceImpl {

    static get logger() {
        return this._logger = this._logger || Logger('TENANT_PERSISTENCE_SERVICE');
    }

    static async createTenant(context, tenantId, subscriptionData) {
        TenantPersistenceServiceImpl.logger.debug(`Tenant creation started: ${tenantId}`);

        const builder = new HdiBuilder(tenantId);
        let metadataPersistence;

        try {
            const [instanceData, sidecarDataAdapter] = (await Promise.allSettled([
                GlobalConnections.applicationDataPersistence.onboardTenant(tenantId, subscriptionData, true),
                GlobalConnections.createMetadataPersistenceAndConnect(tenantId, true, subscriptionData)
            ])).map(({status, reason, value}) => {
                if (status === 'rejected') throw reason
                else return value
             });

            metadataPersistence = sidecarDataAdapter;

            // preserve existing extensions if called idempotent
            const domain = GlobalConnections.getDomain();
            const isExtended = await GlobalConnections.applicationDataPersistence.isExtended(tenantId, domain);

            await metadataPersistence.saveBaseModel();
            await metadataPersistence.saveOnboardingMetadata(subscriptionData);

            const { basemodelFiles, migrationFiles, extensionFiles } = await metadataPersistence.getModelFilesRaw(isExtended);

            const { basemodelFolders } = await builder.setupProject(basemodelFiles, migrationFiles, extensionFiles);

            const { compiledFiles, dbDir, languages, services, hana: hanaFiles} = await builder.build(basemodelFolders);

            const undeployWhitelist = await metadataPersistence.getUndeployWhitelist();
            const options = { undeployWhitelist };
            await this._deployToDb(context, dbDir, instanceData, options);

            // retrieve all migration file from build directory
            const allMigrationFiles = await builder.getMigrationFiles();

            await metadataPersistence.saveBuildResults(compiledFiles, hanaFiles, services, languages, allMigrationFiles, false);

            await GlobalConnections.applicationDataPersistence.logUpdate(tenantId, getDomain(), UPDATE_TYPE.CREATE);
        } finally {
            if (metadataPersistence) {
                await metadataPersistence.destroy();
            }
            await builder.destroy();
            await SessionHelper.ensureConnected();
        }
    }

    static async deleteTenant(tenantId) {
        TenantPersistenceServiceImpl.logger.info(`Offboarding tenant ${tenantId}`);

        const metadataPersistence = await (await GlobalConnections.getTenantMetadataPersistenceFactory()).createInstance();
        await metadataPersistence.offboardMetaTenant(tenantId);
        await GlobalConnections.applicationDataPersistence.offboardTenant(tenantId);

        TenantPersistenceServiceImpl.logger.info(`Offboarded tenant ${tenantId}`);

        await GlobalConnections.applicationDataPersistence.logUpdate(tenantId, getDomain(), UPDATE_TYPE.DELETE);
    }

    static async updateBaseModel(context, tenantId, data) {
        const {
            instanceData,
            deploymentOptions,
            basemodelBuild,
            basemodelBuildLogs,
            isExtended
        } = data;

        let compiledFiles, dbDir, languages, services, hanaFiles, basemodelMigrationFiles;
        if (!isExtended) {
           ({compiledFiles, dbDir, languages, services, hanaFiles, basemodelMigrationFiles} = basemodelBuild);
        }

        let logCollector;
        if (LogCollector.isEnabled()) {
            logCollector = new LogCollector();
        }

        try {
            TenantPersistenceServiceImpl.logger.debug(`Upgrading tenant ${tenantId}`);
            const metadataPersistence = await GlobalConnections.createMetadataPersistenceAndConnect(tenantId, true);

            const builder = new HdiBuilder();
            try {
                let allMigrationFiles;
                if (isExtended) {
                    const newBasemodelMigrationFiles = await metadataPersistence.saveBaseModel();
                    const {basemodelFiles, migrationFiles, extensionFiles} = await metadataPersistence.getModelFilesRaw(true);
                    const {basemodelFolders} = await builder.setupProject(basemodelFiles, migrationFiles, extensionFiles);

                    // extract tenant migration files for later use in build
                    const tenantMigrationFiles = await builder.getMigrationFiles();

                    // run build including extensions
                    ({compiledFiles, dbDir, languages, services, hana: hanaFiles} = await builder.build(basemodelFolders, logCollector));
                    // build produced an migrationtable file including extensions. But it does not contain the original
                    // migration steps from the new base model
                    // -> merge with files from tenant

                    // merge all files from base with those of tenant, assuming that all new migration files are
                    // properly copied to the temp project dir
                    const mergedMigrationFiles = await builder.mergeMigrationFiles(tenantMigrationFiles, newBasemodelMigrationFiles);
                    // files have to be stored in the deployment dir as well
                    await FileSystemHelper.writeFilesFromMap(mergedMigrationFiles, path.dirname(dbDir)); // use gen
                    allMigrationFiles = await builder.getMigrationFiles();
                } else {
                    logCollector.log(`Shared basemodel build: ${basemodelBuildLogs}`);
                }

                const undeployWhitelist = await metadataPersistence.getUndeployWhitelist();
                const effectiveDeploymentOptions = Object.assign(deploymentOptions, { undeployWhitelist, logCollector })
                await this._deployToDb(context, dbDir, instanceData, effectiveDeploymentOptions);

                // retrieve all migration file from build directory
                if (!allMigrationFiles) allMigrationFiles = basemodelMigrationFiles;
                await metadataPersistence.saveBuildResults(compiledFiles, hanaFiles, services, languages, allMigrationFiles, false)
            } finally {
                if (metadataPersistence) await metadataPersistence.destroy();
                await builder.destroy();
            }

            await GlobalConnections.applicationDataPersistence.logUpdate(tenantId, getDomain(), UPDATE_TYPE.BASE);
            TenantPersistenceServiceImpl.logger.debug(`Successfully upgraded tenant ${tenantId}`);
            return { status: 'SUCCESS', message: '', buildLogs: logCollector ? logCollector.logs : null };
        } catch (error) {
            TenantPersistenceServiceImpl.logger.error(error);
            return { status: 'FAILURE', message: error.toString(), buildLogs: logCollector ? logCollector.logs : null };
        }
    }

    static async _deployToDb(context, dbDir, instanceData, deployOptions) {

        const tenantPersistenceService = await cds.connect.to('TenantPersistenceService');
        // it is important to open a new transaction here with the given context as this can also be called
        // by a job that is no longer running in the right request context
        const tx = tenantPersistenceService.tx(context);
        return await tx.deployToDb(dbDir, instanceData, deployOptions, {});
    }

    static async getAllWithMetadata() {
        const existingTenantIds = await TenantPersistenceServiceImpl.getAllTenantIds();
        const loadedTenantIds = !TenantMetadata.all ? existingTenantIds : TenantMetadata.update(existingTenantIds);
        const metadataPromises = await Promise.allSettled(loadedTenantIds.map(TenantPersistenceServiceImpl.getMetadata));
        const rejectedPromises = metadataPromises.filter(({status}) => status === 'rejected');
        if (rejectedPromises.length > 0) {
            rejectedPromises.forEach(({reason}) => {
                TenantPersistenceServiceImpl.logger.error({ error: { ...reason, message: reason.message } });
            });
            throw rejectedPromises[0].reason;
        }
        const allTenantMetadata = metadataPromises.map(({value}) => value);
        !TenantMetadata.all ? TenantMetadata.init(allTenantMetadata) : TenantMetadata.fill(allTenantMetadata);
        return TenantMetadata.all;
    }

    static async getAllTenantIds() {
        return (await GlobalConnections.applicationDataPersistence.getAllTenants())
            .map(tenant => tenant.tenant_id)
            .filter(tenantId =>
                !META_TENANT_REGEX.test(tenantId) &&
                !MT_LIB_TENANT_REGEX.test(tenantId) &&
                tenantId.toLowerCase() !== GLOBAL_DATA_META_TENANT.toLowerCase()
            );
    }

    static async getMetadata(tenantId) {
        TenantPersistenceServiceImpl.logger.debug(`Load metadata for tenant ${tenantId}`);
        const metadataPersistence = await GlobalConnections.createMetadataPersistenceAndConnect(tenantId);
        try {
            return await metadataPersistence.getOnboardingMetadata();
        } finally {
            if (metadataPersistence) {
                await metadataPersistence.destroy();
            }
        }
    }
}

module.exports = cds.service.impl(function() {

    this.on('createTenant', async context => {
        const { tenantId, subscriptionData } = context.data;
        return TenantPersistenceServiceImpl.createTenant(context, tenantId, subscriptionData);
    });

    this.on('deleteTenant', async context => {
        return TenantPersistenceServiceImpl.deleteTenant(context.data.tenantId);
    });

    this.on('upgradeTenant', async context => {
        return TenantPersistenceServiceImpl.updateBaseModel(context, context.data.tenantId, context.data);
    });

    this.on('deployToDb', async context => {

        const { sourceDir, instanceData, deploymentOptions, additionalServices } = context.data;

        await GlobalConnections.deploymentStrategy.deployModel(sourceDir, instanceData, deploymentOptions, additionalServices);
    });

    this.on('getAllTenants', async context => {
        return TenantPersistenceServiceImpl.getAllWithMetadata();
    });

    this.on('getAllTenantIds', async context => {
        return TenantPersistenceServiceImpl.getAllTenantIds();
    });

    this.on('getTenantMetadata', async context => {
        return TenantPersistenceServiceImpl.getMetadata(context.data.tenantId);
    });
});
