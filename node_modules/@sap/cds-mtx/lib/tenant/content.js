const GlobalConnections = require('../helper/global_connections');
const Logger = require('../helper/logger');
const logger = Logger('CONTENT');
const path = require('path');
const fs = require('fs');
const TenantMissingError = require('../errors/tenant_missing_error');

const {
    BASE_MODEL_NAME,
    BASE_MODEL_NATIVE_HANA_FILTER,
    BASE_MODEL_FILES_FILTER,
    BASE_MODEL_EXTENSION_PROJECT_FILTER,
    TEMPLATES_DIR
} = require('../../config/constants');

const InstanceManagerFactory = require('../helper/cf/instance_manager_factory');

const TEMPLATE_DIRS = [
    path.join(process.cwd(), 'gen', 'tpl'),
    path.join(process.cwd(), 'tpl')
];

let templateFiles;

class Content {

    static async getExtension(tenantId) {
        logger.info(`Exporting model for tenant: ${tenantId}`);
        const instanceManager = await InstanceManagerFactory.get();
        const dataTenantExists = await GlobalConnections.applicationDataPersistence.tenantExists(tenantId, instanceManager);
        if (!dataTenantExists) {
            logger.info(`Tenant does not exist: ${tenantId}`);
            throw new TenantMissingError(tenantId);
        }

        const metadataPersistence = await GlobalConnections.createMetadataPersistenceAndConnect(tenantId, true);

        try {
            const extensionPackageJsonPath = path.join(TEMPLATES_DIR, 'extension_package.json');
            const content = await fs.promises.readFile(extensionPackageJsonPath, { encoding: 'utf8' });
            const extensionPackageJson = JSON.parse(content);

            extensionPackageJson.name = await metadataPersistence.getTenantAppname();

            const files = await metadataPersistence.getBaseModelFilesRaw();
            const base = this._convertToExtensionProject(files);

            const extension = await metadataPersistence.getExtensionFiles();

            const packageJson = JSON.stringify(extensionPackageJson, null, 4);
            if (!extension.has('package.json')) {
                extension.set('package.json', packageJson);
            }

            return {
                base,
                extension
            };

        } finally {
            await metadataPersistence.destroy();
        }
    }

    static _isModelFile(filename) {
        return BASE_MODEL_EXTENSION_PROJECT_FILTER.test(filename);
    }

    static _convertToExtensionProject(files) {
        const basemodelFiles = new Map();

        for (const [file, content] of files) {
            if (this._isModelFile(file)) {
                const prefixedPath = path.join('node_modules', BASE_MODEL_NAME, file);
                basemodelFiles.set(prefixedPath, content);
            }
        }

        return basemodelFiles;
    }

    static async getTemplateFiles() {
        if (templateFiles) return templateFiles;

        const FileSystemHelper = require('../helper/file_system_helper');
        const templatePath = await FileSystemHelper.getExistingFolder(TEMPLATE_DIRS);
        if (!templatePath) {
            logger.debug('No template files found');
            templateFiles = new Map();
            return templateFiles;
        }
        logger.debug(`Loading template from: ${templatePath}`);

        templateFiles = await FileSystemHelper.readAllFilesInDirectory(templatePath);
        return templateFiles;
    }
}

module.exports = Content;
