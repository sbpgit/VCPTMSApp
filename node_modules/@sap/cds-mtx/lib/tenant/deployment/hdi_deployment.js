const fs = require('fs');
const path = require('path');
const cds = require('../../cds');
const CONSTANTS = require('../../../config/constants');
const Deployment = require('./deployment');
const DeploymentError = require('../../errors/deployment_error');
const Logger = require('../../helper/logger');
const FileSystemHelper = require('../../helper/file_system_helper');

const { deploy, clean_env } = (() => {
    try {
        return require('@sap/hdi-deploy/library');
    } catch (error) {
        error.message = `Unable to require @sap/hdi-deploy. Error: ${error.message}\nMake sure it is in your list of dependencies.`;
        throw error;
    }
})()

const MAX_ATTEMPTS = 3;

// subset of https://help.sap.com/viewer/4505d0bdaf4948449b7f7379d24d0f0d/2.0.05/en-US/a4bbc2dd8a20442387dc7b706e8d3070.html
const ALLOWED_HDI_OPTIONS = [
    'undeploy',
    'path_parameter',
    'path-parameter', // leave it for now in case someone has used it (without impact) so that the deployment does not break
    'include_filter',
    'exclude_filter',
    'write_timeout',
    'write-timeout', // see above
    'connection_timeout',
    'connection-timeout', // see above
    'trace',
    'lock_container_timeout',
    'lock-container-timeout', // see above
    'working_set'
]

class HdiDeployment extends Deployment {

    static async deployModel(dbDir, instanceData, options = {}, additionalServices = {}) {

        const {
            undeployExtension = false,
            undeployWhitelist = [],
            autoUndeploy = false,
            advancedOptions = null,
            logCollector = false,
            ignoreHdiOptions = false
        } = options;

        const logger = Logger(`HDI_DEPLOYMENT-${instanceData.tenant_id}`, logCollector);

        if (!dbDir) {
            logger.info('No "db" directory set - skipping deployment');
            return;
        }

        logger.debug(`The "db" directory is:`, dbDir);
        logger.debug(`Undeploy whitelist is`, undeployWhitelist);
        logger.debug(`Advanced options are `, advancedOptions);

        const templateHdiConfig = path.join(CONSTANTS.TEMPLATES_DIR, '.hdiconfig');
        const dbHdiConfig = path.join(dbDir, 'src', '.hdiconfig');
        await FileSystemHelper.copy(templateHdiConfig, dbHdiConfig, { overwrite: false });

        logger.info('Deploying using internal deployer');

        if (undeployExtension) {
            logger.debug('Writing undeploy.json because undeploy=true');
            await this._writeUndeployJson(dbDir, undeployWhitelist, logger);
        } else {
            logger.debug('Not writing undeploy.json because undeploy=false');
        }

        if (logger.hasLevel(logger.LOG_LEVELS.debug)) {
            const allFiles = await FileSystemHelper.readAllFilesInDirectory(dbDir, { skipContent: true });
            logger.debug(`Files to deploy: ${Array.from(allFiles.keys())}`);
        }

        const deployerEnv = this._prepareEnv(instanceData, autoUndeploy, advancedOptions, additionalServices, logger, ignoreHdiOptions);

        logger.debug('---------------[HDI-DEPLOY-OUTPUT]---------------');
        logger.debug(`Using environment ${deployerEnv.HDI_DEPLOY_OPTIONS}`);

        const tryDeployment = async (attempt = 1) => {
            try {
                await this._deployPromise(dbDir, deployerEnv, logger);
            } catch (error) {
                logger.error(error);
                if (attempt <= MAX_ATTEMPTS) {
                    logger.info(`Retrying deployment (attempt ${attempt} of ${MAX_ATTEMPTS})`);
                    await tryDeployment(attempt + 1);
                } else {
                    logger.info(`Maximum number of attempts exceeded. Aborting deployment.`);
                    throw error;
                }
            }
        }

        try {
            await tryDeployment();
            logger.info('Deployment successfully finished');
        } finally {
            logger.debug('---------------[HDI-DEPLOY-OUTPUT]---------------');
        }

    }

    static async _writeUndeployJson(dbDir, undeployWhitelist, logger) {
        const undeployPath = path.join(dbDir, 'undeploy.json');
        let undeployWhitelistToWrite = undeployWhitelist;

        if (await FileSystemHelper.pathExists(undeployPath)) {
            logger.debug('Merging undeploy whitelists');
            const undeployJson = await fs.promises.readFile(undeployPath, { encoding: 'utf8' });
            try {
                const undeploy = JSON.parse(undeployJson);
                const mergedUndeploy = new Set(undeployWhitelist.concat(undeploy));
                undeployWhitelistToWrite = Array.from(mergedUndeploy);
            } catch(error) {
                const message = `Could not parse undeploy.json of base model (${undeployPath})`;
                logger.error(error, message);
                throw new DeploymentError(message, error);
            }
        }

        await fs.promises.writeFile(undeployPath, JSON.stringify(undeployWhitelistToWrite, null, 4));
    }

    static _verifyAdvancedOptions(advancedOptions) {
        for (const option in advancedOptions) {
            if (!ALLOWED_HDI_OPTIONS.includes(option)) {
                throw new DeploymentError(`HDI deployment option '${option}' cannot be used with mtx deployment`);
            }
        }
        return;
    }

    static _getDeployOptionsFromEnv() {
        const jsonEnv = process.env.HDI_DEPLOY_OPTIONS;
        if (jsonEnv) {
            try {
                return JSON.parse(jsonEnv);
            } catch (error) {
                throw new DeploymentError(`Invalid HDI deployment options: ${jsonEnv}`, error);
            }
        }
    }

    static _prepareEnv(instanceData, autoUndeploy, advancedOptions, additionalServices, logger, ignoreOptions = false) {

        const deployOptions = {};

        if (!ignoreOptions) {
            HdiDeployment._verifyAdvancedOptions(advancedOptions);

            //first get and check deploy options from env
            const deployOptionsFromEnv = this._getDeployOptionsFromEnv();
            if (deployOptionsFromEnv) {
                HdiDeployment._verifyAdvancedOptions(deployOptionsFromEnv);
                Object.assign(deployOptions, deployOptionsFromEnv);
            }

            // add additional deploy options from request
            if (advancedOptions) {
                Object.assign(deployOptions, advancedOptions);
            }
        }

        // add fixed deploy options
        Object.assign(deployOptions, { "auto_undeploy": autoUndeploy, "verbose": true } );

        let deployerEnv = JSON.parse(JSON.stringify(process.env));
        if (clean_env) {
            deployerEnv = clean_env(deployerEnv);
        }

        // name the container
        instanceData.name = instanceData.tenant_id;

        // use it also as target
        deployerEnv.TARGET_CONTAINER = instanceData.name;

        const vcap = { hana: [instanceData] };
        this._addAdditionalServices(vcap, additionalServices, logger);

        const serviceReplacements = this._getServiceReplacements();
        if (serviceReplacements) {
            deployerEnv.SERVICE_REPLACEMENTS = serviceReplacements;
        }
        deployerEnv.VCAP_SERVICES = JSON.stringify(vcap);

        deployerEnv.HDI_DEPLOY_OPTIONS = JSON.stringify(deployOptions);

        return deployerEnv;
    }

    static _addAdditionalServices(vcap, additionalServices, logger) {
        // for now: add all other hana services
        if (process.env.VCAP_SERVICES) {
            try {
                const originalVcap = JSON.parse(process.env.VCAP_SERVICES);
                if (originalVcap.hana) {
                    if (Array.isArray(originalVcap.hana)) {
                        for (const service of originalVcap.hana) {
                            logger.debug('Adding additional hana service', service.name);
                            vcap.hana.push(service);
                        }
                    } else {
                        logger.error(`Erroneous hana binding in VCAP_SERVICES: ${JSON.stringify(originalVcap['user-provided'])}`);
                    }
                }
                if (originalVcap['user-provided']) {
                    vcap['user-provided'] = [];
                    if (Array.isArray(originalVcap['user-provided'])) {
                        for (const service of originalVcap['user-provided']) {
                            logger.debug('Adding user-provided service', service.name);
                            vcap['user-provided'].push(service);
                        }
                    } else {
                        logger.error(`Erroneous user-provided binding in VCAP_SERVICES: ${JSON.stringify(originalVcap['user-provided'])}`);
                    }
                }
            } catch (error) {
                logger.error(`Invalid VCAP_SERVICES environment: ${error.message}`);
            }
        }

        for (const service of Object.keys(additionalServices)) {
            if (Array.isArray(additionalServices[service])) {
                vcap[service] = (vcap[service] || []).concat(additionalServices[service]);
            } else {
                logger.error(`Erroneous definition of additional services: ${JSON.stringify(additionalServices[service])}`);
            }
        }
    }

    static _getServiceReplacements() {
        // kept this method to add further configuration ways later
        return process.env.SERVICE_REPLACEMENTS || null;
    }

    static async _deployPromise(dir, env, logger) {
        const logLevel = logger.level || logger.logLevel;
        const infoLogLevel = cds.log.levels && cds.log.levels.INFO || 3;
        const deployLogCollector = { log: '' };
        return new Promise((resolve, reject) => {
            deploy(dir, env, (error, response) => {
                if (error || response && response.exitCode > 0) {
                    if (logLevel === infoLogLevel) {
                        // Has already been logged in the debug log, so we only need this for the 'info' log level
                        logger.info('HDI deployment log before failure:\n', deployLogCollector.log);
                    }
                    const exitCode = response && response.exitCode || undefined;
                    return reject(new DeploymentError(`HDI deployment failed with exit code ${exitCode}`, error));
                }
                return resolve();
            }, {
                stdoutCB: data => {
                    if (logLevel === infoLogLevel) deployLogCollector.log += `${data}`;
                    logger.debug(`${data}`);
                },
                stderrCB: error => logger.error(`${error}`)
            });
        });
    }
}

module.exports = HdiDeployment;
