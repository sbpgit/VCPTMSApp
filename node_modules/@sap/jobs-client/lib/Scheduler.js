'use strict';

const assert = require('assert');
const request = require('request');
const querystring = require('querystring');
const util = require('util');
const xsenv = require('@sap/xsenv');

const debugLog = util.debuglog('scheduler');

function basicInputValidation(obj, mandatoryProps) {
    assert.ok(obj, 'Object expected as argument');
    assert.strictEqual(typeof obj, 'object', 'Object expected as argument');
    if (!mandatoryProps) return;
    for (const prop of Object.keys(mandatoryProps)) {
        assert.ok(obj[prop] !== null && obj[prop] !== undefined, 'Property "' + prop + '" should be provided');
        const expectedType = mandatoryProps[prop];
        if (Array.isArray(expectedType)) {
            assert.ok(expectedType.includes(typeof obj[prop]),
                'Property "' + prop + '" must be of type ' + expectedType.join(' or '));
        } else {
            assert.strictEqual(typeof obj[prop], expectedType,
                'Property "' + prop + '" must be of type ' + expectedType);
        }
    }
}

/**
 * Thin wrapper of Job Scheduler API
 */
class Scheduler {
    /**
     * @param {{ baseURL: ?string, timeout: ?number, token: ?string, user: ?string, password: ?string }} [options = {}] Job Scheduler parameters
     */
    constructor(options = {}) {
        basicInputValidation(options);

        if (!options.baseURL || !options.token && !(options.user && options.password)) {
            try {
                this._credentials = xsenv.getServices({ jobscheduler: { tag: 'jobscheduler' } }).jobscheduler;
            } catch (e) {
                // Do nothing. The input validation below will throw an appropriate error.
            }
        }

        if (this._credentials) this._baseURL = this._credentials.url;
        if (options.baseURL) this._baseURL = options.baseURL;
        assert.strictEqual(typeof this._baseURL, 'string', 'Property "baseURL" must be of type string');
        if (!this._baseURL.endsWith('/')) this._baseURL += '/';
        this._baseURL += 'scheduler';

        assert.ok(
            options.timeout === undefined || options.timeout === null
                || Number.isSafeInteger(options.timeout) && options.timeout > 0,
            'Property "timeout" should be a positive integer');
        this._timeout = options.timeout || 15000; // ms

        if (this._credentials) {
            if (this._credentials.uaa) this._accessToken = -1;  // marker that access token has to be fetched
            this._user = this._credentials.user;
            this._password = this._credentials.password;
        }
        if (options.token) this._accessToken = options.token;
        if (options.user) this._user = options.user;
        if (options.password) this._password = options.password;
        assert.ok(this._accessToken || this._user && this._password,
            'Credentials could not be retrieved; property "token" or "user", "password" must be provided');
    }

    fetchJob(options, done) {
        basicInputValidation(options);
        assert.ok(options.jobId || options.name, 'Either property "jobId" or property "name" should be provided');

        const req = { method: 'GET', uri: this._baseURL + '/jobs', qs: options };
        this._sendRequest(req, done);
    }

    createJob(options, done) {
        basicInputValidation(options, { job: 'object' });

        const req = { method: 'POST', uri: this._baseURL + '/jobs', body: options.job };
        this._sendRequest(req, done);
    }

    updateJob(options, done) {
        basicInputValidation(options, { jobId: ['number', 'string'] });
        this._configureJob(options, options.jobId, done);
    }

    upsertJob(options, done) {
        basicInputValidation(options, { name: 'string' });
        this._configureJob(options, querystring.escape(options.name), done);
    }

    _configureJob(options, idPath, done) {
        basicInputValidation(options, { job: 'object' });
        assert.ok(idPath);

        const req = { method: 'PUT', uri: this._baseURL + '/jobs/' + idPath, body: options.job };
        this._sendRequest(req, done);
    }

    fetchJobSchedule(options, done) {
        basicInputValidation(options, { jobId: ['number', 'string'], scheduleId: 'string', displayLogs: 'boolean' });

        const req = {
            method: 'GET',
            uri: this._baseURL + '/jobs/' + options.jobId + '/schedules/' + options.scheduleId,
            qs: { displayLogs: options.displayLogs }
        };
        this._sendRequest(req, done);
    }

    createJobSchedule(options, done) {
        basicInputValidation(options, { jobId: ['number', 'string'], schedule: 'object' });

        const req = {
            method: 'POST',
            uri: this._baseURL + '/jobs/' + options.jobId + '/schedules',
            body: options.schedule
        };
        this._sendRequest(req, done);
    }

    updateJobSchedule(options, done) {
        basicInputValidation(options, { jobId: ['number', 'string'], scheduleId: 'string', schedule: 'object' });

        const req = {
            method: 'PUT',
            uri: this._baseURL + '/jobs/' + options.jobId + '/schedules/' + options.scheduleId,
            body: options.schedule
        };
        this._sendRequest(req, done);
    }

    deleteJobSchedule(options, done) {
        basicInputValidation(options, { jobId: ['number', 'string'], scheduleId: 'string' });

        const req = {
            method: 'DELETE',
            uri: this._baseURL + '/jobs/' + options.jobId + '/schedules/' + options.scheduleId
        };
        this._sendRequest(req, done);
    }

    updateJobRunLog(options, done) {
        basicInputValidation(options,
            { jobId: ['number', 'string'], scheduleId: 'string', runId: ['number', 'string'], data: 'object' });

        const req = {
            method: 'PUT',
            uri: options.schedulerUrl
                || this._baseURL + '/jobs/' + options.jobId + '/schedules/' + options.scheduleId
                    + '/runs/' + options.runId,
            body: options.data
        };
        this._sendRequest(req, done);
    }

    getRunLogs(options, done) {
        basicInputValidation(options, { jobId: ['number', 'string'], scheduleId: 'string' });
        assert.ok(!options.page_size || options.page_size > 0, 'Property "page_size" should be a non-negative integer');
        assert.ok(!options.offset || options.offset > 0, 'Property "offset" should be a non-negative integer');

        const req = {
            method: 'GET',
            uri: this._baseURL + '/jobs/' + options.jobId + '/schedules/' + options.scheduleId + '/runs',
            qs: { page_size: options.page_size, offset: options.offset }
        };
        this._sendRequest(req, done);
    }

    getRunLogsById(options, done) {
        basicInputValidation(options,
            { jobId: ['number', 'string'], scheduleId: 'string', runId: ['number', 'string'] });

        const req = {
            method: 'GET',
            uri: this._baseURL + '/jobs/' + options.jobId + '/schedules/' + options.scheduleId
                + '/runs/' + options.runId
        };
        this._sendRequest(req, done);
    }

    fetchJobSchedules(options, done) {
        basicInputValidation(options, { jobId: ['number', 'string'] });

        const req = { method: 'GET', uri: this._baseURL + '/jobs/' + options.jobId + '/schedules' };
        this._sendRequest(req, done);
    }

    searchJobs(options, done) {
        const req = { method: 'GET', uri: this._baseURL + '/search/jobs', qs: options };
        this._sendRequest(req, done);
    }

    searchSchedules(options, done) {
        const req = { method: 'GET', uri: this._baseURL + '/search/schedules', qs: options };
        this._sendRequest(req, done);
    }

    deleteJob(options, done) {
        basicInputValidation(options, { jobId: ['number', 'string'] });

        const req = { method: 'DELETE', uri: this._baseURL + '/jobs/' + options.jobId };
        this._sendRequest(req, done);
    }

    activateAllSchedules(options, done) {
        basicInputValidation(options, { jobId: ['number', 'string'] });

        const req = {
            method: 'POST',
            uri: this._baseURL + '/jobs/' + options.jobId + '/schedules/activationStatus',
            body: { activationStatus: true }
        };
        this._sendRequest(req, done);
    }

    deactivateAllSchedules(options, done) {
        basicInputValidation(options, { jobId: ['number', 'string'] });

        const req = {
            method: 'POST',
            uri: this._baseURL + '/jobs/' + options.jobId + '/schedules/activationStatus',
            body: { activationStatus: false }
        };
        this._sendRequest(req, done);
    }

    deleteAllJobSchedules(options, done) {
        basicInputValidation(options, { jobId: ['number', 'string'] });

        const req = { method: 'DELETE', uri: this._baseURL + '/jobs/' + options.jobId + '/schedules' };
        this._sendRequest(req, done);
    }

    getJobCount(options, done) {
        basicInputValidation(options, { activeStatus: 'boolean' });

        const req = { method: 'GET', uri: this._baseURL + '/jobCount' };
        this._sendRequest(req, (err, result) => {
            if (!err && result) {
                if (options.activeStatus) {
                    delete result.inactive;
                } else {
                    delete result.active;
                }
            }
            done(err, result);
        });
    }

    getJobActionLogs(options, done) {
        basicInputValidation(options, { jobId: ['number', 'string'] });

        const req = { method: 'GET', uri: this._baseURL + '/actionLogs?jobId=' + options.jobId };
        this._sendRequest(req, done);
    }

    getScheduleActionLogs(options, done) {
        basicInputValidation(options, { jobId: ['number', 'string'], scheduleId: 'string' });

        const req = {
            method: 'GET',
            uri: this._baseURL + '/actionLogs?jobId=' + options.jobId + '&scheduleId=' + options.scheduleId
        };
        this._sendRequest(req, done);
    }

    fetchAllJobs(options, done) {
        const req = { method: 'GET', uri: this._baseURL + '/jobs', qs: options };
        this._sendRequest(req, done);
    }

    _validateAccessToken() {
        if (!this._accessToken) return true;
        if (this._accessToken === -1) return false;  // marker from the constructor
        const expiryTime = JSON.parse(Buffer.from(this._accessToken.split('.')[1], 'base64').toString('utf8')).exp;
        return expiryTime - Date.now() / 1000 >= 5 * 60;  // access token should be still valid in five minutes
    }

    _fetchAccessToken() {
        return new Promise((resolve, reject) => {
            if (this._validateAccessToken()) {
                resolve(this._accessToken);
            } else {
                const uaa = this._credentials.uaa;
                const options = {
                    form: { response_type: 'token', grant_type: 'client_credentials' }
                };
                if (uaa.certurl && uaa.certificate && uaa.key) {
                    options.url = uaa.certurl + '/oauth/token';
                    options.cert = uaa.certificate;
                    options.key = uaa.key;
                    options.form.client_id = uaa.clientid;
                } else {
                    options.url = uaa.url + '/oauth/token';
                    options.auth = {
                        username: uaa.clientid,
                        password: uaa.clientsecret,
                        sendImmediately: true
                    };
                }
                request.post(options, (error, response, body) => {
                    if (error || response.statusCode !== 200) {
                        reject(error || new Error('Error fetching access token from ' + options.url));
                    } else {
                        this._accessToken = JSON.parse(body).access_token;
                        resolve(this._accessToken);
                    }
                });
            }
        });
    }

    _sendRequest(req, done) {
        this._fetchAccessToken().then(() =>
            this._request(req, (error, response, body) => {
                if (error) {
                    done(error);
                } else if (response.statusCode >= 200 && response.statusCode < 300) {
                    done(null, body);
                } else {
                    const message = body && body.message || ('Status code ' + response.statusCode);
                    let err = new Error(message);
                    err.statusCode = response.statusCode;
                    done(err);
                }
            }))
            .catch(done);
    }

    _request(req, done) {
        const completeRequest = Object.assign({
            auth: {
                bearer: this._accessToken,
                username: this._user,
                password: this._password,
                sendImmediately: true
            },
            json: true,
            timeout: this._timeout
        }, req);
        debugLog('REQUEST:\n%o', completeRequest);
        request(completeRequest, (error, response, body) => {
            debugLog('RESPONSE:\n%o', error
                || {
                    statusCode: response && response.statusCode,
                    headers: response && response.headers,
                    body: body
                });
            done(error, response, body);
        });
    }
}

module.exports = Scheduler;
