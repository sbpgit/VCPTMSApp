"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs = __importStar(require("fs"));
const typescript_json_schema_1 = require("typescript-json-schema");
const utils_1 = require("../src/sync/v2/generate/utils");
const factory_1 = require("../src/sync/v2/export/factory");
const factory_2 = require("../src/sync/v4/export/factory");
const common_1 = require("../src/specification/common");
//TS compiler options, compare with tsconfig
const compilerOptions = {
    skipLibCheck: true,
    types: ['node', '@sapui5/ts-types', 'jest'],
    esModuleInterop: true,
    resolveJsonModule: true,
    downlevelIteration: true
};
/**
 * Convert interfaces to json schema
 * @param path - path to interfaces
 * @param files - file names, filename must match the main symbol (interface) in the content of the file
 */
function convertInterfaces(path, files, version) {
    const schemas = [];
    files.forEach((file) => {
        const generator = typescript_json_schema_1.buildGenerator(typescript_json_schema_1.getProgramFromFiles([path_1.join(path, file)], compilerOptions), {
            noExtraProps: true,
            required: true,
            validationKeywords: ['i18nClassification', 'isViewNode', 'displayName', 'controlProperty']
        });
        if (generator) {
            const filename = file.replace('ts', 'json');
            schemas[filename] = generator.getSchemaForSymbol(file.replace('.ts', ''));
            if (file.search('Config') > -1) {
                //it is a page template ==> enhance schema by further information from reflect-metadata
                let pageType;
                let factory;
                if (version === common_1.FioriElementsVersion.v2) {
                    factory = new factory_1.MetadataInstanceFactoryV2();
                    pageType = file.split('Config')[0];
                }
                else {
                    factory = new factory_2.MetadataInstanceFactoryV4();
                    pageType = file.split('Config')[0];
                }
                const page = factory.createPageInstance(pageType, {});
                utils_1.processMetadata(schemas[filename], schemas[filename], page, pageType, factory);
            }
        }
    });
    return schemas;
}
exports.convertInterfaces = convertInterfaces;
function writeSchemasToFile(path, schemas, version) {
    const dirToWrite = path_1.join(path, version);
    if (!fs.existsSync(dirToWrite)) {
        fs.mkdirSync(dirToWrite);
    }
    for (const schema in schemas) {
        const file = path_1.join(dirToWrite, schema);
        fs.writeFile(file, JSON.stringify(schemas[schema], null, 2), function (err) {
            if (err) {
                return console.log(err);
            }
            console.log("File: '" + file + "' saved.");
        });
    }
}
function convertPagesOfFEVersion(paths, version, outputPath) {
    let fileNames = [];
    for (let index = 0; index < paths.length; index++) {
        fs.readdir(paths[index], function (err, files) {
            if (err) {
                return console.error(err);
            }
            files.forEach(function (pathName) {
                const fileName = path_1.basename(pathName);
                if (fileName !== 'index.ts') {
                    if (!paths[index]) {
                        paths[index] = pathName.replace(fileName, '');
                    }
                    fileNames.push(fileName);
                }
            });
            const schemas = convertInterfaces(paths[index], fileNames, version);
            fileNames = [];
            writeSchemasToFile(outputPath, schemas, version);
        });
    }
}
/**
 * Converts all application and page definitions to JSON schema
 * @param outputPath - path to write to
 */
async function toJsonSchema(outputPath) {
    let schemas = [];
    //Pages V2
    let paths = [];
    paths.push(path_1.join('src', 'specification', 'v2', 'pages'));
    convertPagesOfFEVersion(paths, common_1.FioriElementsVersion.v2, outputPath);
    //Pages V4
    paths = [];
    paths.push(path_1.join('src', 'specification', 'v4', 'pages'));
    convertPagesOfFEVersion(paths, common_1.FioriElementsVersion.v4, outputPath);
    //App V2
    schemas = convertInterfaces(path_1.join('src', 'specification', 'v2'), ['ApplicationV2.ts'], common_1.FioriElementsVersion.v2);
    writeSchemasToFile(outputPath, schemas, 'v2');
    //App V4
    schemas = convertInterfaces(path_1.join('src', 'specification', 'v4'), ['ApplicationV4.ts'], common_1.FioriElementsVersion.v4);
    writeSchemasToFile(outputPath, schemas, 'v4');
}
const dir = path_1.join(__dirname, '..', '..', 'schemas');
if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir);
}
toJsonSchema(dir);
//# sourceMappingURL=to-json-schema.js.map