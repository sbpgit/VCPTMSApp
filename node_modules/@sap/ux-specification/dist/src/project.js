"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = require("fs");
const readFile = async (path) => {
    return new Promise((resolve, reject) => {
        fs_1.readFile(path, { encoding: 'utf8' }, (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
};
const readJSON = async (path) => {
    return JSON.parse(await readFile(path));
};
exports.readDirectory = async (path) => {
    return new Promise((resolve, reject) => {
        fs_1.readdir(path, { encoding: 'utf8' }, (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
};
exports.isDirectory = async (path) => {
    return new Promise((resolve) => {
        fs_1.stat(path, (err, stats) => {
            if (err) {
                resolve(false);
            }
            else {
                resolve(stats.isDirectory());
            }
        });
    });
};
const resourceExists = async (path) => {
    return new Promise((resolve) => {
        fs_1.exists(path, (doesExist) => {
            resolve(doesExist);
        });
    });
};
const getManifest = async (path) => {
    const manifest = await readJSON(path_1.join(path, 'manifest.json'));
    return manifest;
};
const getChanges = async (webapp) => {
    const changes = [];
    const changesDirectory = path_1.join(webapp, 'changes');
    if (!(await resourceExists(changesDirectory))) {
        return changes;
    }
    const files = await exports.readDirectory(changesDirectory);
    for (const file of files) {
        changes.push(await readFile(path_1.join(webapp, 'changes', file)));
    }
    return changes;
};
const getFragments = async (webAppPath) => {
    const fragments = [];
    const directoryPath = path_1.join(webAppPath, 'ext', 'fragments');
    if (!(await resourceExists(directoryPath))) {
        return fragments;
    }
    const files = await exports.readDirectory(directoryPath);
    for (const file of files) {
        const filePath = path_1.join(directoryPath, file);
        const data = await readFile(filePath);
        fragments.push({
            dataSourceUri: filePath,
            fileContent: data
        });
    }
    return fragments;
};
const getAnnotations = async (manifest, webAppPath) => {
    const annotationData = [];
    const serviceDataSources = manifest['sap.app'].dataSources;
    if (serviceDataSources.mainService &&
        serviceDataSources.mainService.settings &&
        serviceDataSources.mainService.settings.localUri) {
        const metadataPath = path_1.join(webAppPath, serviceDataSources.mainService.settings.localUri);
        annotationData.push({
            dataSourceUri: metadataPath,
            fileContent: await readFile(metadataPath)
        });
    }
    if (serviceDataSources &&
        serviceDataSources.mainService &&
        serviceDataSources.mainService.settings &&
        serviceDataSources.mainService.settings.annotations) {
        for (const annotationRef of serviceDataSources.mainService.settings.annotations) {
            const annotationFilePath = path_1.join(webAppPath, serviceDataSources[annotationRef].settings.localUri);
            annotationData.push({
                dataSourceUri: annotationFilePath,
                fileContent: await readFile(annotationFilePath)
            });
        }
    }
    //Consider CAP/multiple services
    if (annotationData.length === 0) {
        for (const key in serviceDataSources) {
            const dataSource = serviceDataSources[key];
            if (dataSource.type === 'ODataAnnotation' && dataSource.settings && dataSource.settings.localUri) {
                const annotationFilePath = path_1.join(webAppPath, dataSource.settings.localUri);
                annotationData.push({
                    dataSourceUri: annotationFilePath,
                    fileContent: await readFile(annotationFilePath)
                });
            }
        }
    }
    return annotationData;
};
/**
 * Get the project artefacts, like manifest, service metadata, annotations
 * @param root - project root where package.json is
 */
exports.getProject = async (root) => {
    const name = path_1.basename(root);
    const webappPath = path_1.join(root, 'webapp');
    const manifest = await getManifest(webappPath);
    const annotations = await getAnnotations(manifest, webappPath);
    const changes = await getChanges(webappPath);
    const fragments = await getFragments(webappPath);
    return {
        root,
        name,
        manifest,
        annotations,
        changes,
        fragments
    };
};
//# sourceMappingURL=project.js.map