"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
/**
 * Type for all available schema types, e.g. Application, ListReport, ObjectPage, ...
 */
var SchemaType;
(function (SchemaType) {
    SchemaType["Application"] = "Application";
    SchemaType["ObjectPage"] = "ObjectPage";
    SchemaType["ListReport"] = "ListReport";
    SchemaType["OverviewPage"] = "OverviewPage";
    SchemaType["AnalyticalListPage"] = "AnalyticalListPage";
})(SchemaType = exports.SchemaType || (exports.SchemaType = {}));
/**
 * Return the path to the generic JSON schema
 * @param version - Fiori elements version
 * @param schemaType - Type of the schema, e.g Application, ListReport, ObjectPage, ...
 */
const getPathToGenericSchema = (version, schemaType) => {
    const fileName = schemaType === SchemaType.Application
        ? SchemaType.Application + version.toUpperCase() + '.json'
        : schemaType + 'Config.json';
    // Path is shorter when using webpack
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return typeof __webpack_require__ === 'function'
        ? path_1.join(__dirname, 'schemas', version, fileName)
        : path_1.join(__dirname, '..', '..', 'schemas', version, fileName);
};
/**
 * Read JSON schema from given path
 * @param path - path to schema file
 */
const readJsonSchema = async (path) => {
    return new Promise((resolve, reject) => {
        fs_1.readFile(path, { encoding: 'utf8' }, (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(JSON.parse(data));
            }
        });
    });
};
/**
 * Return the generic schema for a given version and type
 * @param version - Fiori elements version, e.g. v2 or v4
 * @param schemaType - Type of the schema, e.g Application, ListReport, ObjectPage, ...
 */
exports.getGenericSchema = async (version, schemaType) => {
    try {
        const path = getPathToGenericSchema(version, schemaType);
        return await readJsonSchema(path);
    }
    catch (error) {
        throw new Error(`No schema available for type: ${schemaType}, version: ${version}. Error was ${error.message}`);
    }
};
//# sourceMappingURL=schemaAccess.js.map