"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
const utils_1 = require("../utils");
/**
 * General export rule, joining all given breadcrumbs to the base ID
 * @param baseId - base ID, first part of the stable ID
 * @param idBreadcrumbs - array of ID parts
 */
exports.buildControlIdFromParent = (baseId, idBreadcrumbs) => {
    return baseId + idBreadcrumbs.join('::');
};
/**
 * Export rule for pages
 * @param baseId - base ID, first part of the stable ID
 * @param idBreadcrumbs - array of ID parts
 * @param breadcrumbs - array of breadcrumbs
 */
exports.buildControlIdForPage = (baseId, idBreadcrumbs, breadcrumbs) => {
    return baseId + idBreadcrumbs.join('::') + breadcrumbs[0];
};
/**
 * Converts the section id to the right string for the stable id:
 * If the corresponsing facet has ID maintained, we must take this ID. If ID is not present, take the navigation path.
 * @param sectionId - old ID that shall get converted
 * @param breadcrumbs - array of breadcrumbs
 * @param title - title from JSON schema, comprising the facet ID
 */
exports.convertSectionId = (sectionId, title) => {
    let convertedSectionId;
    const prefix = types_1.FacetTitlePrefix;
    if (title !== undefined && title.includes(prefix)) {
        convertedSectionId = title.split(prefix)[1];
    }
    else {
        convertedSectionId = sectionId.replace(new RegExp('/@', 'g'), '::').replace(/@com.sap/g, 'com.sap');
    }
    return convertedSectionId;
};
function escapeId(sParam) {
    /* escape all characters not allowed in stable ids with :<hexcode>
     * as we use : as escape character, also escape :
     */
    return sParam.replace(/[^-A-Za-z0-9_.:]/g, function (c) {
        const sCode = c.charCodeAt(0).toString(16);
        return ':' + (sCode.length === 1 ? '0' : '') + sCode;
    });
}
exports.escapeId = escapeId;
/**
 * Binding Change values, will be added on object pages  */
var BindingValue;
(function (BindingValue) {
    BindingValue["Editable"] = "{ui>/editable}";
    BindingValue["NotEditable"] = "{= !${ui>/editable}}";
})(BindingValue = exports.BindingValue || (exports.BindingValue = {}));
/**
 * Export rule for table columns
 * @param baseId - base ID, first part of the stable ID
 * @param idBreadcrumbs - array of ID parts
 * @param breadcrumbs - array of breadcrumbs
 * @param controlType - controlType function of ecorators, not used here
 * @param title - title from JSON schema, comprising the facet ID
 */
exports.buildColumnControlId = (baseId, idBreadcrumbs, breadcrumbs, controlType, title) => {
    let sectionId, tableId = 'listReport'; //default
    const localBreadcrumbs = [...breadcrumbs];
    idBreadcrumbs = idBreadcrumbs.map(function (item) {
        if (item === 'sections') {
            for (let index = 0; index < localBreadcrumbs.length; index++) {
                const breadcrumb = localBreadcrumbs[index];
                if (breadcrumb === 'sections') {
                    sectionId = localBreadcrumbs[index + 1];
                    if (sectionId.indexOf('LineItem') !== -1) {
                        localBreadcrumbs[index + 1] = exports.convertSectionId(sectionId, title) + '::Table';
                        return localBreadcrumbs[index + 1];
                    }
                }
            }
        }
        return item;
    });
    if (localBreadcrumbs[0] === 'sections') {
        tableId = localBreadcrumbs[1]
            .replace(/::com.sap.vocabularies/g, types_1.VOCWITHSLASH)
            .replace(/::@com.sap.vocabularies/g, types_1.VOCWITHSLASH);
    }
    else if (idBreadcrumbs[0] === 'table') {
        tableId = idBreadcrumbs[0];
    }
    const lastIdPart = localBreadcrumbs[localBreadcrumbs.length - 1]
        .replace(/::com.sap.vocabularies/g, types_1.VOCWITHSLASH)
        .replace(/::@com.sap.vocabularies/g, types_1.VOCWITHSLASH)
        .replace('sTarget/@', 'sTarget::@')
        .replace('/', ':2f');
    let fullId;
    const splitPoint = lastIdPart.indexOf(':::');
    if (lastIdPart.startsWith('DataField') && splitPoint > -1) {
        fullId =
            baseId +
                'template:::TableColumn:::' +
                lastIdPart.substr(0, splitPoint) +
                ':::sSmartTableId::' +
                tableId.replace('::Table', ':3a:3aTable') +
                ':::' +
                lastIdPart.substr(splitPoint + 3);
    }
    else {
        fullId = baseId + idBreadcrumbs.join('::') + '-' + lastIdPart;
    }
    return escapeId(fullId);
};
/**
 * Split up action breadcrumb and return different parts from it
 * @param breadcrumbs - array of breadcrumbs
 * @returns {object} - actionType, semanticObjectId, actionId of action
 */
exports.getActionBreadcrumbParts = (breadcrumbs) => {
    const actionIdParts = breadcrumbs[breadcrumbs.length - 1].split(':::');
    let actionType, semanticObjectId, actionId;
    if (actionIdParts.length > 2) {
        actionType = actionIdParts[0];
        semanticObjectId = actionIdParts[1].split('::')[1];
        actionId = actionIdParts[2].split('::')[1];
    }
    else if (actionIdParts.length === 2) {
        actionType = actionIdParts[0];
        actionId = actionIdParts[1].split('sAction::')[1];
    }
    else {
        actionId = actionIdParts[0];
    }
    return { actionType, semanticObjectId, actionId };
};
/**
 * Determines the valid pattern for a binding change
 * @param schemaDefinition - definition in the JSON schema
 * @returns the pattern as string
 */
function determinePattern(schemaDefinition) {
    let pattern = types_1.BindingPropertyRegexAsString;
    if (schemaDefinition.enum) {
        let enumPattern;
        schemaDefinition.enum.forEach((enumValue) => {
            if (!enumValue.toString().startsWith('{')) {
                enumPattern = enumPattern ? enumPattern + '|' + enumValue.toString() : enumValue.toString();
            }
        });
        pattern = `^(${enumPattern})$|${pattern}`;
    }
    if (schemaDefinition['type'] && schemaDefinition['type'] === 'boolean') {
        pattern = `^(false|true)$|${pattern}`;
    }
    return pattern;
}
/**
 * Reuseable function for strings that allow binding changes
 * @param schema - the complete JSON schema
 * @param definition - definition in the JSON schema, to be updated
 * @param propertyName - property in the properties' list of the given definition
 * @param bindingValues - values that shall be added to the resulting enum
 */
const addPatternForBindingChangeOfEnum = (schema, definition, propertyName, bindingValues) => {
    const propertyList = definition && definition['properties'];
    if (propertyList[propertyName].pattern) {
        return; //as already processed
    }
    const originalDefinition = propertyList[propertyName];
    let resultDefinition = originalDefinition;
    const targetDefinition = originalDefinition.$ref
        ? schema['definitions'][originalDefinition.$ref.split(utils_1.DEFINITION_LINK_PREFIX)[1]]
        : originalDefinition;
    const description = originalDefinition.description ? originalDefinition.description : targetDefinition.description;
    const pattern = determinePattern(targetDefinition);
    if (targetDefinition['type'] && targetDefinition['type'] === 'boolean') {
        resultDefinition = { enum: [false, true] };
    }
    if (bindingValues && resultDefinition['enum']) {
        bindingValues.forEach((value) => {
            if (resultDefinition['enum'].indexOf(value) === -1) {
                resultDefinition['enum'].push(value);
            }
        });
    }
    propertyList[propertyName] = {
        pattern: pattern,
        anyOf: [
            resultDefinition,
            {
                type: 'string'
            }
        ]
    };
    if (description) {
        propertyList[propertyName].description = description;
        delete originalDefinition.description;
    }
};
exports.addPatternForBindingChangeOfEnumLR = (schema, definition, propertyName) => {
    addPatternForBindingChangeOfEnum(schema, definition, propertyName);
};
exports.addPatternForBindingChangeOfEnumOP = (schema, definition, propertyName) => {
    const bindingValues = Object.values(BindingValue);
    addPatternForBindingChangeOfEnum(schema, definition, propertyName, bindingValues);
};
//# sourceMappingURL=control.js.map