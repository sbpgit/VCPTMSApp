"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StableIdHelper_1 = require("../../v4/utils/StableIdHelper");
const common_1 = require("../../../specification/common");
const __1 = require("..");
/**
 * Copies the field properties from the generic definition to the specific field definition
 * @param {FioriElementsVersion} version - Fiori Elements version
 * @param {object} appSchema - App schema in general
 * @param {DataFieldAbstractTypes} field - field definition in parser output (AVT)
 * @param {string} fieldDefinition - the unique ID for the given field definition
 */
function copyFieldProperties(version, appSchema, field, fieldDefinition) {
    if (version === common_1.FioriElementsVersion.v4 && appSchema['definitions']['Field']) {
        switch (field.$Type) {
            case "com.sap.vocabularies.UI.v1.DataField" /* DataField */:
            case "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */:
            case "com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath" /* DataFieldWithNavigationPath */:
            case "com.sap.vocabularies.UI.v1.DataFieldWithUrl" /* DataFieldWithUrl */: {
                appSchema['definitions'][fieldDefinition]['properties'] =
                    appSchema['definitions']['Field']['properties'];
                break;
            }
        }
    }
    else if (version === common_1.FioriElementsVersion.v2 && appSchema['definitions']['Field']) {
        switch (field.$Type) {
            case "com.sap.vocabularies.UI.v1.DataField" /* DataField */:
            case "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */:
            case "com.sap.vocabularies.UI.v1.DataFieldWithUrl" /* DataFieldWithUrl */: {
                appSchema['definitions'][fieldDefinition]['properties'] =
                    appSchema['definitions']['Field']['properties'];
                break;
            }
        }
    }
}
/**
 * Determines the name for a field definition in app schema
 * @param {FioriElementsVersion} version - Fiori Elements version
 * @param fieldReferenceId - the stable ID representation of the field
 * @param {string} targetID - unique ID, identifies the parent object (form)
 * @param fieldReference - the reference to the field definition in schema
 * @returns the field definition name in schema
 */
function determineFieldDefinitionName(version, fieldReferenceId, targetID, fieldReference) {
    const fieldReferenceType = version === common_1.FioriElementsVersion.v2 && fieldReferenceId && fieldReferenceId.includes('::')
        ? fieldReferenceId.split('::')[0].replace('DataField', 'Field')
        : undefined;
    if (version === common_1.FioriElementsVersion.v2) {
        return `${fieldReferenceType}<${targetID}::${fieldReference}>`;
    }
    else {
        return `${targetID}::${fieldReference}`;
    }
}
/**
 * Adds a field definition to the app specific schema
 * @param {string} sectionType - prefix to distinguish Section and HeaderSection
 * @param {object} appSchema - App schema in general
 * @param {DataFieldAbstractTypes} field - field definition in parser output (AVT)
 * @param {string} targetID - unique ID, identifies the parent object (form)
 * @param {string} key - current field key
 * @param {SectionType} section - current section of the object page
 * @param {FioriElementsVersion} version - Fiori Elements version
 */
function addField(sectionType, appSchema, field, targetID, key, section, version, withActions = true) {
    var _a;
    // Calculate field reference
    const fieldReferenceId = StableIdHelper_1.getStableIdPartFromDataField(field);
    const fieldReference = version === common_1.FioriElementsVersion.v2 && fieldReferenceId && fieldReferenceId.includes('::')
        ? fieldReferenceId.split('::').splice(1).join('::')
        : fieldReferenceId;
    // Determine field definition name
    const fieldDefinition = determineFieldDefinitionName(version, fieldReferenceId, targetID, fieldReference);
    // Evaluate field type, set field reference of properties of fields' or actions' definition
    if (!field || !field.$Type) {
        return;
    }
    else if (field.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */ ||
        field.$Type === "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */) {
        if (withActions && sectionType === __1.SectionType.Section) {
            const actionsDefinition = __1.prepareRef(`${sectionType}Actions<${targetID}>`);
            appSchema['definitions'][actionsDefinition]['properties'][fieldReference] = {
                $ref: __1.DEFINITION_LINK_PREFIX + fieldDefinition,
                propertyIndex: parseInt(key)
            };
        }
    }
    else {
        const fieldsDefinition = __1.prepareRef(`${sectionType}Fields<${targetID}>`);
        appSchema['definitions'][fieldsDefinition]['properties'][fieldReference] = {
            $ref: __1.DEFINITION_LINK_PREFIX + fieldDefinition,
            propertyIndex: parseInt(key)
        };
    }
    // Now set up the field definition
    appSchema['definitions'][fieldDefinition] = {
        type: 'object',
        isViewNode: true,
        properties: {},
        description: __1.getDatafieldDescription(field, section.entityType),
        additionalProperties: false,
        annotationType: field.$Type,
        annotationPath: `/${section.entityType.fullyQualifiedName}/${field.fullyQualifiedName.split(section.entityType.fullyQualifiedName)[1]}`
    };
    __1.addDataTypeToDefinition(appSchema['definitions'][fieldDefinition], field);
    // Copy the generic definition of field properties to the specific one
    copyFieldProperties(version, appSchema, field, fieldDefinition);
    if (field.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */ && ((_a = appSchema['definitions']) === null || _a === void 0 ? void 0 : _a['FormAction'])) {
        appSchema['definitions'][fieldDefinition]['properties'] = appSchema['definitions']['FormAction']['properties'];
    }
}
/**
 * The function determines the target ID that shall be used in the app schema for a form
 * @param section - object describing the section or facet
 * @returns the target ID (string)
 */
function determineTargetIdOfForm(section) {
    let targetID;
    if (section.target && section.target['qualifier'] && section.entityType) {
        targetID = `${section.entityType.name}::${section.base}::${section.target['qualifier']}`;
    }
    else if (section.entityType) {
        targetID = `${section.entityType.name}::${section.base}`;
    }
    else {
        targetID = section.ID;
    }
    return targetID;
}
/**
 * Adds definitions for forms in object page sections to the app schema
 * @param {SectionType} sectionType - prefix to distinguish Section and HeaderSection
 * @param {FacetConfig} section - facet or section in the FE core model
 * @param {object} appSchemaSection - current definition of facet or section in the JSON schema
 * @param {object} appSchema - app specific schema that gets enhanced
 * @param {FioriElementsVersion} version - Fiori Elements version
 */
function handleForm(sectionType, section, appSchemaSection, appSchema, version, withActions = true) {
    var _a;
    if (!section.target) {
        return;
    }
    const targetID = determineTargetIdOfForm(section);
    const formDefinition = __1.prepareRef(`${sectionType}Form<${targetID}>`);
    const fieldsDefinition = __1.prepareRef(`${sectionType}Fields<${targetID}>`);
    const actionsDefinition = __1.prepareRef(`${sectionType}Actions<${targetID}>`);
    // Form definition
    appSchemaSection['properties']['form'] = { $ref: __1.DEFINITION_LINK_PREFIX + formDefinition };
    if (sectionType === __1.SectionType.Section && withActions) {
        appSchema['definitions'][formDefinition] = {
            type: 'object',
            properties: {
                actions: {
                    $ref: __1.DEFINITION_LINK_PREFIX + actionsDefinition
                },
                fields: { $ref: __1.DEFINITION_LINK_PREFIX + fieldsDefinition }
            },
            isViewNode: true,
            description: 'Form',
            additionalProperties: false
        };
        appSchema['definitions'][actionsDefinition] = {
            type: 'object',
            properties: {},
            isViewNode: true,
            description: 'Actions',
            additionalProperties: false
        };
    }
    else {
        appSchema['definitions'][formDefinition] = {
            type: 'object',
            properties: {
                fields: { $ref: __1.DEFINITION_LINK_PREFIX + fieldsDefinition }
            },
            isViewNode: true,
            description: 'Form',
            additionalProperties: false
        };
    }
    if ((_a = section.entityType) === null || _a === void 0 ? void 0 : _a.name) {
        appSchema['definitions'][formDefinition].annotationPath = __1.createAnnotationPath(section.entityType.fullyQualifiedName, section.target['term'], section.target['qualifier']);
    }
    // Fields definition
    appSchema['definitions'][fieldsDefinition] = {
        type: 'object',
        properties: {},
        isViewNode: true,
        description: 'Fields',
        additionalProperties: false
    };
    // Add fields
    if (section.base === __1.FacetBase.Identification) {
        for (const key in section.target) {
            const field = section.target[key];
            if (field) {
                addField(sectionType, appSchema, field, targetID, key, section, version, withActions);
            }
        }
    }
    else {
        for (const key in section.target['Data']) {
            const field = section.target['Data'][key];
            addField(sectionType, appSchema, field, targetID, key, section, version);
        }
    }
}
exports.handleForm = handleForm;
/**
 * Replaces an alias in an annotation ID or reference, based on the AVT references' list
 * @param annotationIdentifier - annotation ID or reference
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @returns the converted string
 */
function replaceAlias(annotationIdentifier, oDataServiceAVT) {
    const potentialAlias = annotationIdentifier.indexOf('.') > -1 ? annotationIdentifier.split('.')[0] : undefined;
    let result = annotationIdentifier;
    if (potentialAlias) {
        const reference = oDataServiceAVT.references.find((ref) => {
            return ref.alias === potentialAlias;
        });
        if (reference) {
            result = annotationIdentifier.replace(potentialAlias, reference.namespace);
        }
    }
    return result;
}
exports.replaceAlias = replaceAlias;
/**
 * Common routine to determine the name and the ID of a header action
 * @param action - action as given by AVT
 * @param entityType - entity type by AVT
 * @returns an object comprising action name and action id
 */
function getActionNameAndId(action, entityType) {
    let separatorIndex = action.lastIndexOf('/');
    if (separatorIndex === -1) {
        separatorIndex = action.lastIndexOf('.');
    }
    let actionName, actionId;
    if (separatorIndex > -1) {
        actionName = action.substr(separatorIndex + 1);
        actionId = action.substr(0, separatorIndex) + '::' + actionName;
    }
    else {
        actionName = action;
        const namespace = entityType.fullyQualifiedName.split(entityType.name)[0];
        actionId = namespace.substr(0, namespace.length - 1) + '::' + actionName;
    }
    return { actionName, actionId };
}
exports.getActionNameAndId = getActionNameAndId;
/**
 * Add Object Page Footer Action Buttons to app-specific schema
 *
 * @param {object} appSchema Schema of the app
 * @param {EntityType} entityType - current entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 */
function addFooterActions(appSchema, entityType, oDataServiceAVT) {
    appSchema['definitions']['ObjectPageFooter'] = JSON.parse(JSON.stringify(appSchema['definitions']['ObjectPageFooter<ObjectPageFooterActions>']));
    // Change reference of footer
    appSchema['properties']['footer'] = {
        $ref: `${__1.DEFINITION_LINK_PREFIX}ObjectPageFooter`
    };
    // Add action to configuration
    appSchema['definitions']['ObjectPageFooter'].properties['actions'] = {
        $ref: `${__1.DEFINITION_LINK_PREFIX}FooterActions`
    };
    const footerActions = (appSchema['definitions']['FooterActions'] = {
        type: 'object',
        properties: {},
        description: 'Actions',
        additionalProperties: false,
        isViewNode: true
    });
    const alias = __1.findAlias(__1.UIVOCABULARY, oDataServiceAVT);
    const actionAnnotation = alias &&
        entityType.annotations &&
        entityType.annotations[alias] &&
        entityType.annotations[alias].Identification;
    if (actionAnnotation) {
        const convertedIdentification = actionAnnotation.fullyQualifiedName.replace(`@${"com.sap.vocabularies.UI.v1.Identification" /* Identification */}`, `/@${"com.sap.vocabularies.UI.v1.Identification" /* Identification */}`);
        footerActions['annotationPath'] = `/${convertedIdentification}`;
        actionAnnotation.forEach((item, index) => {
            if (item['Determining'] && item.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */) {
                const { actionName, actionId } = getActionNameAndId(item.Action, entityType);
                const description = item.Label || actionName;
                const actionDefinitionKey = __1.prepareRef(`ObjectPageFooterAction<${actionId}>`);
                if (appSchema['definitions']['ObjectPageFooterAction']) {
                    appSchema['definitions'][actionDefinitionKey] = Object.assign(Object.assign({}, JSON.parse(JSON.stringify(appSchema['definitions']['ObjectPageFooterAction']))), { description, annotationPath: `/${convertedIdentification}/${index}` });
                }
                else {
                    appSchema['definitions'][actionDefinitionKey] = {
                        isViewNode: true,
                        type: 'object',
                        properties: {},
                        description: description,
                        annotationPath: `/${convertedIdentification}/${index}`
                    };
                }
                footerActions.properties[actionId] = {
                    $ref: `${__1.DEFINITION_LINK_PREFIX}${actionDefinitionKey}`
                };
            }
        });
    }
    else {
        footerActions['annotationPath'] = `/${entityType.fullyQualifiedName}/@${"com.sap.vocabularies.UI.v1.Identification" /* Identification */}`;
    }
    delete appSchema['definitions']['ObjectPageFooterActions'];
    delete appSchema['definitions']['ObjectPageFooter<ObjectPageFooterActions>'];
}
exports.addFooterActions = addFooterActions;
/**
 * Add Object Page Header Action Buttons to app-specific schema
 * @param {object} appSchema Schema of the app
 * @param {EntityType} entityType - current entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 */
function addHeaderActions(appSchema, entityType, oDataServiceAVT, addHeaderActionCallBack) {
    appSchema['definitions']['ObjectPageHeader'].properties['actions'] = {
        $ref: `${__1.DEFINITION_LINK_PREFIX}HeaderActions`
    };
    const headerActions = (appSchema['definitions']['HeaderActions'] = {
        type: 'object',
        properties: {},
        description: 'Actions',
        additionalProperties: false,
        isViewNode: true
    });
    const alias = __1.findAlias(__1.UIVOCABULARY, oDataServiceAVT);
    const identification = alias &&
        entityType.annotations &&
        entityType.annotations[alias] &&
        entityType.annotations[alias].Identification;
    if (identification) {
        headerActions['annotationPath'] =
            '/' +
                identification.fullyQualifiedName.replace(`@${"com.sap.vocabularies.UI.v1.Identification" /* Identification */}`, `/@${"com.sap.vocabularies.UI.v1.Identification" /* Identification */}`);
        identification.forEach(addHeaderActionCallBack(entityType, appSchema, identification, headerActions, oDataServiceAVT));
    }
    else {
        headerActions['annotationPath'] = `/${entityType.fullyQualifiedName}/@${"com.sap.vocabularies.UI.v1.Identification" /* Identification */}`;
    }
    delete appSchema['definitions']['GenericActions'];
    delete appSchema['definitions']['ObjectPageHeader<GenericActions>'];
}
exports.addHeaderActions = addHeaderActions;
/**
 * Adds common Object Page Header definitions to the app schema
 * @param appSchema - app-specific JSOn schema
 * @param entityType - current entity Type
 */
function addCommonHeaderSchema(appSchema, entityType) {
    appSchema['properties']['header'] = {
        $ref: __1.DEFINITION_LINK_PREFIX + 'ObjectPageHeader'
    };
    appSchema['definitions']['ObjectPageHeader'] = JSON.parse(JSON.stringify(appSchema['definitions']['ObjectPageHeader<GenericActions>']));
    appSchema['definitions']['ObjectPageHeader'].annotationPath = `/${entityType.fullyQualifiedName}/@${"com.sap.vocabularies.UI.v1.HeaderInfo" /* HeaderInfo */}`;
}
exports.addCommonHeaderSchema = addCommonHeaderSchema;
/**
 * Common logic to determine the EntitySet of a facet
 * @param facet - current facet or section
 * @param serviceAVT - AVT converter output, comprising all annotation information
 * @returns the entity set as defined in AVT, if found
 */
function determineEntitySetOfFacet(facet, serviceAVT) {
    return facet.entityType
        ? serviceAVT.entitySets.find((es) => es.entityType.name === facet.entityType.name || es.name === facet.entityType.name)
        : undefined;
}
exports.determineEntitySetOfFacet = determineEntitySetOfFacet;
//# sourceMappingURL=objectPage.js.map