"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
/**
 * Adds an enum filled with existing UI annotations of the given list (validAnnotations)
 * @param {EntityType} entityType
 * @param {UIAnnotationTerms[]} validAnnotations
 * @param {Definition} annoPath - the annotation path property in the app schema where the enum shall be added
 */
function addEnumForValidAnnotations(entityType, validAnnotations, annoPath) {
    const UiAnnotations = entityType.annotations.UI;
    if (!UiAnnotations) {
        return;
    }
    const enumEntries = annoPath['enum'] ? annoPath['enum'] : [];
    for (const key in UiAnnotations) {
        const annotation = UiAnnotations[key];
        if (validAnnotations.indexOf(annotation.term) > -1) {
            const enumEntry = annotation.qualifier
                ? `${annotation.term}#${annotation.qualifier}`
                : `${annotation.term}`;
            if (enumEntries.indexOf(enumEntry) === -1) {
                enumEntries.push(enumEntry);
            }
        }
    }
    if (enumEntries.length > 0) {
        annoPath['enum'] = enumEntries;
    }
}
exports.addEnumForValidAnnotations = addEnumForValidAnnotations;
/**
 * Adds an enum filled with existing UI annotations for single-tab variants of a table
 * @param {EntityType} entityType
 * @param {Definition} appSchema - app specific JSON schema
 * @param definitionName - name of the definition in the app schema
 */
function addEnumForSingleTabVariant(entityType, appSchema, definitionName) {
    const annoPath = appSchema['definitions'][definitionName].properties.annotationPath;
    const validAnnotations = ["com.sap.vocabularies.UI.v1.SelectionVariant" /* SelectionVariant */, "com.sap.vocabularies.UI.v1.SelectionPresentationVariant" /* SelectionPresentationVariant */];
    addEnumForValidAnnotations(entityType, validAnnotations, annoPath);
}
exports.addEnumForSingleTabVariant = addEnumForSingleTabVariant;
/**
 * Adds an enum filled with existing UI annotations for multi-tab variants of a table
 * @param appSchema - app specific JSOn schema
 * @param definitionName - name of the definition in the app schema
 * @param {EntitySet} entitySet - current entity set of the page or view
 */
function addEnumForMultiTabVariant(appSchema, definitionName, entitySet) {
    const annoPath = appSchema['definitions'][definitionName].properties.annotationPath;
    const validAnnotations = ["com.sap.vocabularies.UI.v1.SelectionVariant" /* SelectionVariant */, "com.sap.vocabularies.UI.v1.SelectionPresentationVariant" /* SelectionPresentationVariant */];
    addEnumForValidAnnotations(entitySet.entityType, validAnnotations, annoPath);
}
exports.addEnumForMultiTabVariant = addEnumForMultiTabVariant;
/**
 * Adds the enume values for entitySet as part of the multiple view scenario
 * @param {ConverterOutput} oDataServiceAVT - combined service metadata, as returned by annotation vocabularies tools
 * @param appSchema - app specific JSOn schema
 * @param definitionName - name of the definition in the app schema
 */
function addEnumForVariantEntitySet(oDataServiceAVT, appSchema, definitionName) {
    const entitySet = appSchema['definitions'][definitionName].properties.entitySet;
    const enumEntries = [];
    oDataServiceAVT.entitySets.forEach((es) => {
        enumEntries.push(es.name);
    });
    if (enumEntries.length > 0) {
        entitySet['enum'] = enumEntries;
    }
}
exports.addEnumForVariantEntitySet = addEnumForVariantEntitySet;
/**
 * Method adds definition for 'RelatedFacetKeys' as enum with describtion and adds references to 'RelatedFacetKeys' for custom section definitions.
 * @param {object} schema App specific schema that potentially gets enhanced
 * @param {string[]>} sectionDefinitions array of section definitions which should be updated with new reference to 'RelatedFacetKeys' enum.
 * @param {FacetSection[]} facetSections Array of facet section objects which is used to generate enum values.
 * @param {Array<keyof Omit<FacetSection, 'custom'>>} idProperties Array of property names which should be looked up in 'FacetSection' object.
 *  Please note that method depends on order and takes first non empty value associated to passed properties.
 */
function addDefinitionForRelatedFacetKeys(schema, sectionDefinitions, facetSections, idProperties) {
    const oneOfSections = facetSections.map((section) => {
        // Loop accaptable properties in received order and find first entry with value
        const propertyName = idProperties.find((property) => !!section[property]);
        const schemaIdForSection = section[propertyName];
        return Object.assign(Object.assign({ const: schemaIdForSection }, (section.label && { description: section.label })), (section.custom && { custom: section.custom }));
    });
    // Change 'relatedFacet' only when we have entries for sections - otherwise use generic.
    if (oneOfSections.length) {
        // Create new definition in schema as 'oneOf'.
        // Simpler way would be to use 'enum', but then there no option to pass description.
        schema['definitions']['RelatedFacetKeys'] = {
            type: 'string',
            oneOf: oneOfSections
        };
        // Add enum definition
        for (const name of sectionDefinitions) {
            const definition = schema['definitions'][name];
            const property = definition['properties']['relatedFacet'];
            definition['properties']['relatedFacet'] = {
                anyOf: [
                    {
                        $ref: __1.DEFINITION_LINK_PREFIX + 'RelatedFacetKeys'
                    },
                    property
                ]
            };
        }
    }
}
exports.addDefinitionForRelatedFacetKeys = addDefinitionForRelatedFacetKeys;
/**
 * Functions used both by V2 and V4 to add the common definitions for a line item to the app schema
 * @param appSchema - the app specific schema that shall get enhanced
 * @param lineItemAnnotation - the UI.LineItem annotation, comprising all records
 * @param entityType - the entity type as part of the AVT ConverterOutput
 * @param lineItemId - line item ID, as comprise in stable ID
 * @returns the actions definition plus the annotation path to the given line item
 */
function addCommonLineItemDefinitions(appSchema, lineItemAnnotation, entityType, lineItemId) {
    let lineItemPath;
    appSchema['definitions'][lineItemId] = {
        type: 'object',
        properties: {},
        isViewNode: true,
        description: 'Columns'
    };
    appSchema['definitions'][lineItemId].additionalProperties = false;
    // Copy toolbar
    const toolBar = lineItemId.startsWith('LineItems') ? 'ToolBar' : 'ObjectPageToolBar';
    const schemaIdForToolBar = `${toolBar}<${lineItemId}>`;
    appSchema['definitions'][schemaIdForToolBar] = JSON.parse(JSON.stringify(appSchema['definitions'][`${toolBar}`]));
    const schemaIdForActions = `Actions<${__1.prepareRef(lineItemId)}>`;
    appSchema['definitions'][schemaIdForToolBar].properties.actions.$ref = __1.DEFINITION_LINK_PREFIX + schemaIdForActions;
    const actionId = lineItemId.startsWith('LineItems') ? 'Actions' : 'ObjectPageToolBarActions';
    const actions = (appSchema['definitions'][schemaIdForActions] = JSON.parse(JSON.stringify(appSchema['definitions'][actionId])));
    actions.properties = {};
    actions.additionalProperties = false;
    // Copy LR footer
    let footerActions, schemaIdForFooter;
    if (lineItemId === 'LineItems' && appSchema['properties']['footer']) {
        schemaIdForFooter = `Footer<${lineItemId}>`;
        appSchema['properties']['footer'].$ref = __1.DEFINITION_LINK_PREFIX + schemaIdForFooter;
        appSchema['definitions'][schemaIdForFooter] = JSON.parse(JSON.stringify(appSchema['definitions'][`GenericFooter`]));
        const schemaIdForFooterActions = `FooterActions<${__1.prepareRef(lineItemId)}>`;
        appSchema['definitions'][schemaIdForFooter].properties.actions.$ref =
            __1.DEFINITION_LINK_PREFIX + schemaIdForFooterActions;
        footerActions = appSchema['definitions'][schemaIdForFooterActions] = JSON.parse(JSON.stringify(appSchema['definitions'][`Actions`]));
        footerActions.properties = {};
        footerActions.additionalProperties = false;
    }
    //Determine annotation path
    if (lineItemAnnotation) {
        lineItemPath = __1.createAnnotationPath(entityType.fullyQualifiedName, lineItemAnnotation.term, lineItemAnnotation.qualifier);
        appSchema['definitions'][lineItemId].annotationPath = appSchema['definitions'][schemaIdForToolBar].annotationPath = lineItemPath;
        if (footerActions) {
            appSchema['definitions'][schemaIdForFooter].annotationPath = lineItemPath;
        }
    }
    return { actions, footerActions, lineItemPath };
}
exports.addCommonLineItemDefinitions = addCommonLineItemDefinitions;
/**
 * Add schema definitions for fields of createWithParameterDialog
 * @param {object} appSchema - Application-specific schema, to be enhanced
 * @param {EntityType} entityType - Given entity type for which entries shall get generated
 * @param {string=} floorplanSuffix - floorplan specific suffix (optional)
 */
function addFieldsType(appSchema, entityType, floorplanSuffix = '') {
    const propertyNameArray = [], propertyObject = {};
    const fieldPathRef = `FieldPath${__1.prepareRef(floorplanSuffix)}`;
    for (const key of entityType.entityProperties) {
        const propertyName = key.name;
        propertyNameArray.push(propertyName);
        propertyObject[propertyName] = {
            $ref: __1.DEFINITION_LINK_PREFIX + fieldPathRef
        };
    }
    appSchema['definitions'][entityType.name] = {
        enum: propertyNameArray
    };
    appSchema['definitions'][fieldPathRef].properties.path = {
        $ref: __1.DEFINITION_LINK_PREFIX + entityType.name
    };
    const creationFieldsRef = `CreationFieldKeys${__1.prepareRef(floorplanSuffix)}`;
    appSchema['definitions'][creationFieldsRef] = {
        type: 'object',
        properties: propertyObject,
        additionalProperties: false
    };
    const fields4Dialog = appSchema['definitions'][`Fields4Dialog${floorplanSuffix}`];
    fields4Dialog.properties.fields.$ref = __1.DEFINITION_LINK_PREFIX + creationFieldsRef;
}
exports.addFieldsType = addFieldsType;
var DataType;
(function (DataType) {
    DataType["String"] = "String";
    DataType["Rating"] = "Rating";
    DataType["Progress"] = "Progress";
    DataType["DataPoint"] = "DataPoint";
    DataType["Contact"] = "Contact";
    DataType["Address"] = "Address";
    DataType["Chart"] = "Chart";
    DataType["FieldGroup"] = "FieldGroup";
    DataType["IntentBasedNavigation"] = "IntentBasedNavigation";
})(DataType = exports.DataType || (exports.DataType = {}));
/**
 * Determines the dataType of the target that shall be added to a property in schema
 * @param target - the given target
 * @returns - the dataType as string
 */
function determineDataTypeOfTarget(target) {
    var _a, _b;
    let dataType;
    if (!target) {
        return dataType;
    }
    if (target.Value) {
        if (target.Visualization === 'UI.VisualizationType/Rating') {
            dataType = DataType.Rating;
        }
        else if (target.Visualization === 'UI.VisualizationType/Progress') {
            dataType = DataType.Progress;
        }
        else if (target.$Type === 'com.sap.vocabularies.UI.v1.DataPointType') {
            dataType = DataType.DataPoint;
        }
        else {
            dataType = (_b = (_a = target.Value) === null || _a === void 0 ? void 0 : _a.$target) === null || _b === void 0 ? void 0 : _b.type.replace('Edm.', '');
        }
    }
    else if (target.$Type === 'com.sap.vocabularies.Communication.v1.ContactType') {
        dataType = DataType.Contact;
    }
    else if (target.$Type === 'com.sap.vocabularies.Communication.v1.AddressType') {
        dataType = DataType.Address;
    }
    else if (target.$Type === 'com.sap.vocabularies.UI.v1.ChartDefinitionType') {
        dataType = DataType.Chart;
    }
    else if (target.$Type === 'com.sap.vocabularies.UI.v1.FieldGroupType') {
        dataType = DataType.FieldGroup;
    }
    return dataType;
}
exports.determineDataTypeOfTarget = determineDataTypeOfTarget;
/**
 * Determines the dataType that shall be added to a property in schema, for any kind of field like
 * - field of a field group
 * - line item record
 * - selection field
 * @param field - the given field
 * @returns - the dataType as string
 */
function determineDataType(field) {
    var _a;
    let dataType;
    if (field['Value']) {
        if ((_a = field['Value'].$target) === null || _a === void 0 ? void 0 : _a.type) {
            dataType = field['Value'].$target.type.replace('Edm.', '');
        }
        else {
            dataType = DataType.String;
        }
    }
    else if (field['Target']) {
        dataType = determineDataTypeOfTarget(field['Target'].$target);
    }
    else if (field['$target']) {
        dataType = field['$target'].type.replace('Edm.', '');
    }
    else if (field['$Type'] === 'com.sap.vocabularies.UI.v1.DataFieldForAction') {
        dataType = 'Action';
    }
    else if (field['$Type'] === 'com.sap.vocabularies.UI.v1.DataFieldWithUrl') {
        dataType = 'Url';
    }
    else if (field['$Type'] === 'com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation') {
        dataType = DataType.IntentBasedNavigation;
    }
    else if (field['type']) {
        dataType = field['type'];
    }
    return dataType;
}
exports.determineDataType = determineDataType;
/**
 * Adds the dataType to the given schema field definition, if the data type cane be determined
 * @param definition - given schema definition
 * @param field - given field definition = annotation property, at AVT
 */
function addDataTypeToDefinition(definition, field) {
    const dataType = determineDataType(field);
    if (dataType) {
        definition['dataType'] = dataType;
    }
}
exports.addDataTypeToDefinition = addDataTypeToDefinition;
//# sourceMappingURL=utils.js.map