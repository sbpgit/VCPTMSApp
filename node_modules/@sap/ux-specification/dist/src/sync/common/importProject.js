"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../../specification/common");
const schemaAccess_1 = require("../../specification/schemaAccess");
const pageV2 = __importStar(require("../../specification/v2/webapp/manifest/sapUiPageV2"));
const pageV4 = __importStar(require("../../specification/v4/webapp/manifest/sapUiPageV4"));
const generate_1 = require("../v2/generate");
const appProvider_1 = require("../v2/import/app/appProvider");
const ovpProvider_1 = require("../v2/import/app/ovpProvider");
const generate_2 = require("../v4/generate");
const appProvider_2 = require("../v4/import/app/appProvider");
const types_1 = require("./types");
const utils_1 = require("./utils");
const i18next_1 = __importDefault(require("i18next"));
const extensionLogger_1 = require("../../extensionLogger");
const i18n_1 = require("../../i18n/i18n");
/**
 * Generates an object comprising all generic schemas
 * @param {TemplateType} templateType - Template type
 * @param {FioriElementsVersion} fioriElementsVersion - Fiori Elements version
 * @returns {Object} genericSchemas
 */
async function getGenericSchemas(templateType, fioriElementsVersion) {
    const genericSchemas = {};
    let schemaTypes = [];
    schemaTypes = [common_1.SchemaType.Application];
    switch (templateType) {
        case utils_1.TemplateType.ListReportObjectPageV2:
        case utils_1.TemplateType.ListReportObjectPageV4:
        case utils_1.TemplateType.AnalyticalListPageV4:
            schemaTypes.push(common_1.SchemaType.ListReport, common_1.SchemaType.ObjectPage);
            break;
        case utils_1.TemplateType.AnalyticalListPageV2:
            schemaTypes.push(common_1.SchemaType.AnalyticalListPage, common_1.SchemaType.ObjectPage);
            break;
        case utils_1.TemplateType.OverviewPageV2:
            schemaTypes.push(common_1.SchemaType.OverviewPage);
            break;
        default:
            break;
    }
    for (const schemaType of schemaTypes) {
        const schemaFile = utils_1.getSchemaFilePath(schemaType);
        genericSchemas[schemaFile.filename] = await schemaAccess_1.getGenericSchema(fioriElementsVersion, schemaType);
    }
    return genericSchemas;
}
/**
 * Get the relavant UI.ListItem and UI.Facet entity sets
 * @param allEntityTypes - array of entity types, parsed, merged, and converted by AVT
 */
function getAnnotationsForUi(oDataServiceAVT) {
    const filteredEntityTypes = {
        Facets: [],
        LineItems: []
    };
    const allEntityTypes = oDataServiceAVT === null || oDataServiceAVT === void 0 ? void 0 : oDataServiceAVT.entityTypes;
    if (allEntityTypes) {
        const alias = utils_1.findAlias(types_1.UIVOCABULARY, oDataServiceAVT);
        for (const entity of allEntityTypes) {
            if (!entity.annotations || !entity.annotations[alias]) {
                continue;
            }
            const name = entity.name || entity.fullyQualifiedName.split('.').pop();
            const { LineItem, Facets } = entity.annotations[alias];
            if (LineItem &&
                !LineItem.qualifier &&
                LineItem.find((li) => li.$Type === "com.sap.vocabularies.UI.v1.DataField" /* DataField */ ||
                    li.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */)) {
                filteredEntityTypes.LineItems.push(name);
            }
            if (Facets && !Facets.qualifier) {
                filteredEntityTypes.Facets.push(name);
            }
        }
    }
    return filteredEntityTypes;
}
function getEntitySetByEntitySetName(entitySetName, oDataServiceAVT) {
    return (oDataServiceAVT &&
        oDataServiceAVT.entitySets &&
        oDataServiceAVT.entitySets.find((es) => es.name === entitySetName));
}
exports.getEntitySetByEntitySetName = getEntitySetByEntitySetName;
/**
 * The function generates one app schema per entitySet that is linked with an object page in V2
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {Schema} genericSchemas - The generic schemas
 * @param {Schema} appSchemas - the list of app schemas that shall get extended
 */
function generateObjectPageSchemasV2(generateParameters, genericSchemas, appSchemas) {
    var _a;
    const allPages = appProvider_1.getPages(generateParameters.manifest[common_1.ManifestSection.generic].pages, pageV2.FE_TEMPLATE_V2_OBJECT_PAGE);
    for (const page in allPages) {
        const entitySetName = allPages[page].entitySet;
        const entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT);
        const entityTypeName = (_a = entitySet === null || entitySet === void 0 ? void 0 : entitySet.entityType) === null || _a === void 0 ? void 0 : _a.name;
        const schemaFile = utils_1.getSchemaFilePath(common_1.SchemaType.ObjectPage, (entitySet === null || entitySet === void 0 ? void 0 : entitySet.name) || entitySetName);
        const genericSchemaFile = utils_1.getSchemaFilePath(common_1.SchemaType.ObjectPage);
        appSchemas[schemaFile.filename] = generate_1.generateObjectPageSchemaV2(generateParameters, genericSchemas[genericSchemaFile.filename], entityTypeName);
    }
}
/**
 * The function generates one app schema per entitySet that is linked with an object page in V4
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {Schemas} appSchemas - the list of app schemas that shall get extended
 */
function generateObjectPageSchemasV4(generateParameters, genericSchemas, appSchemas) {
    var _a;
    const pages = appProvider_2.getPages(generateParameters.manifest, pageV4.FE_TEMPLATE_V4_OBJECT_PAGE);
    for (const page in pages) {
        const entitySetName = pages[page].options.settings.entitySet;
        const entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT);
        if (!entitySet) {
            extensionLogger_1.log(generateParameters.logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('ENTITYSETNOTFOUND', { entitySet: entitySetName }),
                location: {
                    path: types_1.METADATAPATH
                }
            });
        }
        const entityTypeName = (_a = entitySet === null || entitySet === void 0 ? void 0 : entitySet.entityType) === null || _a === void 0 ? void 0 : _a.name;
        const schemaFile = utils_1.getSchemaFilePath(common_1.SchemaType.ObjectPage, (entitySet === null || entitySet === void 0 ? void 0 : entitySet.name) || entitySetName);
        const genericSchemaFile = utils_1.getSchemaFilePath(common_1.SchemaType.ObjectPage);
        appSchemas[schemaFile.filename] = generate_2.generateObjectPageSchemaV4(generateParameters, genericSchemas[genericSchemaFile.filename], entityTypeName);
    }
}
/**
 * Generates all app specific schemas for a Fiori Elements V2 application
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {UiEntityTypes} uiEntityTypes - list of all entity types, as comprised in oDataServiceAVT
 * @param {TemplateType} templateType - the given Fiori Elements' template type
 */
function generateAppSchemasV2(generateParameters, genericSchemas, uiEntityTypes, templateType) {
    var _a, _b;
    const appSchemas = {};
    if (templateType === utils_1.TemplateType.ListReportObjectPageV2 && uiEntityTypes) {
        /*--- List Report ----*/
        const allPages = appProvider_1.getPages(generateParameters.manifest[common_1.ManifestSection.generic].pages, pageV2.FE_TEMPLATE_V2_LIST_REPORT);
        for (const page in allPages) {
            const entitySetName = allPages[page].entitySet;
            const entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT);
            const entityTypeName = (_a = entitySet === null || entitySet === void 0 ? void 0 : entitySet.entityType) === null || _a === void 0 ? void 0 : _a.name;
            const schemaFile = utils_1.getSchemaFilePath(common_1.SchemaType.ListReport, (entitySet === null || entitySet === void 0 ? void 0 : entitySet.name) || entitySetName);
            const genericSchemaFile = utils_1.getSchemaFilePath(common_1.SchemaType.ListReport);
            appSchemas[schemaFile.filename] = generate_1.generateListReportSchemaV2(generateParameters, genericSchemas[genericSchemaFile.filename], entityTypeName);
        }
        /*--- Object Pages ----*/
        generateObjectPageSchemasV2(generateParameters, genericSchemas, appSchemas);
    }
    else if (templateType === utils_1.TemplateType.AnalyticalListPageV2 && uiEntityTypes) {
        /*--- Analytical List Page ----*/
        const allPages = appProvider_1.getPages(generateParameters.manifest[common_1.ManifestSection.generic].pages, pageV2.FE_TEMPLATE_V2_ALP);
        for (const page in allPages) {
            const entitySetName = allPages[page].entitySet;
            const entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT);
            const entityTypeName = (_b = entitySet === null || entitySet === void 0 ? void 0 : entitySet.entityType) === null || _b === void 0 ? void 0 : _b.name;
            const schemaFile = utils_1.getSchemaFilePath(common_1.SchemaType.AnalyticalListPage, (entitySet === null || entitySet === void 0 ? void 0 : entitySet.name) || entitySetName);
            const genericSchemaFile = utils_1.getSchemaFilePath(common_1.SchemaType.AnalyticalListPage);
            appSchemas[schemaFile.filename] = generate_1.generateAnalyticalListReportSchemaV2(generateParameters, genericSchemas[genericSchemaFile.filename], entityTypeName);
        }
        /*--- Object Pages ----*/
        generateObjectPageSchemasV2(generateParameters, genericSchemas, appSchemas);
    }
    else if (templateType === utils_1.TemplateType.OverviewPageV2) {
        /*--- Overview Page ----*/
        const schemaFile = utils_1.getSchemaFilePath(common_1.SchemaType.OverviewPage);
        const genericSchemaFile = utils_1.getSchemaFilePath(common_1.SchemaType.OverviewPage);
        appSchemas[schemaFile.filename] = generate_1.generateOVPInterfaceV2(genericSchemas[genericSchemaFile.filename], generateParameters.manifest);
    }
    return Object.assign(Object.assign({}, genericSchemas), appSchemas);
}
/**
 * Generates all app specific schemas for a Fiori Elements V4 application
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {UiEntityTypes} uiEntityTypes - list of all entity types, as comprised in oDataServiceAVT
 * @param {TemplateType} templateType - the given Fiori Elements' template type
 */
function generateAppSchemasV4(generateParameters, genericSchemas, uiEntityTypes, templateType) {
    const appSchemas = {};
    if (uiEntityTypes) {
        if (templateType === utils_1.TemplateType.ListReportObjectPageV4 ||
            templateType === utils_1.TemplateType.AnalyticalListPageV4) {
            /*--- List Report ----*/
            const lrPages = appProvider_2.getPages(generateParameters.manifest, pageV4.FE_TEMPLATE_V4_LIST_REPORT);
            const alpPages = appProvider_2.getPages(generateParameters.manifest, pageV4.FE_TEMPLATE_V4_ALP);
            const pages = Object.assign(Object.assign({}, lrPages), alpPages);
            for (const pageId in pages) {
                const entitySetName = pages[pageId].options.settings.entitySet;
                const entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT);
                const schemaFile = utils_1.getSchemaFilePath(common_1.SchemaType.ListReport, (entitySet === null || entitySet === void 0 ? void 0 : entitySet.name) || entitySetName);
                const genericSchemaFile = utils_1.getSchemaFilePath(common_1.SchemaType.ListReport);
                appSchemas[schemaFile.filename] = generate_2.generateListReportSchemaV4(generateParameters, genericSchemas[genericSchemaFile.filename], entitySet, pages[pageId].name);
            }
            /*--- Object Pages ----*/
            generateObjectPageSchemasV4(generateParameters, genericSchemas, appSchemas);
        }
    }
    return Object.assign(Object.assign({}, genericSchemas), appSchemas);
}
/**
 * Generates app specific schemas by adding annotation information to copies of the generic schemas, thus replacing all generic definitions.
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {UiEntityTypes} uiEntityTypes - list of all entity types from the service metadata
 * @param templateType - type of the Fiori Elements' template
 */
async function generateAppSchemas(generateParameters, uiEntityTypes, templateType) {
    const genericSchemas = await getGenericSchemas(templateType, generateParameters.fioriElementsVersion);
    if (generateParameters.fioriElementsVersion === common_1.FioriElementsVersion.v4) {
        return generateAppSchemasV4(generateParameters, genericSchemas, uiEntityTypes, templateType);
    }
    else {
        return generateAppSchemasV2(generateParameters, genericSchemas, uiEntityTypes, templateType);
    }
}
/**
 * Imports manifest and flex changes into configuration files with aid of the relevant app provider
 * @param {Manifest} manifest - manifest.json file content of the app in JSON format
 * @param {string[]} flex - list of all UI flexibility changes
 * @param {Schemas} appSchemas - list of app-specific schemas
 * @param {TemplateType} templateType - type of the Fiori Elements' template
 * @returns {File[]} a list of all configuration files as generated by the function
 */
function importConfigs(manifest, flex, appSchemas, templateType, fragments) {
    let provider;
    const files = [];
    switch (templateType) {
        case utils_1.TemplateType.ListReportObjectPageV2:
        case utils_1.TemplateType.AnalyticalListPageV2:
            provider = new appProvider_1.V2AppProvider(manifest, flex, appSchemas, fragments);
            break;
        case utils_1.TemplateType.AnalyticalListPageV4:
        case utils_1.TemplateType.ListReportObjectPageV4:
            provider = new appProvider_2.V4AppProvider(manifest, appSchemas, templateType);
            break;
        case utils_1.TemplateType.OverviewPageV2:
            provider = new ovpProvider_1.V2OvpProvider(manifest, appSchemas);
            break;
        default:
            break;
    }
    if (provider) {
        const { appConfig, pageConfigs } = provider.createConfigFiles();
        for (const app in appConfig) {
            files.push({ dataSourceUri: app, fileContent: JSON.stringify(appConfig[app], null, 4) });
        }
        for (const config in pageConfigs) {
            files.push({ dataSourceUri: config, fileContent: JSON.stringify(pageConfigs[config], null, 4) });
        }
    }
    return files;
}
function getFileList(schema, configs) {
    let files = [];
    for (const schemaName of Object.keys(schema).sort()) {
        let dataSourceUri;
        if (schemaName === common_1.SchemaType.Application) {
            dataSourceUri = `${types_1.DirName.Schemas}/${types_1.FileName.App[0].toUpperCase()}${types_1.FileName.App.slice(1)}`;
        }
        else {
            dataSourceUri = `${types_1.DirName.Schemas}/${schemaName}.json`;
        }
        files.push({ dataSourceUri, fileContent: JSON.stringify(schema[schemaName], null, 4) });
    }
    if (configs) {
        files = files.concat(configs);
    }
    return files;
}
/**
 * Import the schema and config files for a given project
 * @param {ImportProjectParameters} importParameters - files of the project: manifest, flex changes, odata files
 */
async function importProjectSchema(importProjectParameters) {
    // Initialize i18next
    i18n_1.initI18n();
    const fioriElementsVersion = utils_1.getVersionFromManifest(importProjectParameters.manifest);
    const service = utils_1.parseAndMergeAndConvert(importProjectParameters.annotations, importProjectParameters.logger);
    const uiEntityTypes = getAnnotationsForUi(service);
    const templateType = utils_1.getTemplateTypeFromManifest(importProjectParameters.manifest, fioriElementsVersion, importProjectParameters.logger);
    const generateParameters = {
        templateType,
        manifest: importProjectParameters.manifest,
        serviceAVT: service,
        fragments: importProjectParameters.fragments,
        fioriElementsVersion,
        logger: importProjectParameters.logger
    };
    const appSchemas = await generateAppSchemas(generateParameters, uiEntityTypes, templateType);
    return getFileList(appSchemas);
}
exports.importProjectSchema = importProjectSchema;
/**
 * Import the schema and config files for a given project
 * @param {ImportProjectParameters} importParameters - files of the project: manifest, flex changes, odata files
 */
async function importProjectSchemaAndConfig(importProjectParameters) {
    // Initialize i18next
    i18n_1.initI18n();
    let configFiles = [];
    const { manifest, annotations, flex, fragments, logger } = importProjectParameters;
    const fioriElementsVersion = utils_1.getVersionFromManifest(manifest);
    const oDataServiceAVT = utils_1.parseAndMergeAndConvert(annotations, logger);
    const templateType = utils_1.getTemplateTypeFromManifest(manifest, fioriElementsVersion, logger);
    const generateParameters = {
        templateType,
        manifest: importProjectParameters.manifest,
        serviceAVT: oDataServiceAVT,
        fragments: importProjectParameters.fragments,
        fioriElementsVersion,
        logger: importProjectParameters.logger
    };
    const uiEntityTypes = getAnnotationsForUi(oDataServiceAVT);
    const appSchemas = await generateAppSchemas(generateParameters, uiEntityTypes, templateType);
    configFiles = importConfigs(manifest, flex, appSchemas, templateType, fragments);
    return getFileList(appSchemas, configFiles);
}
exports.importProjectSchemaAndConfig = importProjectSchemaAndConfig;
//# sourceMappingURL=importProject.js.map