"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const annotation_converter_1 = require("@sap-ux/annotation-converter");
const edmx_parser_1 = require("@sap-ux/edmx-parser");
const common_1 = require("../../specification/common");
const schemaAccess_1 = require("../../specification/schemaAccess");
const i18next_1 = __importDefault(require("i18next"));
const v2_1 = require("../../specification/v2");
const v4_1 = require("../../specification/v4");
const extensionLogger_1 = require("../../extensionLogger");
const deepmerge_1 = __importDefault(require("deepmerge"));
var TemplateType;
(function (TemplateType) {
    TemplateType["ListReportObjectPageV2"] = "ListReportObjectPageV2";
    TemplateType["ListReportObjectPageV4"] = "ListReportObjectPageV4";
    TemplateType["OverviewPageV2"] = "OverviewPageV2";
    TemplateType["AnalyticalListPageV2"] = "AnalyticalListPageV2";
    TemplateType["AnalyticalListPageV4"] = "AnalyticalListPageV4";
})(TemplateType = exports.TemplateType || (exports.TemplateType = {}));
exports.DEFINITION_LINK_PREFIX = '#/definitions/';
/**
 * Function returns annotation path for schema based on received params.
 * @param entityTypeName - Entity type name.
 * @param term - Annotation term.
 * @param qualifier - Annotation qualifier.
 * @returns Annotation path based on received params
 */
exports.createAnnotationPath = (entityTypeName, term, qualifier) => {
    let annotationPath = `/${entityTypeName}/@${term}`;
    if (qualifier) {
        annotationPath += `#${qualifier}`;
    }
    return annotationPath;
};
/**
 * Parses, merges, and converts a list of annotation files with aid of tools from annotation-vocabularies-tools
 * @param annotationFiles - The list of all annotation files, in JSON format
 * @returns the complete service information
 */
function parseAndMergeAndConvert(annotationFiles, logger) {
    const parseResult = [];
    let converterOutput;
    try {
        if (annotationFiles) {
            annotationFiles.forEach(function (annotationData) {
                parseResult.push(edmx_parser_1.parseEDMX(annotationData.fileContent, annotationData.dataSourceUri));
            });
        }
        if (parseResult.length > 0) {
            converterOutput = annotation_converter_1.convertTypes(edmx_parser_1.merge(parseResult));
        }
        if (logger && (converterOutput === null || converterOutput === void 0 ? void 0 : converterOutput.diagnostics)) {
            for (const converterMessage of converterOutput.diagnostics) {
                extensionLogger_1.log(logger, {
                    severity: "error" /* Error */,
                    message: converterMessage.message
                });
            }
        }
        return converterOutput;
    }
    catch (error) {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('ANNOERR')
        }, ...error);
    }
}
exports.parseAndMergeAndConvert = parseAndMergeAndConvert;
exports.getAnnotationPropertyValue = (annotationProperty) => (annotationProperty === null || annotationProperty === void 0 ? void 0 : annotationProperty.value) || (annotationProperty === null || annotationProperty === void 0 ? void 0 : annotationProperty.path);
/**
 * Checks for Common.Label and overwrites the label from it if present
 * @param {PropertyAnnotations} annotations - property annotations
 * @param {EntityType} entityType - entity type
 * @param {string} label - label, to be actualized
 */
function evaluateCommonLabel(annotations, entityType, label) {
    var _a, _b, _c, _d;
    if ((_a = annotations === null || annotations === void 0 ? void 0 : annotations.Common) === null || _a === void 0 ? void 0 : _a.Label) {
        if (typeof annotations.Common.Label === 'string') {
            label = annotations.Common.Label;
        }
        else if (annotations.Common.Label['type'] === 'Path') {
            const targetProperty = entityType.resolvePath(annotations.Common.Label['path']);
            if (targetProperty.value) {
                label = targetProperty.value;
            }
            else if (typeof ((_b = targetProperty.Common) === null || _b === void 0 ? void 0 : _b.Label) === 'string') {
                label = targetProperty.annotations.Common.Label;
            }
        }
        else if (typeof ((_d = (_c = annotations.Common) === null || _c === void 0 ? void 0 : _c.Label) === null || _d === void 0 ? void 0 : _d.toString()) === 'string') {
            label = annotations.Common.Label.toString();
        }
    }
    return label;
}
exports.evaluateCommonLabel = evaluateCommonLabel;
/**
 * Determines the label for a property path
 * @param {PropertyPath} propertyPath - property path
 * @param {EntityType} entityType - entity type
 * @returns label, derived from Common.Label or from property value
 */
function getLabelForPropertyPath(propertyPath, entityType) {
    let label = propertyPath.value;
    if (propertyPath.$target) {
        label = evaluateCommonLabel(propertyPath.$target.annotations, entityType, label);
    }
    return label;
}
exports.getLabelForPropertyPath = getLabelForPropertyPath;
/**
 * Determines the label for a LineItem record
 * @param {DataFieldAbstractType} field - Line item record
 * @param {EntityType} entityType - entity type
 * @returns label, derived from Common.Label or from property value
 */
function getLabelForDataField(field, entityType) {
    var _a, _b;
    let label, property;
    if (field['Value']) {
        if (typeof field['Value'] === 'string') {
            property = entityType.entityProperties.find((ep) => ep.name === field['Value']);
        }
        else {
            property = entityType.resolvePath(field['Value'].path);
            if (!property) {
                property = field['Value'].$target;
            }
        }
    }
    else if (field['Target'] && field['Target'].$target && field['Target'].$target.Value) {
        property = field['Target'].$target.Value.$target;
    }
    if ((_b = (_a = property === null || property === void 0 ? void 0 : property.annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.Label) {
        label = evaluateCommonLabel(property.annotations, entityType, label);
    }
    return label;
}
exports.getLabelForDataField = getLabelForDataField;
/**
 * Function to resolve the dataField label
 * @param dataFieldLabel - Given dataField label; might be of type string, or an object in case of a path reference
 * @param entityType - the entity type as part of the AVT ConverterOutput
 * @returns undefined or the right string value
 */
function getLabel(dataFieldLabel, entityType) {
    var _a, _b;
    if (typeof dataFieldLabel === 'string') {
        return dataFieldLabel;
    }
    else if (typeof dataFieldLabel === 'object' && dataFieldLabel.path) {
        const property = entityType.resolvePath(dataFieldLabel.path);
        if (!property || property.length === 0) {
            return undefined;
        }
        else {
            const singleProperty = property[0];
            if ((_b = (_a = singleProperty === null || singleProperty === void 0 ? void 0 : singleProperty.annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.Label) {
                const label = dataFieldLabel;
                return evaluateCommonLabel(singleProperty.annotations, entityType, label);
            }
        }
    }
    else {
        return undefined;
    }
}
function getTitleForDataField(dataField, entityType, dataFieldLabel) {
    const propertyCommonLabel = getLabelForDataField(dataField, entityType);
    return (dataFieldLabel ||
        propertyCommonLabel ||
        (dataField.Value.$target ? dataField.Value.$target.name : dataField.Value.value || dataField.Value.path));
}
/**
 * Determines the description of a data field, e.g. for the column header
 * @param dataFieldAbstract - the given record of the line item annotation
 * @param entityType - the entity type as part of the AVT ConverterOutput
 */
function getDatafieldDescription(dataFieldAbstract, entityType) {
    let title = '', propertyCommonLabel, dataField;
    const dataFieldLabel = getLabel(dataFieldAbstract.Label, entityType);
    switch (dataFieldAbstract.$Type) {
        case "com.sap.vocabularies.UI.v1.DataField" /* DataField */:
            dataField = dataFieldAbstract;
            title = getTitleForDataField(dataField, entityType, dataFieldLabel);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithUrl" /* DataFieldWithUrl */:
            dataField = dataFieldAbstract;
            propertyCommonLabel = getLabelForDataField(dataFieldAbstract, entityType);
            title =
                dataFieldLabel ||
                    propertyCommonLabel ||
                    (typeof dataField.Value === 'string' ? dataField.Value : dataField.Value.path);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */:
            dataField = dataFieldAbstract;
            propertyCommonLabel = getLabelForDataField(dataFieldAbstract, entityType);
            title = dataFieldLabel || propertyCommonLabel || dataField.Target.$target.Title || dataField.Target.value;
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */:
        case "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */:
            dataField = dataFieldAbstract;
            if (dataFieldLabel) {
                title = typeof dataFieldLabel === 'string' ? dataFieldLabel : dataField.Action;
            }
            else {
                title = dataFieldAbstract.Action;
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation" /* DataFieldWithIntentBasedNavigation */:
            dataField = dataFieldAbstract;
            propertyCommonLabel = getLabelForDataField(dataFieldAbstract, entityType);
            title = propertyCommonLabel || dataField.Value.path;
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath" /* DataFieldWithNavigationPath */:
            dataField = dataFieldAbstract;
            title = getTitleForDataField(dataField, entityType, dataFieldLabel);
            break;
        default:
            break;
    }
    return title;
}
exports.getDatafieldDescription = getDatafieldDescription;
/**
 * Return the page type for a given V2 page in manifest
 * @param name - page component name
 */
function getPageTypeV2(name) {
    if (name) {
        const templatePart = `${v2_1.FE_TEMPLATE_V2}.`;
        return name.split(templatePart)[1];
    }
}
exports.getPageTypeV2 = getPageTypeV2;
/**
 * Return the page type for a given V4 page in manifest
 * @param name - page component name
 */
function getPageTypeV4(name) {
    if (name) {
        const templatePart = `${v4_1.FE_TEMPLATE_V4}.`;
        return name.split(templatePart)[1];
    }
}
exports.getPageTypeV4 = getPageTypeV4;
function getTargetAnnotationName(targetAnnotation, keyForRelatedFacetKeys = false) {
    return `${!keyForRelatedFacetKeys ? '@' : ''}${targetAnnotation.qualifier ? targetAnnotation.term + '#' + targetAnnotation.qualifier : targetAnnotation.term}`;
}
/**
 * Finds the alias for a given namespace in the references' section of the converted service metadata
 * @param {string} namespace - complete namespace, e.g. 'com.sap.vocabularies.UI.v1'
 * @param {ConverterOutput} oDataServiceAVT - combined service metadata, as returned by annotation vocabularies tools
 * @returns alias for the given namespace
 */
function findAlias(namespace, oDataServiceAVT) {
    let aliasReference = oDataServiceAVT.references.find((reference) => {
        return reference.namespace === namespace;
    });
    if (!aliasReference) {
        aliasReference = oDataServiceAVT.references.find((reference) => {
            return reference.alias === namespace;
        });
    }
    if (!aliasReference) {
        aliasReference = oDataServiceAVT.references.find((reference) => {
            return (reference.alias.toUpperCase() ===
                namespace.split('SAP__')[namespace.split('SAP__').length - 1].toUpperCase());
        });
    }
    return aliasReference === null || aliasReference === void 0 ? void 0 : aliasReference.alias;
}
exports.findAlias = findAlias;
/**
 * Determines the target annotation
 * @param navigationParts - parts of the target annotation path
 * @param entityType - entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @returns the target annotation
 */
function determineTargetAnnotation(navigationParts, entityType, oDataServiceAVT) {
    var _a;
    const lastNavigationPart = navigationParts[navigationParts.length - 1];
    const annotation = lastNavigationPart.substring(lastNavigationPart.lastIndexOf('.') + 1, lastNavigationPart.length);
    const alias = findAlias(lastNavigationPart.substring(0, lastNavigationPart.lastIndexOf('.')).replace('@', ''), oDataServiceAVT);
    return (_a = entityType === null || entityType === void 0 ? void 0 : entityType.annotations[alias]) === null || _a === void 0 ? void 0 : _a[annotation];
}
/**
 * Adjust key by considering navigation
 * @param key - given key
 * @param keyForRelatedFacetKeys - construct key for 'keyForRelatedFacetKeys' property(used to define custom sections) - we should not add '@' symbol there.
 * @param navigationParts - parts of the target annotation path
 */
function adjustKey(key, navigationParts, keyForRelatedFacetKeys) {
    const uiParts = (navigationParts[1] || navigationParts[0]).split('#');
    const uiClass = uiParts[0];
    if (uiClass.includes('.LineItem')) {
        const pathParts = key.split('::');
        pathParts[pathParts.length - 1] = `${!keyForRelatedFacetKeys ? '@' : ''}${"com.sap.vocabularies.UI.v1.LineItem" /* LineItem */}`;
        key = pathParts.join('::');
    }
    else {
        key = uiClass.replace('@UI', `${!keyForRelatedFacetKeys ? '@' : ''}com.sap.vocabularies.UI.v1`);
    }
}
/**
 * Resolve page section(get key and label->description).
 * @param facetDefinition - the actual annotation record
 * @param keyForRelatedFacetKeys - construct key for 'keyForRelatedFacetKeys' property(used to define custom sections) - we should not add '@' symbol there.
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {FacetSection} - object comprising the relevant facet information
 */
function getSectionFacet(facetDefinition, sourceEntityType, oDataServiceAVT, logger, oDataVersion = common_1.FioriElementsVersion.v2, keyForRelatedFacetKeys = false) {
    var _a;
    //Take facet ID as fallback
    const facetName = facetDefinition.fullyQualifiedName.substr(facetDefinition.fullyQualifiedName.lastIndexOf('@'));
    let key = facetDefinition.ID ? facetDefinition.ID.toString() : facetName;
    let entityType = sourceEntityType; //default
    //If reference facet: overwrite with target annotation if present
    if (facetDefinition.$Type !== "com.sap.vocabularies.UI.v1.CollectionFacet" /* CollectionFacet */ && 'Target' in facetDefinition) {
        const propertyValue = exports.getAnnotationPropertyValue(facetDefinition.Target);
        if (!propertyValue) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOTARGET', { target: facetDefinition.Target })
            });
            return;
        }
        const navigationParts = propertyValue.split('/');
        const navigation = navigationParts.length > 1 ? navigationParts[0] : '';
        if (navigation) {
            entityType = (_a = sourceEntityType.resolvePath(navigation)) === null || _a === void 0 ? void 0 : _a.targetType;
        }
        adjustKey(key, navigationParts, keyForRelatedFacetKeys);
        const targetAnnotation = determineTargetAnnotation(navigationParts, entityType, oDataServiceAVT);
        if (targetAnnotation) {
            const separator = oDataVersion === common_1.FioriElementsVersion.v2 ? '::' : '#';
            key = getTargetAnnotationName(targetAnnotation, keyForRelatedFacetKeys).replace('#', separator);
        }
        else {
            return undefined;
        }
        if (navigation) {
            const navSeparator = oDataVersion === common_1.FioriElementsVersion.v2 ? '::' : '/';
            key = `${navigation}${navSeparator}${key}`;
        }
    }
    key = key.replace(/\//gi, '::');
    return key
        ? Object.assign(Object.assign(Object.assign({ key }, (facetDefinition.Label && { label: facetDefinition.Label.toString() })), (facetDefinition.ID && { ID: facetDefinition.ID.toString() })), { entityType }) : undefined;
}
exports.getSectionFacet = getSectionFacet;
/**
 * Finds the alias for a given namespace in the references' section of the converted service metadata.
 * An empty object is created if the path element does not exist yet.
 * Exception: if an empty array is the next element  of the 'path' definition, an empty array is created instaed of an empty object.
 * @param {object} manifest - manifest that is being modified during export
 * @param {string} path - path of the property in the manifest
 * @param {string} targetAnnotation - target annotation (optional)
 * @param {string} targetAnnotationEncoded - target annotation in its encoded form, as used in manifest settings
 * @param {boolean} importScenario - indicates if the function is called for the import, else it is the export
 * @returns returns section of the manifest based on path, generates an empty object in case it does not exists
 */
exports.getManifestSectionByPathV4 = (manifest, path, targetAnnotation, targetAnnotationEncoded, importScenario = false) => {
    let manifestSection = manifest;
    const pathElements = path.split('/');
    for (let index = 0; index < pathElements.length; index++) {
        const element = pathElements[index];
        if (element === '[]') {
            continue;
        }
        const decodedElement = targetAnnotationEncoded && targetAnnotationEncoded === element
            ? targetAnnotation
            : element.replace('??', '/');
        //?? can be used in path functions to encoode /
        if (!manifestSection[decodedElement]) {
            if (importScenario) {
                manifestSection = undefined;
                break;
            }
            if (pathElements[index + 1] === '[]') {
                manifestSection[decodedElement] = [];
            }
            else {
                manifestSection[decodedElement] = {};
            }
        }
        manifestSection = manifestSection[decodedElement];
    }
    return manifestSection;
};
function getSchemaKeyOfLineItemRecord(lineItemRecord) {
    let schemaKey, target, value;
    switch (lineItemRecord.$Type) {
        case "com.sap.vocabularies.UI.v1.DataField" /* DataField */:
            schemaKey = exports.getAnnotationPropertyValue(lineItemRecord.Value);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithUrl" /* DataFieldWithUrl */:
            schemaKey =
                typeof lineItemRecord.Value === 'string'
                    ? lineItemRecord.Value
                    : exports.getAnnotationPropertyValue(lineItemRecord.Value);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */:
            target = lineItemRecord.Target.value;
            if (target) {
                schemaKey =
                    'DataFieldForAnnotation:::sTarget::' +
                        target
                            .replace('@UI', '@com.sap.vocabularies.UI.v1')
                            .replace('@Communication', '@com.sap.vocabularies.Communication.v1')
                            .replace('@Contact', '@com.sap.vocabularies.Contact.v1');
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */:
            if (lineItemRecord.Inline) {
                schemaKey = `DataFieldForAction:::sAction::${prepareRef(lineItemRecord.Action)}`;
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation" /* DataFieldWithIntentBasedNavigation */:
            value = exports.getAnnotationPropertyValue(lineItemRecord.Value);
            schemaKey =
                'DataFieldWithIntentBasedNavigation:::sProperty::' +
                    value +
                    ':::sSemanticObject::' +
                    lineItemRecord.SemanticObject +
                    ':::sAction::' +
                    lineItemRecord.Action;
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */:
            if (lineItemRecord.Inline) {
                schemaKey = `DataFieldForIntentBasedNavigation:::sSemanticObject::${lineItemRecord.SemanticObject}:::sAction::${prepareRef(lineItemRecord.Action)}`;
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath" /* DataFieldWithNavigationPath */:
            value = exports.getAnnotationPropertyValue(lineItemRecord.Value);
            target = exports.getAnnotationPropertyValue(lineItemRecord.Target);
            schemaKey = 'DataFieldWithNavigationPath:::sProperty::' + value + ':::sTarget::' + target;
            break;
        default:
            break;
    }
    return schemaKey;
}
exports.getSchemaKeyOfLineItemRecord = getSchemaKeyOfLineItemRecord;
/**
 * Determines if type of given annotation term is of UIAnnotationTerm
 * @param {string} path path in manifest
 * @param {string} alias for a given namespace
 * @param {EntityType} entityType - the entity type
 * @returns UI annotation term type
 */
function getUIAnnotationTerm(path, alias, entityType) {
    if (path.includes("com.sap.vocabularies.UI.v1.Chart" /* Chart */) || path.includes(alias + '.Chart')) {
        return "com.sap.vocabularies.UI.v1.Chart" /* Chart */;
    }
    else if (path.includes("com.sap.vocabularies.UI.v1.Identification" /* Identification */) || path.includes(alias + '.Identification')) {
        return "com.sap.vocabularies.UI.v1.Identification" /* Identification */;
    }
    else if ((entityType && path.includes("com.sap.vocabularies.UI.v1.LineItem" /* LineItem */)) || path.includes(alias + '.LineItem')) {
        return "com.sap.vocabularies.UI.v1.LineItem" /* LineItem */;
    }
    else if (path.includes("com.sap.vocabularies.UI.v1.FieldGroup" /* FieldGroup */) || path.includes(alias + '.FieldGroup')) {
        return "com.sap.vocabularies.UI.v1.FieldGroup" /* FieldGroup */;
    }
    else if (path.includes("com.sap.vocabularies.UI.v1.DataPoint" /* DataPoint */) || path.includes(alias + '.DataPoint')) {
        return "com.sap.vocabularies.UI.v1.DataPoint" /* DataPoint */;
    }
    else {
        return undefined;
    }
}
/**
 * Determines if type of given annotation term is of CommunicationAnnotationTerm
 * @param {string} path path in manifest
 * @param {string} alias for a given namespace
 * @param {EntityType} entityType - the entity type
 * @returns Communication annotation term type
 */
function getCommunicationAnnotationTerm(path, alias) {
    if (path.includes('com.sap.vocabularies.Communication.v1.Contact') || path.includes(alias + '.Contact')) {
        return "com.sap.vocabularies.Communication.v1.Contact" /* Contact */;
    }
    else if (path.includes('com.sap.vocabularies.Communication.v1.Address') || path.includes(alias + '.Address')) {
        return "com.sap.vocabularies.Communication.v1.Address" /* Address */;
    }
    else {
        return undefined;
    }
}
/**
 * Determines the type of given annotation term
 * @param {string} path path in manifest
 * @param {string} alias for a given namespace
 * @param {EntityType} entityType - the entity type
 * @returns annotation term type
 */
function getAnnotationTerm(path, alias, entityType) {
    return getUIAnnotationTerm(path, alias, entityType) || getCommunicationAnnotationTerm(path, alias);
}
/**
 * Evaluates the target annotation of a reference facet and actualizes the facets for the config
 * @param {AnnotationTerm} annotationRecord - the actual annotation record
 * @param {FacetConfigs} facets - list of facets in config format, to be updated
 * @param {EntityType} entityType - the entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function evaluateTargetAnnotation(section, annotationRecord, facets, entityType, oDataServiceAVT, oDataVersion = common_1.FioriElementsVersion.v2, logger) {
    var _a, _b, _c, _d, _e, _f, _g;
    const alias = findAlias(types_1.UIVOCABULARY, oDataServiceAVT);
    let path = section ? section.key : '';
    const targetEntityType = section.entityType;
    const annotationTerm = getAnnotationTerm(path, alias, entityType);
    let annotation, targetAnnotation;
    switch (annotationTerm) {
        case "com.sap.vocabularies.UI.v1.Chart" /* Chart */: {
            facets[path] = { base: types_1.FacetBase.Chart };
            facets[path].target = (_a = annotationRecord === null || annotationRecord === void 0 ? void 0 : annotationRecord.Target) === null || _a === void 0 ? void 0 : _a.$target;
            facets[path].entityType = targetEntityType;
            break;
        }
        case "com.sap.vocabularies.UI.v1.Identification" /* Identification */: {
            annotation = path.split('.')[path.split('.').length - 1];
            targetAnnotation = targetEntityType.annotations[alias][annotation];
            facets[path] = { base: types_1.FacetBase.Identification };
            facets[path].entityType = targetEntityType;
            facets[path].target = targetAnnotation;
            break;
        }
        case "com.sap.vocabularies.UI.v1.LineItem" /* LineItem */: {
            if (!path.includes("com.sap.vocabularies.UI.v1.LineItem" /* LineItem */) && path.includes('.LineItem')) {
                const pathParts = path.split('::');
                pathParts[pathParts.length - 1] = `@${"com.sap.vocabularies.UI.v1.LineItem" /* LineItem */}`;
                path = pathParts.join('::');
            }
            facets[path] = { base: types_1.FacetBase.LineItem };
            facets[path].target = (_b = annotationRecord === null || annotationRecord === void 0 ? void 0 : annotationRecord.Target) === null || _b === void 0 ? void 0 : _b.$target;
            facets[path].entityType = targetEntityType;
            break;
        }
        case "com.sap.vocabularies.UI.v1.FieldGroup" /* FieldGroup */: {
            facets[path] = { base: types_1.FacetBase.Form };
            facets[path].target = (_c = annotationRecord === null || annotationRecord === void 0 ? void 0 : annotationRecord.Target) === null || _c === void 0 ? void 0 : _c.$target;
            facets[path].entityType = targetEntityType;
            break;
        }
        case "com.sap.vocabularies.UI.v1.DataPoint" /* DataPoint */: {
            facets[path] = { base: types_1.FacetBase.DataPoint };
            facets[path].target = (_d = annotationRecord === null || annotationRecord === void 0 ? void 0 : annotationRecord.Target) === null || _d === void 0 ? void 0 : _d.$target;
            facets[path].entityType = targetEntityType;
            facets[path].Label = (_e = annotationRecord === null || annotationRecord === void 0 ? void 0 : annotationRecord.Target) === null || _e === void 0 ? void 0 : _e.$target['Title'];
            break;
        }
        case "com.sap.vocabularies.Communication.v1.Contact" /* Contact */: {
            facets[path] = { base: types_1.FacetBase.Contact };
            facets[path].target = (_f = annotationRecord === null || annotationRecord === void 0 ? void 0 : annotationRecord.Target) === null || _f === void 0 ? void 0 : _f.$target;
            facets[path].entityType = targetEntityType;
            break;
        }
        case "com.sap.vocabularies.Communication.v1.Address" /* Address */: {
            facets[path] = { base: types_1.FacetBase.Address };
            facets[path].target = (_g = annotationRecord === null || annotationRecord === void 0 ? void 0 : annotationRecord.Target) === null || _g === void 0 ? void 0 : _g.$target;
            facets[path].entityType = targetEntityType;
            break;
        }
        default: {
            facets[path] = { base: types_1.FacetBase.Unknown };
        }
    }
    if (facets[path]) {
        facets[path].annotationPath = `/${annotationRecord.fullyQualifiedName.replace('@com.sap.vocabularies', types_1.VOCWITHSLASH)}`;
        if (annotationRecord.Label) {
            facets[path].Label = annotationRecord.Label;
        }
        // Add Facet ID
        if (annotationRecord.ID) {
            facets[path]['ID'] = annotationRecord.ID;
        }
        else if (oDataVersion === common_1.FioriElementsVersion.v4) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOID4SECTION', { facet: annotationRecord.fullyQualifiedName })
            });
        }
        if (section && section.entityType) {
            facets[path].entityType = section.entityType;
        }
    }
}
/**
 * Adds the information from facets to the config
 * @param {AnnotationTerm} annotationRecord - the actual annotation record
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {string} serviceName - name of the service of the app
 * @param {string} entityName - the entity (type) name
 * @param {FacetConfigs} facets - list of facets in config format, to be updated
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function addFacetToConfig(annotationRecord, oDataServiceAVT, serviceName, entityType, facets, oDataVersion = common_1.FioriElementsVersion.v2, logger) {
    var _a;
    const section = getSectionFacet(annotationRecord, entityType, oDataServiceAVT, logger, oDataVersion, false);
    if (section) {
        switch (annotationRecord.$Type) {
            case "com.sap.vocabularies.UI.v1.ReferenceFacet" /* ReferenceFacet */: {
                evaluateTargetAnnotation(section, annotationRecord, facets, entityType, oDataServiceAVT, oDataVersion, logger);
                break;
            }
            case "com.sap.vocabularies.UI.v1.CollectionFacet" /* CollectionFacet */: {
                const annotationPath = `/${entityType.fullyQualifiedName}/${annotationRecord.fullyQualifiedName.split(entityType.fullyQualifiedName)[1]}`;
                const facet = (facets[section.key] = {
                    base: types_1.FacetBase.CollectionFacet,
                    facets: {},
                    ID: section.ID,
                    annotationPath: annotationPath,
                    Label: section.label
                });
                (_a = annotationRecord.Facets) === null || _a === void 0 ? void 0 : _a.forEach((collectionItem) => {
                    addFacetToConfig(collectionItem, oDataServiceAVT, serviceName, entityType, facet.facets, oDataVersion, logger);
                });
                break;
            }
        }
    }
}
/**
 * Retrieve header facet configurations that can be used to generate ObjectPage schemas
 * @param {QualifiedName} entityTypeName - the name of the actual entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function getObjectPageHeaderFacets(entityType, oDataServiceAVT, oDataVersion = common_1.FioriElementsVersion.v2, logger) {
    const facets = {};
    if (!entityType || !entityType.annotations) {
        return;
    }
    const alias = findAlias(types_1.UIVOCABULARY, oDataServiceAVT);
    const facetAnnotation = alias && entityType.annotations[alias] && entityType.annotations[alias].HeaderFacets;
    if (facetAnnotation) {
        const lastDot = entityType.fullyQualifiedName.lastIndexOf('.');
        const serviceName = entityType.fullyQualifiedName.substr(0, lastDot);
        // Add facets to configuration
        facetAnnotation.forEach((item) => {
            addFacetToConfig(item, oDataServiceAVT, serviceName, entityType, facets, oDataVersion, logger);
        });
    }
    return facets;
}
exports.getObjectPageHeaderFacets = getObjectPageHeaderFacets;
/**
 * Retrieve facet configurations that can be used to generate ObjectPage schemas
 * @param {QualifiedName} entityTypeName - the name of the actual entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function getObjectPageFacets(entityType, oDataServiceAVT, oDataVersion = common_1.FioriElementsVersion.v2, logger) {
    const facets = {};
    if (!entityType || !entityType.annotations) {
        return;
    }
    const alias = findAlias(types_1.UIVOCABULARY, oDataServiceAVT);
    const facetAnnotation = alias && entityType.annotations[alias] && entityType.annotations[alias].Facets;
    if (facetAnnotation) {
        const lastDot = entityType.fullyQualifiedName.lastIndexOf('.');
        const serviceName = entityType.fullyQualifiedName.substr(0, lastDot);
        // Add facets to configuration
        facetAnnotation.forEach((item) => {
            addFacetToConfig(item, oDataServiceAVT, serviceName, entityType, facets, oDataVersion, logger);
        });
    }
    return facets;
}
exports.getObjectPageFacets = getObjectPageFacets;
/**
 * Returns the version of Fiori elements (v2/v4) from a given manifest
 * @param manifest - the manifest.json file
 */
function getVersionFromManifest(manifest) {
    if (manifest[v4_1.ManifestSection.generic] || manifest[v4_1.ManifestSection.ovp]) {
        return common_1.FioriElementsVersion.v2;
    }
    else {
        return common_1.FioriElementsVersion.v4;
    }
}
exports.getVersionFromManifest = getVersionFromManifest;
/**
 * Determines the template type of a V2 app
 * @param manifest - the manifest.json file
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {TemplateType} the template type
 */
function determineV2Template(manifest, logger) {
    let templateType;
    if (manifest[v4_1.ManifestSection.generic]) {
        const v2Pages = manifest[v4_1.ManifestSection.generic].pages;
        if (!v2Pages) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOPAGES', { appId: manifest['sap.app']['id'] }),
                location: {
                    path: types_1.MANIFESTPATH,
                    range: [v4_1.ManifestSection.generic]
                }
            });
            return;
        }
        for (const pageKey in v2Pages) {
            const v2Page = v2Pages[pageKey];
            if (getPageTypeV2(v2Page.component.name) === common_1.PageType.AnalyticalListPage) {
                templateType = TemplateType.AnalyticalListPageV2;
                break;
            }
            else if (getPageTypeV2(v2Page.component.name) === common_1.PageType.ListReport) {
                templateType = TemplateType.ListReportObjectPageV2;
                break;
            }
        }
    }
    else {
        if (!templateType) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOTEMPLATE', { section: v4_1.ManifestSection.generic }),
                location: {
                    path: types_1.MANIFESTPATH,
                    range: [v4_1.ManifestSection.generic]
                }
            });
        }
    }
    return templateType;
}
exports.determineV2Template = determineV2Template;
/**
 * Determines the template type of a V4 app
 * @param manifest - the manifest.json file
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {TemplateType} the template type
 */
function determineV4Template(manifest, logger) {
    var _a, _b, _c, _d;
    let templateType;
    const v4Pages = manifest[v4_1.ManifestSection.ui5].routing &&
        manifest[v4_1.ManifestSection.ui5].routing.targets;
    if (!v4Pages) {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOPAGES', { appId: manifest['sap.app']['id'] }),
            location: {
                path: types_1.MANIFESTPATH,
                range: [v4_1.ManifestSection.ui5, 'routing']
            }
        });
        return;
    }
    for (const pageKey in v4Pages) {
        const v4Page = v4Pages[pageKey];
        const pageType = getPageTypeV4(v4Page.name);
        if (pageType === common_1.PageTypeV4.AnalyticalListPage) {
            templateType = TemplateType.AnalyticalListPageV4;
            break;
        }
        else if (pageType === common_1.PageTypeV4.ListReport) {
            const viewPath = (_d = (_c = (_b = (_a = v4Page.options) === null || _a === void 0 ? void 0 : _a.settings) === null || _b === void 0 ? void 0 : _b.views) === null || _c === void 0 ? void 0 : _c.paths) === null || _d === void 0 ? void 0 : _d[0];
            if (viewPath && (viewPath[types_1.ALPViewType.Primary] || viewPath[types_1.ALPViewType.Secondary])) {
                templateType = TemplateType.AnalyticalListPageV4;
            }
            else {
                templateType = TemplateType.ListReportObjectPageV4;
            }
            break;
        }
        else if (pageType === common_1.PageTypeV4.ObjectPage) {
            templateType = TemplateType.ListReportObjectPageV4;
            //fixed now for FEOP scenario, bit continue to check if LR/ALP exists
        }
    }
    if (!templateType) {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOTEMPLATE', { section: v4_1.ManifestSection.ui5 }),
            location: {
                path: types_1.MANIFESTPATH,
                range: [v4_1.ManifestSection.ui5, 'routing', 'targets']
            }
        });
    }
    return templateType;
}
exports.determineV4Template = determineV4Template;
/**
 * Determines the template type, based on the given manifest entries of the app
 * @param manifest - the manifest.json file
 * @param {FioriElementsVersion} fioriElementsVersion - OData or FE version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {TemplateType} the template type
 */
function getTemplateTypeFromManifest(manifest, fioriElementsVersion, logger) {
    let templateType;
    if (manifest[v4_1.ManifestSection.ovp]) {
        templateType = TemplateType.OverviewPageV2;
    }
    else if (fioriElementsVersion === common_1.FioriElementsVersion.v2) {
        templateType = determineV2Template(manifest, logger);
    }
    else if (fioriElementsVersion === common_1.FioriElementsVersion.v4) {
        templateType = determineV4Template(manifest, logger);
    }
    else {
        if (!templateType) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOFE'),
                location: {
                    path: types_1.MANIFESTPATH
                }
            });
        }
    }
    return templateType;
}
exports.getTemplateTypeFromManifest = getTemplateTypeFromManifest;
/**
 * Adds title and description to a section or header section in an app schema
 * @param facet - intermediate facet structure comprising annotation information
 * @param section - section in the app schema
 * @param facetKey - key of the facet
 */
function addSectionTitleAndDescription(facet, section, facetKey) {
    if (facet === null || facet === void 0 ? void 0 : facet.ID) {
        section['title'] = types_1.FacetTitlePrefix + facet.ID;
    }
    else {
        section['title'] = facetKey.replace(/@com.sap/g, 'com.sap');
    }
    // Description
    if (facet === null || facet === void 0 ? void 0 : facet.Label) {
        section['description'] = facet.Label;
    }
    else if (facet === null || facet === void 0 ? void 0 : facet.ID) {
        section['description'] = facet.ID;
    }
    else {
        section['description'] = facetKey.substr(facetKey.lastIndexOf('.') + 1);
    }
}
exports.addSectionTitleAndDescription = addSectionTitleAndDescription;
/**
 * Adds target title or description to a section or header section in an app schema
 * @param facet - intermediate facet structure comprising annotation information
 * @param section - section in the app schema
 * @param facetKey - key of the facet
 */
function addTargetTitleAndSectionDescription(facet, section, facetKey) {
    var _a, _b, _c, _d;
    addSectionTitleAndDescription(facet, section, facetKey);
    if ((_a = facet === null || facet === void 0 ? void 0 : facet.target) === null || _a === void 0 ? void 0 : _a['Title']) {
        section['description'] = (_b = facet === null || facet === void 0 ? void 0 : facet.target) === null || _b === void 0 ? void 0 : _b['Title'];
    }
    else if ((_c = facet === null || facet === void 0 ? void 0 : facet.target) === null || _c === void 0 ? void 0 : _c['Description']) {
        section['description'] = (_d = facet === null || facet === void 0 ? void 0 : facet.target) === null || _d === void 0 ? void 0 : _d['Description'];
    }
}
exports.addTargetTitleAndSectionDescription = addTargetTitleAndSectionDescription;
/**
 * Creates a default object for a new section or subsection, and adds the ID as title if present.
 * @param facet Facet configuration, to be analyzed
 * @returns the new section object
 */
function createSectionWithoutProperties(facet, facetKey) {
    if (!facet) {
        return undefined;
    }
    const section = {
        type: 'object',
        properties: {},
        additionalProperties: false,
        annotationPath: facet.annotationPath,
        isViewNode: true
    };
    addSectionTitleAndDescription(facet, section, facetKey);
    return section;
}
exports.createSectionWithoutProperties = createSectionWithoutProperties;
/**
 * Retrieve page section data(so far id/key and label/description).
 * @param {EntityType} entityType The actual entityType
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {boolean} [checkUnresolvableFacets=false] - Check and avoid facets and sections without ID and Target.
 * @returns {FacetSection[]} - Array of facets or sections
 */
function getObjectPageFacetSection(entityType, oDataServiceAVT, logger, oDataVersion = common_1.FioriElementsVersion.v2, checkUnresolvableFacets = false) {
    const alias = findAlias(types_1.UIVOCABULARY, oDataServiceAVT);
    let sections = [];
    if (entityType) {
        const facetAnnotation = alias && entityType.annotations && entityType.annotations[alias] && entityType.annotations[alias].Facets;
        if (facetAnnotation) {
            sections = facetAnnotation.reduce(function (result, item) {
                if (checkUnresolvableFacets && !item['ID'] && !('Target' in item && item['Target'])) {
                    return result;
                }
                const section = getSectionFacet(item, entityType, oDataServiceAVT, logger, oDataVersion, true);
                if (section) {
                    result.push(section);
                }
                return result;
            }, sections);
        }
        return sections;
    }
}
exports.getObjectPageFacetSection = getObjectPageFacetSection;
/**
 * Cleans empty sub-structures from the export result for manifest
 * @param manifest - manifest.json part of the export result
 * @param path  - path in the manifest
 * @param targetAnnotation - target annotation (optional, in case of sections, subsections)
 * @param targetAnnotationEncoded - encoded version of the target annotation, as represented in the manifest
 */
exports.deleteEmptyStructure = (manifest, path, targetAnnotation, targetAnnotationEncoded) => {
    let manifestSection = manifest;
    const pathArray = path.split('/');
    pathArray.forEach(function (element) {
        const decodedElement = targetAnnotationEncoded && targetAnnotationEncoded === element
            ? targetAnnotation
            : element.replace('??', '/');
        if (!manifestSection[decodedElement]) {
            return;
        }
        if (Object.keys(manifestSection[decodedElement]).length === 0) {
            if (Array.isArray(manifestSection)) {
                manifestSection.splice(Number(decodedElement), 1);
            }
            else {
                delete manifestSection[decodedElement];
            }
            pathArray.pop();
            exports.deleteEmptyStructure(manifest, pathArray.join('/'), targetAnnotation, targetAnnotationEncoded);
            return;
        }
        manifestSection = manifestSection && manifestSection[decodedElement];
    });
};
/**
 * Method which returns generic schema file name.
 * @param {SchemaType | PageType} schemaType Schema type or Page type.
 * @return {string} File name of generic schema.
 */
const getGenericSchemaFileName = (schemaType) => {
    return `${schemaType}`;
};
/**
 * Method which returns schema file name and path depending on passed schema or page type.
 * @param {SchemaType | PageType} schemaType Schema type or Page type.
 * @param {string} [entitySet] Entity set string.
 * @return {SchemaFilePath} File path info.
 */
exports.getSchemaFilePath = (schemaType, entitySet) => {
    const schemaFile = {
        filename: '',
        path: ''
    };
    switch (schemaType) {
        // Application schema
        case schemaAccess_1.SchemaType.Application: {
            // File name
            schemaFile.filename = `App`;
            // Full path
            schemaFile.path = `./${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
        // List report and object page
        case schemaAccess_1.SchemaType.ListReport:
        case schemaAccess_1.SchemaType.ObjectPage: {
            // File name
            schemaFile.filename = entitySet ? `${schemaType}_${entitySet}` : getGenericSchemaFileName(schemaType);
            // Full path
            schemaFile.path = `../${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
        // Other page configs
        default: {
            // File name
            schemaFile.filename = getGenericSchemaFileName(schemaType);
            // Full path
            schemaFile.path = `../${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
    }
    schemaFile.path += '.json';
    return schemaFile;
};
/**
 * Method which generates id of page according to passed parameters.
 * @param appVersion - Fiori Elements version - V2 or V4.
 * @param pageType - Page type.
 * @param entitySet - Entity Set.
 * @param navigationProperty - Navigation property (optional).
 * @param viewId - Custom page's viewId (optional).
 * @returns {string} Generated page id
 */
function generatePageId(pageType, entitySet, navigationProperty, viewId) {
    if (pageType === common_1.PageType.CustomPage) {
        const names = viewId && viewId.split('.');
        return names && names[names.length - 1] + 'Page';
    }
    const parts = [];
    parts.push(pageType);
    if (entitySet) {
        parts.push(entitySet);
    }
    return parts.join('_');
}
exports.generatePageId = generatePageId;
/**
 * Fills an array of next definitions from given references in the JSON schema
 * @param propertyDefinition - Definition of the current property in schema
 * @param currentConfigObject - Current object in the config JSON. Evaluated to get the right value of a cntrolling property,
 *                              for making the right choice in case of multiple options (anyOf)
 * @param appSchema - app-spcific JSON schema
 * @returns an array of definitions to proceed with
 */
function fillArrayFromPropertyDefinition(propertyDefinition, currentConfigObject, appSchema) {
    const definitionArray = [];
    if (propertyDefinition['$ref']) {
        definitionArray.push(propertyDefinition['$ref'].split(exports.DEFINITION_LINK_PREFIX)[1]);
    }
    else if (propertyDefinition['anyOf']) {
        if (currentConfigObject) {
            propertyDefinition['anyOf'].forEach((element) => {
                if (element.$ref) {
                    const definitionKey = element.$ref.split(exports.DEFINITION_LINK_PREFIX)[1];
                    if (appSchema['definitions'][definitionKey]) {
                        const controlProperty = appSchema['definitions'][definitionKey]['controlProperty'];
                        if (element.$ref.includes(currentConfigObject[controlProperty])) {
                            definitionArray.push(definitionKey);
                        }
                    }
                }
            });
        }
        if (definitionArray.length === 0) {
            return undefined;
        }
    }
    return definitionArray;
}
/**
 * Determines the next definition to be handled, based on the definition array.
 * It also creates the Metadata instance for the next definition, to subsequently access metadata like the syncRule
 * @param definitionArray - Array of definitions, as determined by fillArrayFromNextDefinition
 * @param appSchema - app-spcific JSON schema
 * @param title - default title
 * @param currentConfigObject - Current object in the config JSON.
 * @param key - actual key
 * @param {MetadataInstanceInterface} factory - factory for creating metadata instances
 * @param pageType - page type
 * @param propertyDefinition - Definition of the current property in schema
 * @returns {NextDefinition} - Next target definition to process
 */
function determineNextDefinitionFromDefinitionArray(definitionArray, appSchema, title, currentConfigObject, key, factory, pageType, propertyDefinition) {
    var _a, _b, _c, _d;
    let nextDefinition = {
        configObject: undefined,
        targetDefinition: {},
        title: ''
    };
    if (definitionArray.length) {
        const lastDefinition = definitionArray[definitionArray.length - 1];
        nextDefinition.targetDefinition = appSchema['definitions'][lastDefinition];
        if (((_a = nextDefinition === null || nextDefinition === void 0 ? void 0 : nextDefinition.targetDefinition) === null || _a === void 0 ? void 0 : _a['$ref']) || ((_b = nextDefinition === null || nextDefinition === void 0 ? void 0 : nextDefinition.targetDefinition) === null || _b === void 0 ? void 0 : _b['type']) === 'array') {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            nextDefinition = getNextTargetDefinition(appSchema, title, currentConfigObject, nextDefinition.targetDefinition, key, factory, pageType);
            return nextDefinition;
        }
        if (definitionArray.length > 1) {
            definitionArray.forEach((element) => {
                if (element !== '') {
                    nextDefinition.targetDefinition['properties'] = Object.assign(Object.assign({}, nextDefinition.targetDefinition['properties']), appSchema['definitions'][element]['properties']);
                }
            });
        }
        nextDefinition.title = ((_c = nextDefinition === null || nextDefinition === void 0 ? void 0 : nextDefinition.targetDefinition) === null || _c === void 0 ? void 0 : _c['title']) ? nextDefinition.targetDefinition['title']
            : title;
        const factoryKey = lastDefinition === null || lastDefinition === void 0 ? void 0 : lastDefinition.split('<')[0];
        const targetObject = currentConfigObject ? currentConfigObject : {};
        nextDefinition.configObject = factory.createInstance(pageType, factoryKey, targetObject, (_d = nextDefinition === null || nextDefinition === void 0 ? void 0 : nextDefinition.targetDefinition) === null || _d === void 0 ? void 0 : _d['controlProperty']);
    }
    else {
        //e.g. sections ==> loop over all properties = subsections or other
        nextDefinition.targetDefinition = propertyDefinition;
        nextDefinition.title = nextDefinition.targetDefinition['title']
            ? nextDefinition.targetDefinition['title']
            : key;
        nextDefinition.configObject = currentConfigObject;
    }
    return nextDefinition;
}
/**
 * Recursive function to determine the next config part, next definition in the app schema and the title
 * @param appSchema - app-spcific JSON schema
 * @param title - default title
 * @param currentConfigObject - current part of the configuration that gets traversed
 * @param propertyDefinition - definition of a given property in the app schema
 * @param key - actual key
 * @param {MetadataInstanceInterface} factory - factory for creating metadata instances
 * @param pageType - page type
 */
function getNextTargetDefinition(appSchema, title, currentConfigObject, propertyDefinition, key, factory, pageType) {
    let nextDefinition;
    if (propertyDefinition['type'] === 'array') {
        nextDefinition = getNextTargetDefinition(appSchema, title, currentConfigObject, propertyDefinition['items'], key, factory, pageType);
        return nextDefinition;
    }
    const definitionArray = fillArrayFromPropertyDefinition(propertyDefinition, currentConfigObject, appSchema);
    if (!definitionArray) {
        return undefined;
    }
    nextDefinition = determineNextDefinitionFromDefinitionArray(definitionArray, appSchema, title, currentConfigObject, key, factory, pageType, propertyDefinition);
    return nextDefinition;
}
exports.getNextTargetDefinition = getNextTargetDefinition;
function prepareRef(refInput) {
    return refInput.replace('#', '::').replace(/\//g, ':2f');
}
exports.prepareRef = prepareRef;
/**
 * Custom array merge function called by deepmerge's merge function
 *
 * @param {*} target Target array
 * @param {*} source Source array
 * @param {*} options options object provided by deepmerge's merge function
 * @returns
 */
exports.arrayCombineMerge = (target, source, options) => {
    const destination = target.slice();
    source.forEach((item, index) => {
        if (typeof destination[index] === 'undefined') {
            destination[index] = options.cloneUnlessOtherwiseSpecified(item, options);
        }
        else if (options.isMergeableObject(item)) {
            destination[index] = deepmerge_1.default(target[index], item, options);
        }
        else if (target.indexOf(item) === -1) {
            destination.push(item);
        }
    });
    return destination;
};
//# sourceMappingURL=utils.js.map