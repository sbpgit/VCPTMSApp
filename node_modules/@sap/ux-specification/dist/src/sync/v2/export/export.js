"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Note: the main functions or entry points reside in ./exportPage.ts
const deepmerge_1 = __importDefault(require("deepmerge"));
const controls_1 = require("./controls");
const common_1 = require("../../common");
const v2_1 = require("../../../v2");
const application_1 = require("../application");
const manifest_1 = require("./manifest");
const utils_1 = require("../import/utils");
/**
 * Create missing card from the manifest
 * @param key - card name
 * @param ovp - OVP section of manifest, to be updated
 */
function createCard(key, ovp) {
    if (!ovp.cards) {
        ovp.cards = {};
    }
    if (!(key in ovp.cards)) {
        ovp.cards[key] = {};
    }
}
/**
 * Recursive function that searches for next avaialble id by increasing number by 1.
 * @param {boolean} sectionIds All ids in use.
 * @param {string} candidateId Candidate id to check if it is available.
 * @return {string} Id string.
 */
function findAvailableId(sectionIds, candidateId) {
    if (sectionIds.includes(candidateId)) {
        const idParts = candidateId.split('|');
        if (idParts.length === 3) {
            idParts.push('1');
        }
        else {
            idParts[3] = (parseInt(idParts[3]) + 1).toString();
        }
        return findAvailableId(sectionIds, idParts.join('|'));
    }
    return candidateId;
}
/**
 * Private recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configObject - current object to traverse
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param jsonSchema - application specific schema
 * @param targetDefinition - the current entry point or definition in the app schema
 * @param {MetadataInstanceInterface} factory - factory for creating metadata instances
 * @param pathHierarchy -  elements of the path indicating the hierarchical level
 */
function transferManifestEntriesOVP(configObject, exportResults, jsonSchema, targetDefinition, factory, pathHierarchy) {
    if (targetDefinition) {
        if (targetDefinition['properties']) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            processProperties(configObject, exportResults, jsonSchema, targetDefinition['properties'], factory, pathHierarchy);
        }
        else if (targetDefinition['additionalProperties']) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            processProperties(configObject, exportResults, jsonSchema, targetDefinition['additionalProperties'], factory, pathHierarchy);
        }
    }
}
exports.transferManifestEntriesOVP = transferManifestEntriesOVP;
/**
 * Assign sync rules to {currentObject}
 *
 * @param {string} structureName - name of the complex structure in schema
 * @param {object} currentObject - the given part of the configuration
 * @param {string} defaultTypeName - name of the default type that shall be taken if no class is registered for structureName
 */
function assignReflectMetadataRules(factory, structureName, currentObject, defaultTypeName) {
    return factory.createInstance(v2_1.PageType.OverviewPage, defaultTypeName, currentObject, structureName);
}
exports.assignReflectMetadataRules = assignReflectMetadataRules;
function processAnyOfDefinitionsOfOVP(pathHierarchy, propertyList, jsonSchema, currentObject, configObject, factory, exportResults) {
    pathHierarchy.pop();
    let newConfigObject = currentObject;
    for (const anyOfKey in propertyList['anyOf']) {
        if (propertyList['anyOf'][anyOfKey].$ref) {
            const definitionArray = propertyList['anyOf'][anyOfKey].$ref.split(common_1.DEFINITION_LINK_PREFIX);
            const nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
            const cardSettingsType = pathHierarchy[1];
            currentObject = configObject[cardSettingsType];
            newConfigObject = assignReflectMetadataRules(factory, cardSettingsType, currentObject, 'CustomCard');
            transferManifestEntriesOVP(newConfigObject, exportResults, jsonSchema, nextTargetDefinition, factory, [
                ...pathHierarchy
            ]);
        }
        else if (typeof propertyList['anyOf'][anyOfKey] === 'object') {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            processProperties(configObject, exportResults, jsonSchema, propertyList['anyOf'][anyOfKey].properties, factory, [...pathHierarchy, 'anyOfObject']);
        }
    }
    return newConfigObject;
}
/**
 * Transfer manifest settings from config to manifest
 * @param syncRule
 * @param pathHierarchy
 * @param key
 * @param exportResults
 * @param currentObject
 * @param configObject
 * @param exceptionList
 */
function transferToManifest(syncRule, pathHierarchy, key, exportResults, currentObject, configObject, exceptionList) {
    const path = syncRule.manifest.path([...pathHierarchy, key]);
    const manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
    if (key in v2_1.CardSettingsType || key === 'settings') {
        manifestSection['settings'] = deepmerge_1.default(manifestSection['settings'] || {}, currentObject || {}, {
            arrayMerge: common_1.arrayCombineMerge
        });
    }
    else if (currentObject !== undefined) {
        const exportHandler = syncRule.manifest.export;
        if (exportHandler !== false) {
            if (exportHandler && typeof exportHandler === 'function') {
                exportHandler(manifestSection, configObject, key);
            }
            else if (typeof currentObject === 'object' && !exceptionList.includes(key)) {
                // colorPalette is an exception as it can contain anything as per our schema, so just replace the object
                manifestSection[key] = deepmerge_1.default(manifestSection[key] || {}, currentObject || {}, {
                    arrayMerge: common_1.arrayCombineMerge
                });
            }
            else {
                manifestSection[key] = currentObject;
            }
        }
    }
    else if (manifestSection[key] !== undefined) {
        delete manifestSection[key];
    }
}
function transferCards(currentObject, jsonSchema, factory, exportResults) {
    Object.keys(currentObject).forEach((cardKey) => {
        const cardType = currentObject[cardKey].template;
        //Determine target defintion
        let targetDefinition;
        if (!Object.values(v2_1.CardTemplateType).includes(cardType)) {
            targetDefinition = ['CustomCard'];
        }
        else {
            targetDefinition = Object.keys(jsonSchema['definitions']).filter((definition) => {
                var _a, _b, _c;
                return ((_c = (_b = (_a = jsonSchema['definitions'][definition].properties) === null || _a === void 0 ? void 0 : _a.template) === null || _b === void 0 ? void 0 : _b.enum) === null || _c === void 0 ? void 0 : _c.indexOf(currentObject[cardKey].template)) > -1;
            });
        }
        //Get metadata
        currentObject[cardKey] = assignReflectMetadataRules(factory, targetDefinition[0], currentObject[cardKey], 'CustomCard');
        createCard(cardKey, exportResults['manifest'][v2_1.ManifestSection.ovp]);
        transferManifestEntriesOVP(currentObject[cardKey], exportResults, jsonSchema, jsonSchema['definitions'][targetDefinition[0]], factory, [cardKey]);
    });
    //check for deletions:
    Object.keys(exportResults.manifest[v2_1.ManifestSection.ovp].cards).forEach((manifestCard) => {
        if (!currentObject[manifestCard]) {
            delete exportResults.manifest[v2_1.ManifestSection.ovp].cards[manifestCard];
        }
    });
}
/**
 * Recursive function that transfers the content of a list of properties of a configuration to the overall exportResults
 * @param configObject - the given part of the configuration
 * @param exportResults - overall result list, to be updated
 * @param jsonSchema - app-specific JSOn schema
 * @param propertyList - current property list of the config (properties or additional properties)
 * @param {MetadataInstanceInterface} factory - factory for creating metadata instances
 * @param pathHierarchy -  elements of the path indicating the hierarchical level
 */
function processProperties(configObject, exportResults, jsonSchema, propertyList, factory, pathHierarchy) {
    let currentObject;
    let isAnyOfObject = false;
    let isObjectProperty = false;
    const exceptionList = ['colorPalette', 'tabs'];
    for (const key in propertyList) {
        currentObject = configObject[key];
        let syncRule = common_1.getReflectMetadata(configObject, key);
        if (pathHierarchy[pathHierarchy.length - 1] === 'anyOfObject') {
            isAnyOfObject = true;
            pathHierarchy.pop();
        }
        if (isAnyOfObject) {
            currentObject = configObject[pathHierarchy[pathHierarchy.length - 1]][key];
            syncRule = common_1.getReflectMetadata(configObject, pathHierarchy[pathHierarchy.length - 1]);
        }
        if (pathHierarchy[pathHierarchy.length - 1] === 'objectProperties') {
            isObjectProperty = true;
            pathHierarchy.pop();
        }
        if (isObjectProperty) {
            currentObject = configObject[pathHierarchy[pathHierarchy.length - 1]][key];
            syncRule = common_1.getReflectMetadata(configObject, pathHierarchy[pathHierarchy.length - 1]);
        }
        if (pathHierarchy[pathHierarchy.length - 1] === 'anyOf') {
            currentObject = processAnyOfDefinitionsOfOVP(pathHierarchy, propertyList, jsonSchema, currentObject, configObject, factory, exportResults);
        }
        if (syncRule === null || syncRule === void 0 ? void 0 : syncRule.manifest) {
            transferToManifest(syncRule, pathHierarchy, key, exportResults, currentObject, configObject, exceptionList);
        }
        if (currentObject && typeof currentObject === 'object' && propertyList[key]) {
            if (key === 'cards') {
                //inserts and updates:
                transferCards(currentObject, jsonSchema, factory, exportResults);
            }
            else if (propertyList[key].$ref) {
                const definitionArray = propertyList[key].$ref.split(common_1.DEFINITION_LINK_PREFIX);
                const nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
                currentObject = assignReflectMetadataRules(factory, key, currentObject, key === 'settings' ? 'CustomCard' : '');
                transferManifestEntriesOVP(currentObject, exportResults, jsonSchema, nextTargetDefinition, factory, [
                    ...pathHierarchy,
                    key
                ]);
            }
            else if (propertyList[key].anyOf) {
                processProperties(configObject, exportResults, jsonSchema, propertyList[key], factory, [
                    ...pathHierarchy,
                    key,
                    'anyOf'
                ]);
            }
            else if (propertyList[key]['properties'] !== undefined) {
                processProperties(configObject, exportResults, jsonSchema, propertyList[key].properties, factory, [
                    ...pathHierarchy,
                    key,
                    'objectProperties'
                ]);
            }
        }
    }
}
/**
 * Evaluates an export rule for a property, transfers to flex change
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param syncRule - export rule from the object classes decorator
 * @param configObject - current (sub)object of the configuration file
 * @param ids - list of parent & child ids
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param key - key of the given property
 */
function evaluateFlexRule(transferParameters, breadcrumbs, syncRule, ids, title, configObject, key) {
    let localBreadcrumbs;
    if (breadcrumbs.length === 0) {
        //only added on top = page level, do not forward
        localBreadcrumbs = ['page'];
    }
    else {
        localBreadcrumbs = breadcrumbs;
    }
    const controlId = syncRule.flex.controlId(transferParameters.baseId, ids, localBreadcrumbs, syncRule.flex.controlType, title);
    const flexChange = common_1.fillFlexChangeContent(configObject, syncRule, transferParameters.ui5Version, key, controlId);
    const localManifest = JSON.parse(JSON.stringify(transferParameters.exportResults.manifest));
    localManifest['sap.app'].id = transferParameters.appId;
    const completeFlexChange = syncRule.flex.createFlexChange(flexChange, localManifest);
    const flexChangeExists = transferParameters.exportResults.flexChanges.find((change) => {
        let result = false, oldChange = JSON.parse(change);
        oldChange = {
            content: oldChange['content'],
            selector: oldChange['selector']
        };
        let newChange = JSON.parse(completeFlexChange);
        newChange = {
            content: newChange['content'],
            selector: newChange['selector']
        };
        if (JSON.stringify(oldChange) === JSON.stringify(newChange)) {
            result = true;
        }
        return result;
    });
    if (!flexChangeExists) {
        transferParameters.exportResults.flexChanges.push(completeFlexChange);
    }
}
/**
 * Evaluates an export rule for a property, transfers to manifest setting
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param syncRule - export rule from the object classes decorator
 * @param configObject - current (sub)object of the configuration file
 * @param ids - list of parent & child ids
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param key - key of the given property
 */
function evaluateManifestRule(transferParameters, path, syncRule, key, configObject) {
    const manifestSection = manifest_1.getManifestSectionByPathV2(transferParameters.exportResults.manifest, path);
    const manifestKey = syncRule.manifest.key || key;
    if (configObject[key] !== undefined) {
        // In case of arrays we take over complete array
        if (!(transferParameters.propertyDefinition['type'] !== 'array' &&
            transferParameters.nextDefinition &&
            transferParameters.nextDefinition['targetDefinition'].type === 'object' &&
            transferParameters.nextDefinition['targetDefinition'].properties)) {
            const exportHandler = syncRule.manifest.export;
            if (exportHandler && typeof exportHandler === 'function') {
                exportHandler(manifestSection, configObject, key, manifestKey);
            }
            else if (exportHandler !== false) {
                manifestSection[manifestKey] = configObject[key];
            }
        }
        else if (transferParameters.propertyDefinition['type'] !== 'array' &&
            manifestSection[manifestKey] === undefined) {
            manifestSection[manifestKey] = {};
        }
    }
    else {
        if (Object.prototype.hasOwnProperty.call(manifestSection, manifestKey)) {
            delete manifestSection[manifestKey];
        }
    }
    common_1.deleteEmptyStructure(transferParameters.exportResults.manifest, path);
}
/**
 * Determines the path to a manifest setting, based on the syncRule
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param {SyncRule} syncRule - export rule from the object classes decorator
 * @param configObject - current (sub)object of the configuration file
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @returns the path to the manifest setting
 */
function getManifestPath(transferParameters, breadcrumbs, syncRule, configObject, title) {
    let path;
    if (breadcrumbs[0] === 'sections') {
        if (breadcrumbs[1] === 'custom') {
            path = syncRule.manifest.path(transferParameters.pageKeys, {}, breadcrumbs[2]);
        }
        else {
            path = syncRule.manifest.path(transferParameters.pageKeys, {}, (title === null || title === void 0 ? void 0 : title.startsWith(common_1.FacetTitlePrefix)) ? title.split(common_1.FacetTitlePrefix)[1] : breadcrumbs[1], breadcrumbs[breadcrumbs.length - 1]);
            path = path.replace('/@', '::').replace(/VOCWITHCOLONS/g, '::com.sap.vocabularies');
        }
    }
    else if (breadcrumbs[0] === 'table') {
        if (breadcrumbs[1] === 'columns' && breadcrumbs[2] === 'custom') {
            path = syncRule.manifest.path(transferParameters.pageKeys, transferParameters.exportResults.manifest, configObject['tabKey']);
        }
        else {
            path = syncRule.manifest.path(transferParameters.pageKeys, {}, breadcrumbs[breadcrumbs.length - 1]);
        }
    }
    else if (breadcrumbs[0] === 'keyPerformanceIndicators') {
        path = syncRule.manifest.path(transferParameters.pageKeys, transferParameters.exportResults.manifest, title);
    }
    else if (breadcrumbs[0] === 'filterBar' && breadcrumbs[1] === 'selectionFields') {
        path = syncRule.manifest.path(transferParameters.pageKeys, transferParameters.exportResults.manifest, breadcrumbs.slice(2).join('/'));
    }
    else {
        path = syncRule.manifest.path(transferParameters.pageKeys);
    }
    return path;
}
/**
 * Evaluates an export rule for a property or object, transfers to flex change or manifest setting
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param {SyncRule} syncRule - export rule from the object classes decorator
 * @param configObject - current (sub)object of the configuration file
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param ids - list of parent & child ids
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param key - key of the given property
 */
function evaluateExportRule(transferParameters, syncRule, configObject, breadcrumbs, ids, title, key) {
    if (!syncRule) {
        return;
    }
    //eliminate subsections' hierarchy
    let index = breadcrumbs.indexOf('subsections');
    while (index > -1) {
        breadcrumbs.splice(index - 1, 2);
        index = breadcrumbs.indexOf('subsections');
    }
    if (syncRule.flex) {
        evaluateFlexRule(transferParameters, breadcrumbs, syncRule, ids, title, configObject, key);
    }
    else if (syncRule.manifest) {
        const path = getManifestPath(transferParameters, breadcrumbs, syncRule, configObject, title);
        evaluateManifestRule(transferParameters, path, syncRule, key, configObject);
    }
}
/**
 * Walks through the extensions registered in manifest and compares the columns of the fragment with the ones present in config.
 * If not present anymore, the extension column gets deleted from fragment.
 * @param path - path to extesnions section in manifest
 * @param exportResults - result structure, including the fragments that may get updated
 * @param entitySet - current entity set
 * @param config - current config JSON
 * @param sectionKey - section key
 * @param extensionType - extensionType
 * @param appId - application ID
 */
function deleteObsoleteColumnsFromFragment(path, exportResults, entitySet, config, sectionKey, extensionType, appId) {
    const folderPath = path.substr(0, path.lastIndexOf('/'));
    const manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, folderPath);
    const extensionPattern = path.substr(path.lastIndexOf('/') + 1);
    for (const key in manifestSection) {
        if (key.startsWith(extensionPattern)) {
            const keyParts = key.split('|');
            const keyEntitySet = keyParts[1];
            const keyTab = keyParts[2];
            if (keyEntitySet === entitySet) {
                //relevant extension. still present in config?
                const existingConfigEntries = config === null || config === void 0 ? void 0 : config.filter((column) => (column.tabKey === keyTab ||
                    (keyTab === undefined && column.tabKey === '') ||
                    (keyTab && sectionKey === keyTab)) &&
                    column.extensionType === extensionType);
                if (!existingConfigEntries || existingConfigEntries.length === 0) {
                    controls_1.deleteColumnFromFragment(manifestSection, key, appId, exportResults.fragments);
                    // delete from manifest
                    delete manifestSection[key];
                    // delete cells entry
                    if (key.startsWith(common_1.ViewTemplateType.ResponsiveTableColumnsExtension)) {
                        const cellsPattern = key.replace(common_1.ViewTemplateType.ResponsiveTableColumnsExtension, common_1.ViewTemplateType.ResponsiveTableCellsExtension);
                        controls_1.deleteColumnFromFragment(manifestSection, cellsPattern, appId, exportResults.fragments);
                        // delete from manifest
                        delete manifestSection[cellsPattern];
                    }
                }
            }
        }
    }
}
/**
 * Clusters the custom columns if a config by the extension's path in manifest
 * @param customColumnsInConfig - list of all custom columns in config
 * @param schemaDefinition - schema definition of the table custom column
 * @param v2Page - current page in manifest
 * @param entitySet - current entity set
 * @param sectionKey key of the section (in case of OP)
 * @returns the custom columns, clustered by the manifest path
 */
function clusterConfigColumnsByPath(customColumnsInConfig, schemaDefinition, v2Page, entitySet, sectionKey) {
    const cluster = {};
    for (const customColumn of customColumnsInConfig) {
        //verify that mandatory parameters are filled
        if (!customColumn['className'] ||
            !customColumn['fragmentName'] ||
            !customColumn['columnKey'] ||
            !customColumn['extensionType']) {
            continue;
        }
        //check fragment name
        if (schemaDefinition['properties']['fragmentName']['pattern']) {
            const namePattern = new RegExp(schemaDefinition['properties']['fragmentName']['pattern']);
            if (namePattern.test(customColumn['fragmentName']) === false) {
                continue;
            }
        }
        const { path, viewTemplateType } = controls_1.getCustomColumnPath(v2Page, entitySet, customColumn.tabKey || sectionKey, customColumn['extensionType']);
        if (!cluster[path]) {
            cluster[path] = {
                viewTemplateType: viewTemplateType,
                columns: []
            };
        }
        cluster[path].columns.push(customColumn);
    }
    return cluster;
}
/**
 * Transfers column extensions to manifest and fragment files
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param {TableCustomColumns} customColumnsInConfig - config part comprising the table custom columns
 * @param {object} schemaDefinition - Column schema definition
 * @param {ObjectPageSectionData} [objectPageSectionData] - Object Page section's data containing target and key options.
 */
function transferColumnExtensions(transferParameters, customColumnsInConfig, schemaDefinition, objectPageSectionData) {
    const sectionKey = objectPageSectionData ? objectPageSectionData.key : undefined;
    const sectionTarget = objectPageSectionData ? objectPageSectionData.target : undefined;
    const entitySet = sectionTarget || transferParameters.v2Page.entitySet;
    for (const extensionType in v2_1.TableColumnExtensionTypeV2) {
        const { path } = controls_1.getCustomColumnPath(transferParameters.v2Page, entitySet, sectionKey, extensionType);
        if (!path) {
            continue;
        }
        deleteObsoleteColumnsFromFragment(path, transferParameters.exportResults, entitySet, customColumnsInConfig, sectionKey, extensionType, transferParameters.appId);
    }
    if (customColumnsInConfig) {
        //cluster existing custom columns by manifest path (or tab key)
        const cluster = clusterConfigColumnsByPath(customColumnsInConfig, schemaDefinition, transferParameters.v2Page, entitySet, sectionKey);
        //Export to fragment
        for (const path in cluster) {
            controls_1.exportCustomColumnsToFragment(transferParameters.exportResults, path, cluster[path].columns, transferParameters.appId, cluster[path].viewTemplateType, transferParameters.logger);
        }
    }
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param configSections - sections from configuration object
 * @param pageKey  - page key
 * @param parentIds - array of collected parent ids
 * @param breadcrumbs - array of properties that we are currently processing. Required for instance for table column name
 * @param targetDefinition - the current entry point or definition in the app schema
 */
function transferManifestExtensions(transferParameters, configSections, pageKey, parentIds, breadcrumbs, targetDefinition) {
    const sectionIds = [];
    const entity = pageKey.split('|')[1];
    if (!configSections) {
        return;
    }
    for (const section of configSections) {
        const id = findAvailableId(sectionIds, [section.relativePosition, entity, section.relatedFacet].join('|'));
        sectionIds.push(id);
    }
    for (let index = 0; index < sectionIds.length; index++) {
        const definition = targetDefinition['anyOf'].find((element) => element.$ref.includes(configSections[index].constructor.name));
        const definitionArray = definition.$ref.split(common_1.DEFINITION_LINK_PREFIX);
        const nextTargetDefinition = transferParameters.appSchema['definitions'][definitionArray[definitionArray.length - 1]];
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        transferManifestEntriesAndFlexChange(transferParameters, configSections[index], parentIds, [...breadcrumbs, sectionIds[index]], nextTargetDefinition);
    }
    // Delete removed manifest entries
    const manifestSections = manifest_1.getManifestSectionByPathV2(transferParameters.exportResults.manifest, application_1.getViewExtensionsPath());
    for (const key in manifestSections) {
        if (utils_1.isAssociatedCustomSection(key, entity) && !sectionIds.includes(key)) {
            delete manifestSections[key];
        }
    }
}
/**
 * Method returns converted section id by resolving passed section id and title from schema.
 * @param {string[]} breadcrumbs Array of properties that we are currently processing. Required for instance for table column name.
 * @param {string} title Title from JSON schema, comprising the facet ID
 * @returns {string | undefined} Resolved section id.
 */
function getSectionId(breadcrumbs, title) {
    let sectionId = undefined;
    for (let i = breadcrumbs.length - 1; i >= 0; i--) {
        if (breadcrumbs[i] === 'table') {
            sectionId = breadcrumbs[i - 1];
            break;
        }
    }
    return common_1.convertSectionId(sectionId, title);
}
function transferIndexTable(currentConfigObject, transferParameters, title, propertyDefinition, key, ids, breadcrumbs) {
    if (!currentConfigObject || !(propertyDefinition === null || propertyDefinition === void 0 ? void 0 : propertyDefinition.additionalProperties)) {
        return;
    }
    Object.keys(currentConfigObject).forEach((newKey) => {
        const nextDefinition = common_1.getNextTargetDefinition(transferParameters.appSchema, title, currentConfigObject[newKey], propertyDefinition.additionalProperties, key, transferParameters.factory, transferParameters.pageType);
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        transferManifestEntriesAndFlexChange(transferParameters, nextDefinition.configObject, ids, [...breadcrumbs, key], nextDefinition.targetDefinition, newKey);
    });
}
function transferCustomColumns(propertyDefinition, breadcrumbs, title, transferParameters, configObject, nextDefinition) {
    let objectPageSectionData;
    const target = common_1.getTargetFromCustomColumnRef(propertyDefinition.$ref);
    if (target) {
        objectPageSectionData = {
            target,
            key: getSectionId(breadcrumbs, title)
        };
    }
    transferColumnExtensions(transferParameters, configObject === null || configObject === void 0 ? void 0 : configObject.custom, nextDefinition.targetDefinition, objectPageSectionData);
}
function handleAnyOfDefinitions(propertyDefinition, transferParameters, title, currentConfigObject, key, ids, breadcrumbs) {
    propertyDefinition['anyOf'].forEach((element) => {
        const nextDefinition = common_1.getNextTargetDefinition(transferParameters.appSchema, title, currentConfigObject, element, key, transferParameters.factory, transferParameters.pageType);
        if (nextDefinition) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            transferManifestEntriesAndFlexChange(transferParameters, nextDefinition.configObject, ids, [...breadcrumbs, key], nextDefinition.targetDefinition, nextDefinition.title);
        }
    });
}
/**
 * Function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param configObject - current (sub)object of the configuration file
 * @param parentIds - array of collected parent ids
 * @param breadcrumbs - array of properties that we are currently processing. Required for instance for table column name
 * @param schemaDefinition - the current entry point or definition in the app schema
 * @param title - title from the app schema (comprising for instance the facet ID)
 */
function transferManifestEntriesAndFlexChange(transferParameters, configObject, parentIds, breadcrumbs, schemaDefinition, title) {
    let currentConfigObject;
    if (!(schemaDefinition === null || schemaDefinition === void 0 ? void 0 : schemaDefinition['properties'])) {
        return;
    }
    for (const key in schemaDefinition['properties']) {
        currentConfigObject = configObject && configObject[key];
        const childId = configObject && common_1.getChildId(configObject, key);
        const ids = childId ? [...parentIds, childId] : parentIds;
        const syncRule = common_1.getReflectMetadata(configObject, key);
        const propertyDefinition = (transferParameters.propertyDefinition = schemaDefinition['properties'][key]);
        const nextDefinition = (transferParameters.nextDefinition = common_1.getNextTargetDefinition(transferParameters.appSchema, title, currentConfigObject, propertyDefinition, key, transferParameters.factory, transferParameters.pageType));
        //Evaluate sync rule for the export
        evaluateExportRule(transferParameters, syncRule, configObject, [...breadcrumbs], ids, title, key);
        //index table
        transferIndexTable(currentConfigObject, transferParameters, title, propertyDefinition, key, ids, breadcrumbs);
        if (currentConfigObject === undefined || typeof currentConfigObject === 'object') {
            if ((propertyDefinition === null || propertyDefinition === void 0 ? void 0 : propertyDefinition.type) === 'array' &&
                (breadcrumbs[0] === 'sections' || breadcrumbs[0] === 'subsections') &&
                key === 'custom') {
                transferManifestExtensions(transferParameters, configObject[key], transferParameters.pageKeys[transferParameters.pageKeys.length - 1], ids, [...breadcrumbs, key], propertyDefinition === null || propertyDefinition === void 0 ? void 0 : propertyDefinition.items);
            }
            else if (nextDefinition && key === 'custom') {
                transferCustomColumns(propertyDefinition, breadcrumbs, title, transferParameters, configObject, nextDefinition);
                continue;
            }
            else if (nextDefinition) {
                transferManifestEntriesAndFlexChange(transferParameters, nextDefinition.configObject, ids, [...breadcrumbs, key], nextDefinition.targetDefinition, nextDefinition.title);
            }
            else if (propertyDefinition['anyOf']) {
                handleAnyOfDefinitions(propertyDefinition, transferParameters, title, currentConfigObject, key, ids, breadcrumbs);
            }
        }
        else if ((propertyDefinition === null || propertyDefinition === void 0 ? void 0 : propertyDefinition.$ref) === common_1.DEFINITION_LINK_PREFIX + 'TableCustomColumns') {
            //empty config ==> delete all given extensions
            transferColumnExtensions(transferParameters, [], transferParameters.appSchema['definitions']['TableCustomColumn']);
            continue;
        }
    }
}
exports.transferManifestEntriesAndFlexChange = transferManifestEntriesAndFlexChange;
//# sourceMappingURL=export.js.map