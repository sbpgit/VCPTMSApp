"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../../common");
const utils_1 = require("./utils");
const import_1 = require("../import");
const v2_1 = require("../../../v2");
const extensionLogger_1 = require("../../../extensionLogger");
const common_2 = require("../../../specification/common");
const i18next_1 = __importDefault(require("i18next"));
const i18n_1 = require("../../../i18n/i18n");
const types_1 = require("../types");
/**
 * Adds flexChange properties for sub(sections)
 * @param appSchema - app schema in general
 * @param schemaSection - current section
 * @param property - property that will be enhanced
 * @param sectionType - type of section
 */
function addFlexChangeForSection(appSchema, schemaSection, property, sectionType) {
    let controlType;
    switch (sectionType) {
        case types_1.SectionTypeV2.Section:
        case types_1.SectionTypeV2.SectionForm:
        case types_1.SectionTypeV2.SectionChart:
        case types_1.SectionTypeV2.SectionTable:
            controlType = v2_1.ControlType.Section;
            break;
        case types_1.SectionTypeV2.SubSection:
            controlType = v2_1.ControlType.SubSection;
            break;
        case types_1.SectionTypeV2.SubSectionForm:
            controlType = v2_1.ControlType.SmartGroup;
            break;
        case types_1.SectionTypeV2.SubSectionChart:
            controlType = v2_1.ControlType.SmartChart;
            break;
        case types_1.SectionTypeV2.SubSectionTable:
            controlType = v2_1.ControlType.SmartTable;
            break;
    }
    if (controlType === undefined) {
        return;
    }
    common_1.addPatternForBindingChangeOfEnumOP(appSchema, schemaSection, property);
    schemaSection['properties'][property].artifactType = common_1.ArtifactType.FlexChange;
    schemaSection['properties'][property].controlType = controlType;
}
/**
 * Callback for adding a single action to headerActions of V2
 * @param {EntityType} entityType - current entity type
 * @param {object} appSchema Schema of the app
 * @param actionAnnotation - annotation as present in AVT ConverterOutput
 * @param headerActions - list of header actions, to be enhanced
 */
function addHeaderActionCallBackV2(entityType, appSchema, actionAnnotation, headerActions, oDataServiceAVT) {
    return (item, index) => {
        if (!item['Determining'] && item.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */) {
            const action = common_1.replaceAlias(item.Action, oDataServiceAVT);
            const { actionName, actionId } = common_1.getActionNameAndId(action, entityType);
            const description = item.Label || actionName;
            const actionDefinitionKey = `HeaderAction<${common_1.prepareRef(actionId)}>`;
            appSchema.definitions[actionDefinitionKey] = JSON.parse(JSON.stringify(appSchema.definitions['HeaderAction']));
            const convertedIdentification = actionAnnotation.fullyQualifiedName.replace(`@${"com.sap.vocabularies.UI.v1.Identification" /* Identification */}`, `/@${"com.sap.vocabularies.UI.v1.Identification" /* Identification */}`);
            appSchema.definitions[actionDefinitionKey]['annotationPath'] = `/${convertedIdentification}/${index}`;
            appSchema.definitions[actionDefinitionKey]['description'] = description;
            headerActions.properties[actionId] = {
                $ref: `${common_1.DEFINITION_LINK_PREFIX}${actionDefinitionKey}`
            };
        }
    };
}
/**
 * Method ensures that definitions for custom columns are created for passed entitySet.
 * @param {object} appSchema App schema in general
 * @param {object} manifest manifest.json of the app
 * @param {string} entitySetName Entity set name.
 * @param {string} entityTypeName Entity type name.
 * @param {ConverterOutput} oDataServiceAVT Complete service information, as returned by annotation vocabularies tool
 * @param {FacetConfig} facet information
 * @param {string} facetKey - key of the facet, as listed in FacetConfigs
 * @param {FileData[]} [fragments] Array with XML fragments.
 * @return {string} Name of custom columns definition.
 */
function ensureCustomColumnDefinitionExists(appSchema, manifest, entitySetName, entityTypeName, oDataServiceAVT, facet, facetKey, fragments) {
    let suffix, customColumnsDefinitionName;
    if (facet.ID && facet.Label) {
        suffix = facet.ID + facet.Label.replace(/\s+/g, '');
    }
    else if (facet.ID) {
        suffix = facet.ID;
    }
    else if (facet.Label) {
        suffix = facet.Label.replace(/\s+/g, '');
    }
    if (suffix) {
        customColumnsDefinitionName = `${common_1.DefinitionName.CustomColumns}<${entitySetName}><${facetKey}><${suffix}>`;
    }
    else {
        customColumnsDefinitionName = `${common_1.DefinitionName.CustomColumns}<${entitySetName}><${facetKey}>`;
    }
    if (appSchema.definitions[customColumnsDefinitionName]) {
        // Definition is already created - we do not need to create it again
        return customColumnsDefinitionName;
    }
    // Create type specific 'TableCustomColumn' definition - use entity set as type.
    const customColumnDefinitionName = `${common_1.DefinitionName.CustomColumn}<${entitySetName}>`;
    const customColumnDefinition = JSON.parse(JSON.stringify(appSchema.definitions['TableCustomColumn']));
    appSchema.definitions[customColumnDefinitionName] = customColumnDefinition;
    // Update definitions for type specific custom columns
    const pageKeys = [];
    const entityType = oDataServiceAVT.entityTypes.find((et) => et.name === entityTypeName);
    const v2Page = import_1.findObjectPageV2(manifest[common_2.ManifestSection.generic].pages, entitySetName, pageKeys);
    utils_1.addTableColumnExtensions(appSchema, entityType, v2Page, manifest, fragments, customColumnsDefinitionName, customColumnDefinitionName);
    return customColumnsDefinitionName;
}
/**
 * Method fills new app schema section with properties.
 * @param {Definition} appSchema App schema in general
 * @param {object} appSchemaSection app schema section to be filled
 * @param {FacetConfig} facet facet or section information
 * @param {SectionTypeV2} sectionType (sub)section type
 * @param {SectionTypeV2} mainSectionType main section type, used to fill app schema section
 */
function addAppSchemaDefinition(appSchema, appSchemaSection, facet, sectionType, mainSectionType) {
    appSchemaSection['properties'] = JSON.parse(JSON.stringify(appSchema.definitions[mainSectionType]['properties']));
    if (appSchemaSection['properties'].visible) {
        addFlexChangeForSection(appSchema, appSchemaSection, 'visible', sectionType);
    }
}
/**
 * Method adds reference to section property key.
 * @param {object} sections - schema of current sections definition
 * @param {string} key section key which will contain the reference
 * @param {string} definitionKey key which the section should point to
 */
function addSectionReference(sections, key, definitionKey) {
    sections['properties'][key] = { $ref: `${common_1.DEFINITION_LINK_PREFIX}${definitionKey}` };
}
/**
 * Reuse function for all table types, copies and adapts the generic definition
 * @param tableType - Table type
 * @param facetId - facet ID, as derived for the given section
 * @param facet - facet or section information
 * @param appSchema - app-specific schema, to be updated
 */
function addTableDefinition(tableType, facetId, facet, appSchema) {
    const schemaId = common_1.prepareRef(`${tableType}<${facetId}>`);
    appSchema.definitions[schemaId] = JSON.parse(JSON.stringify(appSchema.definitions[tableType]));
    appSchema.definitions[schemaId]['properties']['columns']['$ref'] = common_1.DEFINITION_LINK_PREFIX + facetId;
    appSchema.definitions[schemaId].properties.toolBar['$ref'] = `${common_1.DEFINITION_LINK_PREFIX}ObjectPageToolBar<${facetId}>`;
    appSchema.definitions[schemaId]['annotationPath'] = facet.annotationPath;
    if (facet.ID !== undefined) {
        appSchema.definitions[schemaId].title = common_1.FacetTitlePrefix + facet.ID;
    }
    appSchema.definitions[schemaId].description = common_1.DefinitionName.Table;
    //adjust quickVariantSelection
    appSchema.definitions[schemaId].properties['quickVariantSelection']['$ref'] = `${common_1.DEFINITION_LINK_PREFIX}QuickVariantSelectionOP<${facetId}>`;
    appSchema.definitions[`QuickVariantSelectionOP<${facetId}>`] = JSON.parse(JSON.stringify(appSchema.definitions['QuickVariantSelectionOP']));
    appSchema.definitions[`QuickVariant<${facetId}>`] = JSON.parse(JSON.stringify(appSchema.definitions['QuickVariant']));
    appSchema.definitions[`QuickVariantSelectionOP<${facetId}>`].properties.variants.patternProperties['^[0-9]+$']['$ref'] = `${common_1.DEFINITION_LINK_PREFIX}QuickVariant<${facetId}>`;
    common_1.addEnumForSingleTabVariant(facet.entityType, appSchema, `QuickVariant<${facetId}>`);
}
/**
 * Adds definitions for line items in object page sections to the app schema
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {string} facetKey - key of the facet, as listed in FacetConfigs
 * @param {Definition} appSchema - app schema in general
 * @param {FacetConfig} facet - the given facet from the UI annotations
 * @param {FacetConfigs} facets - list of all facets
 * @param {SectionTypeV2} sectionType (sub)section type
 */
function handleLineItem(generateParameters, facetKey, appSchema, facet, facets, sectionType) {
    if (facet.base !== 'LineItem' || !facetKey) {
        //no properties
        return;
    }
    const navigationProperty = facetKey.split('::')[0];
    const schemaIdForOpSection = `${sectionType}<${facetKey}>`;
    appSchema.definitions[schemaIdForOpSection] = common_1.createSectionWithoutProperties(facet, facetKey);
    const appSchemaSection = appSchema.definitions[schemaIdForOpSection];
    addAppSchemaDefinition(appSchema, appSchemaSection, facet, sectionType, types_1.SectionTypeV2.SectionTable);
    appSchemaSection.properties.table = JSON.parse(JSON.stringify(appSchema.definitions[types_1.SectionTypeV2.SectionTable]['properties']['table']));
    appSchemaSection.properties.table.anyOf = [
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageResponsiveTableWithMultiSelect<${facetKey}>`
        },
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageResponsiveTableWithInlineDelete<${facetKey}>`
        },
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageAnalyticalTable<${facetKey}>`
        },
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageGridTable<${facetKey}>`
        },
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageTreeTable<${facetKey}>`
        }
    ];
    appSchemaSection['annotationPath'] = facet.annotationPath;
    common_1.addSectionTitleAndDescription(facet, appSchemaSection, facetKey);
    addTableDefinition('ObjectPageResponsiveTableWithMultiSelect', facetKey, facet, appSchema);
    addTableDefinition('ObjectPageResponsiveTableWithInlineDelete', facetKey, facet, appSchema);
    addTableDefinition('ObjectPageGridTable', facetKey, facet, appSchema);
    addTableDefinition('ObjectPageTreeTable', facetKey, facet, appSchema);
    addTableDefinition('ObjectPageAnalyticalTable', facetKey, facet, appSchema);
    let customColumnDefinitionKey;
    // Find target entity
    const targetEntitySet = common_1.determineEntitySetOfFacet(facet, generateParameters.serviceAVT);
    if (targetEntitySet) {
        // Make sure that custom columns definitions are created for passed entity
        customColumnDefinitionKey = ensureCustomColumnDefinitionExists(appSchema, generateParameters.manifest, targetEntitySet.name, facet.entityType.name, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT, facet, facetKey, generateParameters.fragments);
    }
    for (const facetItem in facets) {
        if (facets[facetItem].base === 'LineItem' && facetItem.includes(navigationProperty)) {
            utils_1.addLineItemsType(appSchema, facets[facetItem].target, facets[facetItem].entityType, facetItem, customColumnDefinitionKey);
        }
    }
}
/**
 * Adds definitions for subsections in object page sections to the app schema
 * @param {Definition} appSchema - app schema in general
 * @param {string} definitionKey - key of app schema definition to be filled
 * @param {FacetConfig} facet facet or section information
 * @param {string} facetId - key of the facet, as listed in FacetConfigs
 * @param {SectionTypeV2} sectionType (sub)section type
 */
function handleSubSection(appSchema, definitionKey, facet, facetId, sectionType) {
    appSchema.definitions[definitionKey] = common_1.createSectionWithoutProperties(facet, facetId);
    const appSchemaSection = appSchema.definitions[definitionKey];
    addAppSchemaDefinition(appSchema, appSchemaSection, facet, sectionType, types_1.SectionTypeV2.SubSection);
    appSchemaSection.properties.subsections = {
        type: 'object',
        description: 'Subsections',
        properties: {},
        additionalProperties: false
    };
    appSchemaSection.properties.subsections['isViewNode'] = true;
}
/**
 * Method fills new chart section with properties.
 * @param {Definition} appSchema App schema in general
 * @param {string} definitionKey - key of app schema definition to be filled
 * @param {FacetConfig} facet facet or section information
 * @param {string} facetKey - facet key.
 * @param {SectionTypeV2} sectionType (sub)section type
 */
function handleSectionChart(appSchema, definitionKey, facet, facetKey, sectionType) {
    appSchema.definitions[definitionKey] = common_1.createSectionWithoutProperties(facet, facetKey);
    const appSchemaSection = appSchema.definitions[definitionKey];
    addAppSchemaDefinition(appSchema, appSchemaSection, facet, sectionType, types_1.SectionTypeV2.SectionChart);
}
/**
 * Method fills new form section in app schema with properties.
 * @param {Definition} appSchema App schema in general
 * @param {string} definitionKey - key of app schema definition to be filled
 * @param {FacetConfig} facet facet or section information
 * @param {string} facetKey - facet key.
 * @param {SectionTypeV2} sectionType (sub)section type
 * @return {object} returns filled form section in app schema.
 */
function handleAppSchemaFormSection(appSchema, definitionKey, facet, facetKey, sectionType) {
    appSchema.definitions[definitionKey] = common_1.createSectionWithoutProperties(facet, facetKey);
    const appSchemaSection = appSchema.definitions[definitionKey];
    addAppSchemaDefinition(appSchema, appSchemaSection, facet, sectionType, types_1.SectionTypeV2.SectionForm);
    appSchemaSection['annotationPath'] = facet.annotationPath;
    appSchemaSection['isViewNode'] = true;
    return appSchemaSection;
}
/**
 * Mapping of facet type to (sub)section type to enable correct further handling
 * @param {FacetBase} facetType - facet type to be mapped
 * @param {boolean} isSubSection - if section is subsection of section
 * @return {SectionTypeV2} sectionType (sub)section type
 */
function getSectionType(facetType, isSubSection) {
    const sectionTypeMapping = new Map([
        [v2_1.FacetBase.CollectionFacet, types_1.SectionTypeV2.Section],
        [v2_1.FacetBase.LineItem, types_1.SectionTypeV2.SectionTable],
        [v2_1.FacetBase.Chart, types_1.SectionTypeV2.SectionChart],
        [v2_1.FacetBase.Form, types_1.SectionTypeV2.SectionForm],
        [v2_1.FacetBase.Identification, types_1.SectionTypeV2.SectionForm]
    ]);
    const subSectionTypeMapping = new Map([
        [v2_1.FacetBase.CollectionFacet, types_1.SectionTypeV2.SubSection],
        [v2_1.FacetBase.LineItem, types_1.SectionTypeV2.SubSectionTable],
        [v2_1.FacetBase.Chart, types_1.SectionTypeV2.SubSectionChart],
        [v2_1.FacetBase.Form, types_1.SectionTypeV2.SubSectionForm],
        [v2_1.FacetBase.Identification, types_1.SectionTypeV2.SubSectionForm]
    ]);
    if (isSubSection) {
        return subSectionTypeMapping.get(facetType);
    }
    else {
        return sectionTypeMapping.get(facetType);
    }
}
/**
 * Method returns reference key, special handling of (sub)sections
 * @param {FacetConfig} facet facet or section information
 * @param {string} facetKey - facet key.
 * @param {SectionTypeV2} sectionType (sub)section type
 * @return {string} reference key
 */
function getReferenceKey(facet, facetKey, sectionType) {
    let referenceKey = facetKey;
    if (sectionType === (types_1.SectionTypeV2.Section || types_1.SectionTypeV2.SubSection)) {
        referenceKey = referenceKey.replace(`@${"com.sap.vocabularies.UI.v1.Facets" /* Facets */}`, facet.base);
    }
    return `${referenceKey}`;
}
/**
 * Creates a section definition in app schema.
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {FacetConfigs} facets - list of all facets.
 * @param {string} facetKey - facet key.
 * @param {object} sections - schema of current sections definition.
 * @param {Definition} appSchema - app specific schema that potentially gets enhanced.
 * @param {boolean} isSubSection - if section is subsection of section
 */
function addSection(generateParameters, facets, facetKey, sections, appSchema, isSubSection = false) {
    const facet = facets[facetKey];
    const sectionType = getSectionType(facet.base, isSubSection);
    const referenceKey = getReferenceKey(facet, facetKey, sectionType);
    const definitionKey = `${sectionType}<${referenceKey}>`;
    addSectionReference(sections, referenceKey, definitionKey);
    switch (sectionType) {
        case types_1.SectionTypeV2.Section:
        case types_1.SectionTypeV2.SubSection: {
            //handle collection facets
            isSubSection = true;
            handleSubSection(appSchema, definitionKey, facet, facetKey, sectionType);
            const subSections = appSchema.definitions[definitionKey].properties
                .subsections;
            for (const key in facet['facets']) {
                addSection(generateParameters, facet['facets'], key, subSections, appSchema, isSubSection);
            }
            break;
        }
        case types_1.SectionTypeV2.SectionTable:
        case types_1.SectionTypeV2.SubSectionTable: {
            handleLineItem(generateParameters, facetKey, appSchema, facet, facets, sectionType);
            //add fields for createWithParameterDialog
            const floorplanSuffix = 'OP';
            common_1.addFieldsType(appSchema, facet.entityType, floorplanSuffix);
            break;
        }
        case types_1.SectionTypeV2.SectionChart:
        case types_1.SectionTypeV2.SubSectionChart: {
            //handle reference facet (if comprising chart)
            handleSectionChart(appSchema, definitionKey, facet, facetKey, sectionType);
            break;
        }
        case types_1.SectionTypeV2.SectionForm:
        case types_1.SectionTypeV2.SubSectionForm: {
            const withActions = facet.base !== v2_1.FacetBase.Identification;
            const appSchemaSection = handleAppSchemaFormSection(appSchema, definitionKey, facet, facetKey, sectionType);
            common_1.handleForm(v2_1.SectionType.Section, facet, appSchemaSection, appSchema, common_2.FioriElementsVersion.v2, withActions);
            break;
        }
        default: {
            // Other facets -> no properties
            sections.properties[facetKey] = common_1.createSectionWithoutProperties(facet, facetKey);
        }
    }
}
/**
 * Adds the sections to the app schema
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {Definition} appSchema - app specific schema that potentially gets enhanced
 * @param {EntityType} entityType - current entity type
 * @param {string} entitySetName Entity set name
 * @param {SapUiAppPagesV2} pages - list of (manifest) pages
 */
function addSections(generateParameters, appSchema, entityType, entitySetName, pages) {
    //initialize sections
    appSchema.definitions['Sections'] = {
        type: 'object',
        properties: {},
        description: 'Sections',
        additionalProperties: false
    };
    const sections = appSchema.definitions['Sections'];
    sections['isViewNode'] = true;
    if (entityType) {
        sections['annotationPath'] = `/${entityType.fullyQualifiedName}/@${"com.sap.vocabularies.UI.v1.Facets" /* Facets */}`;
    }
    if (!pages) {
        return;
    }
    // Get facet annotations
    const facets = common_1.getObjectPageFacets(entityType, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT, common_2.FioriElementsVersion.v2, generateParameters.logger);
    if (!facets || Object.keys(facets).length === 0) {
        return;
    }
    // Loop on all pages, look for the right entity set
    for (const key in pages) {
        const element = pages[key];
        if (entitySetName.includes(element.entitySet)) {
            // Loop on all facets (of the given entitySet)
            for (const facetKey in facets) {
                addSection(generateParameters, facets, facetKey, sections, appSchema);
            }
        }
        else {
            addSections(generateParameters, appSchema, entityType, entitySetName, element.pages);
        }
    }
    // Add custom sections
    for (const name in appSchema.definitions['CustomSections']['properties']) {
        sections.properties[name] = appSchema.definitions['CustomSections'].properties[name];
    }
}
/**
 * Add Object Page Header to app-specific schema
 *
 * @param {object} appSchema Schema of the app
 * @param {EntityType} entityType - current entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 */
function addHeader(appSchema, entityType, oDataServiceAVT) {
    common_1.addCommonHeaderSchema(appSchema, entityType);
    //Add header actions
    common_1.addHeaderActions(appSchema, entityType, oDataServiceAVT, addHeaderActionCallBackV2);
}
/**
 * Adds the related facets keys 'enum' to the app schema
 * @param schema - app specific schema that potentially gets enhanced
 * @param {EntityType} entityType - current entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function addRelatedFacetKeysType(schema, entityType, oDataServiceAVT, logger) {
    // Find sections from annotation
    // And create new definition in schema as enum with description
    const facetSections = common_1.getObjectPageFacetSection(entityType, oDataServiceAVT, logger, undefined, true);
    if (facetSections) {
        common_1.addDefinitionForRelatedFacetKeys(schema, ['ObjectPageCustomSectionFragment', 'ObjectPageCustomSectionView'], facetSections, ['ID', 'key']);
    }
}
/**
 * Generates an app specific schema out of the generic schema.
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param genericSchema - generic JSON schema of an object page
 * @param entityTypeName - the base entity type of the given page
 *
 * @returns the app specific JSON schema
 */
function generateObjectPageSchemaV2(generateParameters, genericSchema, entityTypeName) {
    // Initialize i18next
    i18n_1.initI18n();
    const appSchema = JSON.parse(JSON.stringify(genericSchema));
    // Custom sections as part of sections
    const additionalSections = {};
    for (const name in appSchema.definitions['CustomSections']['properties']) {
        additionalSections[name] = appSchema.definitions['CustomSections'].properties[name];
    }
    // Change reference to generated sections
    appSchema.properties['sections'] = {
        $ref: common_1.DEFINITION_LINK_PREFIX + 'Sections'
    };
    const entitySet = (generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT.entitySets) && (generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT.entitySets.find((es) => es.entityType.name === entityTypeName || es.name === entityTypeName));
    if (!entitySet) {
        extensionLogger_1.log(generateParameters.logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOENTITYSET4NAME', { entityType: entityTypeName }),
            location: {
                path: common_1.METADATAPATH
            }
        });
        return appSchema;
    }
    const entityType = entitySet === null || entitySet === void 0 ? void 0 : entitySet.entityType;
    const pages = generateParameters.manifest[common_2.ManifestSection.generic].pages;
    if (!pages) {
        extensionLogger_1.log(generateParameters.logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOPAGES', { appId: generateParameters.manifest['sap.app']['id'] }),
            location: {
                path: v2_1.MANIFESTPATH,
                range: [common_2.ManifestSection.generic]
            }
        });
        return appSchema;
    }
    // Add header
    addHeader(appSchema, entityType, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT);
    // Add sections
    addSections(generateParameters, appSchema, entityType, entitySet.name, pages);
    // Custom section facets
    addRelatedFacetKeysType(appSchema, entityType, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT, generateParameters.logger);
    if (!appSchema.definitions['Sections']) {
        if (appSchema.definitions['RelatedFacetKeys'] && appSchema.definitions['RelatedFacetKeys']['oneOf'].length) {
            // If related facets exists - then we need sections definition
            appSchema.definitions['Sections'] = {
                type: 'object',
                properties: additionalSections,
                additionalProperties: false
            };
            appSchema.definitions['Sections']['isViewNode'] = true;
        }
        else {
            delete appSchema.properties['sections'];
        }
    }
    common_1.addFooterActions(appSchema, entityType, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT);
    // Eliminate generic definitions
    delete appSchema.definitions['GenericSections'];
    delete appSchema.definitions['ObjectPageSectionTableV2'];
    delete appSchema.definitions['GenericColumns'];
    delete appSchema.definitions['TableColumnAction'];
    delete appSchema.definitions['ObjectPageSectionFormV2'];
    delete appSchema.definitions['ObjectPageSectionTableV2'];
    delete appSchema.definitions['ObjectPageSubSectionV2'];
    delete appSchema.definitions['ObjectPageResponsiveTableWithMultiSelect'];
    delete appSchema.definitions['ObjectPageResponsiveTableWithInlineDelete'];
    delete appSchema.definitions['ObjectPageAnalyticalTable'];
    delete appSchema.definitions['ObjectPageTreeTable'];
    delete appSchema.definitions['ObjectPageGridTable'];
    delete appSchema.definitions['ObjectPageToolBar'];
    delete appSchema.definitions['ObjectPageToolBarActions'];
    delete appSchema.definitions['ObjectPageForm'];
    delete appSchema.definitions['ObjectPageFormFields'];
    delete appSchema.definitions['ObjectPageFormActions'];
    return appSchema;
}
exports.generateObjectPageSchemaV2 = generateObjectPageSchemaV2;
//# sourceMappingURL=objectPage.js.map