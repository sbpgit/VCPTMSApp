"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../../common");
const decorators_1 = require("../../common/decoration/decorators");
const path_1 = require("path");
const xml_js_1 = require("xml-js");
const types_1 = require("../types");
/**
 * Common function for enhancing the LineItems definiton of app schema by custom columns
 * @param appSchema - app-specific JSON schema
 * @param customColumnsDefinitionName - custom column definition name (plural)
 * @param customColumnDefinitionName - custom column definition name (singular)
 */
function addCustomColumnDefinition(appSchema, customColumnsDefinitionName, customColumnDefinitionName) {
    if (appSchema['definitions']['LineItems']) {
        appSchema['definitions']['LineItems']['properties']['custom'] = {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}${customColumnsDefinitionName}`
        };
    }
    appSchema['definitions'][customColumnsDefinitionName] = {
        type: 'array',
        items: {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}${customColumnDefinitionName}`
        },
        isViewNode: true,
        description: 'Custom Columns'
    };
    const columnDefinition = appSchema['definitions'][customColumnDefinitionName];
    for (const id in columnDefinition.properties) {
        columnDefinition.properties[id].artifactType = common_1.ArtifactType.Manifest;
    }
}
/**
 * Prepares and returns id of action for further use and reference
 * @param actionType - type of action
 * @param lineItemProperties - properties of the line item collection: lineItemPath, lineItemRecord, lineItemId
 * @returns {string} actionId
 */
function getActionId(actionType, lineItemProperties) {
    if (actionType === types_1.ActionTypeV2.ColumnIntentBased) {
        return common_1.getSchemaKeyOfLineItemRecord(lineItemProperties.lineItemRecord);
    }
    else if (actionType === types_1.ActionTypeV2.ToolBarIntentBased || actionType === types_1.ActionTypeV2.FooterIntentBased) {
        return common_1.prepareRef(`${lineItemProperties.lineItemRecord.SemanticObject}::${lineItemProperties.lineItemRecord.Action}`);
    }
    else if (actionType === types_1.ActionTypeV2.Column &&
        lineItemProperties.lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */) {
        return common_1.prepareRef(`DataFieldForAction:::sAction::${lineItemProperties.lineItemRecord.Action}`);
    }
    else {
        return common_1.prepareRef(lineItemProperties.lineItemRecord.Action);
    }
}
/**
 * Processes a LineItem record of type DataFieldForAction and DataFieldForIntentBasedNavigation during app schema generation
 * @param appSchema - the app specific schema that shall get enhanced
 * @param entityType - the entity type as part of the AVT ConverterOutput
 * @param actions - actions definition in schema, parent object
 * @param lineItemProperties - properties of the line item collection: lineItemPath, lineItemRecord, lineItemId
 * @param actionType - type of action
 * @param recordIndex - record index in the collection
 */
function handleActionRecord(appSchema, actions, lineItemProps, actionType, recordIndex) {
    let actionReferenceType;
    const actionTemplate = lineItemProps.lineItemId === 'LineItems' ? '' : 'ObjectPage';
    const actionId = getActionId(actionType, lineItemProps);
    if (actionType === types_1.ActionTypeV2.Footer || actionType === types_1.ActionTypeV2.FooterIntentBased) {
        actionReferenceType = `Action`;
        actionType = types_1.ActionTypeV2.Footer;
    }
    else if (actionType === types_1.ActionTypeV2.Column || actionType === types_1.ActionTypeV2.ColumnIntentBased) {
        actionReferenceType = `TableColumnAction`;
    }
    else {
        actionReferenceType = actionTemplate !== '' ? `${actionTemplate}${actionType}` : `Action`;
        actionType = types_1.ActionTypeV2.ToolBar;
    }
    const actionDefinition = `${actionTemplate}${actionType}<${actionId}>`;
    const description = common_1.getDatafieldDescription(lineItemProps.lineItemRecord, lineItemProps.entityType);
    actions['properties'][actionId] = {
        $ref: common_1.DEFINITION_LINK_PREFIX + actionDefinition,
        description,
        propertyIndex: recordIndex
    };
    if (appSchema['definitions'][actionReferenceType]) {
        appSchema['definitions'][actionDefinition] = Object.assign(Object.assign({}, JSON.parse(JSON.stringify(appSchema['definitions'][actionReferenceType]))), { description, annotationPath: `${lineItemProps.lineItemPath}/${recordIndex}` });
    }
    else {
        appSchema['definitions'][actionDefinition] = {
            type: 'object',
            properties: {},
            description,
            annotationPath: `${lineItemProps.lineItemPath}/${recordIndex}`,
            isViewNode: true,
            additionalProperties: false
        };
    }
}
exports.handleActionRecord = handleActionRecord;
/**
 * Returns the type of a column lineItem action
 * @param lineItemId - optional: in case of OP the parameter must be passed to distinguish the OP tables;
 * @param {object} lineItemRecord - actual record of the line item collection
 * @param actionTypes - array of action types to be filled
 */
function getColumnActionType(lineItemId, lineItemRecord, actionTypes) {
    if (lineItemId !== 'LineItems' &&
        lineItemRecord.Inline === true &&
        (lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */ ||
            lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */)) {
        actionTypes.push(types_1.ActionTypeV2.OPColumn);
    }
    else if (lineItemRecord.Inline === true && lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */) {
        actionTypes.push(types_1.ActionTypeV2.Column);
    }
    else if (lineItemRecord.Inline === true &&
        lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */) {
        actionTypes.push(types_1.ActionTypeV2.ColumnIntentBased);
    }
}
/**
 * Returns the type of a lineItem action
 * @param {object} lineItemRecord - actual record of the line item collection
 * @returns {string[] | undefined } ActionTypeV2[] - action type(s) of the lineItem
 */
function getActionType(lineItemRecord, lineItemId) {
    const actionTypes = [];
    if (lineItemRecord.$Type !== "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */ &&
        lineItemRecord.$Type !== "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */) {
        return undefined;
    }
    if (lineItemRecord.Inline !== true &&
        lineItemRecord.Determining !== true &&
        lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */) {
        actionTypes.push(types_1.ActionTypeV2.ToolBar);
    }
    else if (lineItemRecord.Inline !== true &&
        lineItemRecord.Determining !== true &&
        lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */) {
        actionTypes.push(types_1.ActionTypeV2.ToolBarIntentBased);
    }
    else if (lineItemRecord.Determining === true && lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */) {
        actionTypes.push(types_1.ActionTypeV2.Footer);
    }
    else if (lineItemRecord.Determining === true &&
        lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */) {
        actionTypes.push(types_1.ActionTypeV2.FooterIntentBased);
    }
    getColumnActionType(lineItemId, lineItemRecord, actionTypes);
    return actionTypes;
}
/**
 * Adds the line item records to the app schema (for the list report or an object page section comprising a table)
 * @param appSchema - the app specific schema that shall get enhanced
 * @param lineItemAnnotation - the UI.LineItem annotation, comprising all records
 * @param entityType - the entity type as part of the AVT ConverterOutput
 * @param lineItemId - optional: in case of OP the parameter must be passed to distinguish the OP tables;
 *                      in case of LR or ALP no ID is passed, 'LineItems' is taken then.
 * @param customColumnRef - schema reference to custom column definition.
 */
function addLineItemsType(appSchema, lineItemAnnotation, entityType, lineItemId, customColumnRef) {
    let schemaKey;
    // Add the correct lineItem definition
    lineItemId = lineItemId || 'LineItems';
    const { actions, footerActions, lineItemPath } = common_1.addCommonLineItemDefinitions(appSchema, lineItemAnnotation, entityType, lineItemId);
    if (lineItemAnnotation) {
        let i = 0;
        lineItemAnnotation.forEach((lineItemRecord) => {
            const lineItemProperties = { lineItemPath, lineItemRecord, lineItemId, entityType };
            const actionTypes = getActionType(lineItemRecord, lineItemId);
            function generateGenericColumn() {
                schemaKey = common_1.getSchemaKeyOfLineItemRecord(lineItemRecord);
                if (schemaKey) {
                    appSchema['definitions'][lineItemId]['properties'][schemaKey] = {
                        $ref: common_1.DEFINITION_LINK_PREFIX + common_1.DefinitionName.TableColumn,
                        description: common_1.getDatafieldDescription(lineItemRecord, entityType),
                        // Custom property in schema - for object properties ordering purpose
                        propertyIndex: i,
                        annotationPath: lineItemPath + '/' + i
                    };
                    common_1.addDataTypeToDefinition(appSchema['definitions'][lineItemId]['properties'][schemaKey], lineItemRecord);
                }
            }
            if (actionTypes) {
                actionTypes.forEach((actionType) => {
                    switch (actionType) {
                        case types_1.ActionTypeV2.ToolBar:
                        case types_1.ActionTypeV2.ToolBarIntentBased: {
                            handleActionRecord(appSchema, actions, lineItemProperties, actionType, i);
                            break;
                        }
                        case types_1.ActionTypeV2.Footer:
                        case types_1.ActionTypeV2.FooterIntentBased: {
                            if (footerActions) {
                                handleActionRecord(appSchema, footerActions, lineItemProperties, actionType, i);
                            }
                            break;
                        }
                        case types_1.ActionTypeV2.Column:
                        case types_1.ActionTypeV2.ColumnIntentBased: {
                            handleActionRecord(appSchema, appSchema['definitions'][lineItemId], lineItemProperties, actionType, i);
                            break;
                        }
                        case types_1.ActionTypeV2.OPColumn: {
                            generateGenericColumn();
                        }
                    }
                });
            }
            else {
                generateGenericColumn();
            }
            i++;
        });
    }
    if (customColumnRef) {
        appSchema['definitions'][lineItemId]['properties']['custom'] = {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}${customColumnRef}`
        };
    }
}
exports.addLineItemsType = addLineItemsType;
/**
 * Adds enum entries of possible leading properties for 'leadingProperty' property in TableCustomColumn properties.
 * @param appSchema - the app specific schema that shall get enhanced
 * @param entityType - the entity type as part of the AVT ConverterOutput
 * @param definitionName - definition name of CustomColumn definition
 */
function addListReportLeadingProperties(appSchema, entityType, definitionName) {
    // Leading Property
    const leadingPropertySchema = appSchema['definitions'][definitionName] &&
        appSchema['definitions'][definitionName]['properties'] &&
        appSchema['definitions'][definitionName]['properties']['leadingProperty'];
    if (leadingPropertySchema) {
        const properties = [
            //  Entity properties
            ...((entityType === null || entityType === void 0 ? void 0 : entityType.entityProperties) || []),
            // Navigation Properties
            ...((entityType === null || entityType === void 0 ? void 0 : entityType.navigationProperties) || [])
        ];
        leadingPropertySchema['enum'] = properties === null || properties === void 0 ? void 0 : properties.reduce((result, property) => {
            if (!result.includes(property.name)) {
                result.push(property.name);
            }
            return result;
        }, []);
    }
}
exports.addListReportLeadingProperties = addListReportLeadingProperties;
/**
 * Adds enum entries of posible tabKey properties for 'leadingProperty' property in TableCustomColumn properties.
 * @param appSchema - the app specific schema that shall get enhanced
 * @param definitionName - definition name of CustomColumn definition
 * @param page - sapui5 page object
 */
function addTabkeyEnum(appSchema, definitionName, page) {
    const tabkeyPropertySchema = appSchema['definitions'][definitionName] &&
        appSchema['definitions'][definitionName]['properties'] &&
        appSchema['definitions'][definitionName]['properties']['tabKey'];
    if (page) {
        const quickVariantsX = page.component &&
            page.component.settings &&
            page.component.settings.quickVariantSelectionX &&
            page.component.settings.quickVariantSelectionX['variants'];
        if (quickVariantsX) {
            const enumEntries = [];
            Object.keys(quickVariantsX).reduce((result, variant) => {
                const key = quickVariantsX[variant] && quickVariantsX[variant]['key'] !== undefined
                    ? quickVariantsX[variant]['key']
                    : undefined;
                // Avoid duplicates
                if (key !== undefined && !result.includes(key)) {
                    result.push(key);
                }
                return result;
            }, enumEntries);
            tabkeyPropertySchema['enum'] = enumEntries;
        }
    }
}
exports.addTabkeyEnum = addTabkeyEnum;
/**
 * Adds enum entries of posible fragment entries.
 * @param {object} appSchema The app specific schema that shall get enhanced.
 * @param {FileData[]} fragments Array of fragments.
 * @param {string[]} appId Application id.
 * @param {string} property Property name.
 * @param {string} definitionName Definition name of CustomColumn definition.
 */
function addFragmentEnum(appSchema, fragments, appId, property, definitionName) {
    var _a, _b;
    const fragmentPropertySchema = (_b = (_a = appSchema['definitions'][definitionName]) === null || _a === void 0 ? void 0 : _a['properties']) === null || _b === void 0 ? void 0 : _b[property];
    if (fragments && appId && !appId.startsWith('${')) {
        const enumEntries = [];
        fragments.forEach((fragment) => {
            let relPath = fragment.dataSourceUri.split('webapp')[1];
            if (relPath && relPath.indexOf('.fragment.xml') > 0) {
                const fragmentJson = JSON.parse(xml_js_1.xml2json(fragment.fileContent, { compact: true }))['core:FragmentDefinition'];
                if ((property === 'fragmentName' &&
                    (!fragmentJson || fragmentJson.Column || fragmentJson['table:Column'])) ||
                    (property === 'cellsFragmentName' &&
                        (!fragmentJson ||
                            (!fragmentJson.Column &&
                                !fragmentJson['table:Column'] &&
                                !fragmentJson['smartfilterbar:ControlConfiguration'])))) {
                    relPath = relPath.replace(new RegExp('\\' + path_1.sep, 'g'), '/');
                    const fragmentName = appId + relPath.split('.fragment.xml')[0].replace(/\//g, '.');
                    enumEntries.push(fragmentName);
                }
            }
        });
        if (enumEntries.length > 0) {
            fragmentPropertySchema['enum'] = enumEntries;
        }
    }
}
exports.addFragmentEnum = addFragmentEnum;
/**
 * Adds the custom columns to the line item records of the app schema (for the list report comprising a table).
 * @param {object} appSchema The app specific schema that shall get enhanced.
 * @param {EntityType} entityType The entity type as part of the AVT ConverterOutput.
 * @param {SapUiAppPageV2} page Sapui5 page object.
 * @param {object} manifest Application manifest.
 * @param {FileData[]} [fragments] Array of fragments.
 * @param {string} [customColumnsDefinitionName=DefinitionName.CustomColumns] Definition name of Custom Columns definition.
 * @param {string} [customColumnDefinitionName=DefinitionName.CustomColumn] Definition name of Custom Column definition.
 */
function addTableColumnExtensions(appSchema, entityType, page, manifest, fragments, customColumnsDefinitionName = common_1.DefinitionName.CustomColumns, customColumnDefinitionName = common_1.DefinitionName.CustomColumn) {
    addCustomColumnDefinition(appSchema, customColumnsDefinitionName, customColumnDefinitionName);
    // Leading Property
    addListReportLeadingProperties(appSchema, entityType, customColumnDefinitionName);
    // Tab key property
    addTabkeyEnum(appSchema, customColumnDefinitionName, page);
    // Fragment property
    const appId = manifest && manifest['sap.app'] && manifest['sap.app']['id'];
    addFragmentEnum(appSchema, fragments, appId, 'fragmentName', customColumnDefinitionName);
    addFragmentEnum(appSchema, fragments, appId, 'cellsFragmentName', customColumnDefinitionName);
}
exports.addTableColumnExtensions = addTableColumnExtensions;
/**
 * Processes an anyOf definition of the generic schema
 * @param propertyDefinition - current definition in the generic schema
 * @param schema - the app-specific schema
 * @param propertyKey - key of the single property
 * @param factory - factory for creating metadata instances
 * @param pageType - page type
 */
function processAnyOf(propertyDefinition, schema, propertyKey, factory, pageType) {
    propertyDefinition['anyOf'].forEach((element) => {
        const nextDefinition = common_1.getNextTargetDefinition(schema, '', {}, element, propertyKey, factory, pageType);
        if (nextDefinition) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            processMetadata(schema, nextDefinition.targetDefinition, nextDefinition.configObject, pageType, factory);
        }
    });
}
/**
 * Processes an object reference of the generic schema
 * @param schema
 * @param propertyDefinition - current definition in the generic schema
 * @param propertyKey - key of the single property
 * @param factory - factory for creating metadata instances
 * @param pageType - page type
 */
function processObject(schema, propertyDefinition, propertyKey, factory, pageType) {
    const nextDefinition = common_1.getNextTargetDefinition(schema, '', {}, propertyDefinition, propertyKey, factory, pageType);
    if (nextDefinition) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        processMetadata(schema, nextDefinition.targetDefinition, nextDefinition.configObject, pageType, factory);
    }
}
/**
 * Determines the artifact type of a property and adds it to the property definition in schema
 * @param syncRule - sync rule of the current property
 * @param propertyDefinition - current definition in the generic schema
 */
function addArtifactType(syncRule, propertyDefinition) {
    if (syncRule.manifest !== undefined) {
        propertyDefinition.artifactType = common_1.ArtifactType.Manifest;
    }
    else if (syncRule.flex !== undefined) {
        propertyDefinition.artifactType = common_1.ArtifactType.FlexChange;
        //Add control type
        if (syncRule.flex.controlType) {
            propertyDefinition.controlType = syncRule.flex.controlType();
        }
    }
    else {
        propertyDefinition.artifactType = common_1.ArtifactType.Annotation;
    }
}
/**
 * After the generation of a generic schema, apply post-generation rule to a single property
 * @param metaDataDefinition
 * @param schema - given app schema, to be adapted
 * @param pageType - page type
 * @param factory - factory for creating metadata instances
 * @param propertyDefinition - definition of the single property
 * @param propertyKey - key of the single property
 * @param schemaDefinition - the current entry point or definition in the app schema
 */
function processSingleProperty(metaDataDefinition, schema, pageType, factory, propertyDefinition, propertyKey, schemaDefinition) {
    if (metaDataDefinition) {
        const syncRule = decorators_1.getReflectMetadata(metaDataDefinition, propertyKey);
        if (syncRule) {
            if (typeof syncRule.generate === 'function') {
                syncRule.generate(schema, schemaDefinition, propertyKey);
                propertyDefinition = schemaDefinition['properties'][propertyKey];
            }
            //Add artifact type
            addArtifactType(syncRule, propertyDefinition);
        }
        if (propertyDefinition.type === 'object' || propertyDefinition.$ref) {
            processObject(schema, propertyDefinition, propertyKey, factory, pageType);
        }
        else if (propertyDefinition['anyOf']) {
            processAnyOf(propertyDefinition, schema, propertyKey, factory, pageType);
        }
    }
}
/**
 * After the generation of a generic schema, apply rules to a list of properties of the given schema section
 * @param schema - given app schema, to be adapted
 * @param schemaDefinition - the current entry point or definition in the app schema
 * @param pageType - page type
 * @param factory - factory for creating metadata instances
 */
function processProperties(schema, schemaDefinition, metaDataDefinition, propertiesSection, pageType, factory) {
    if (schemaDefinition[propertiesSection]) {
        for (const propertyKey in schemaDefinition[propertiesSection]) {
            if (propertyKey === 'anyOf') {
                processAnyOf(schemaDefinition[propertiesSection], schema, propertyKey, factory, pageType);
            }
            else {
                const propertyDefinition = schemaDefinition[propertiesSection][propertyKey];
                if (propertyDefinition['anyOf']) {
                    processAnyOf(propertyDefinition, schema, propertyKey, factory, pageType);
                }
                else if (propertyKey === '$ref') {
                    processObject(schema, schemaDefinition[propertiesSection], propertyKey, factory, pageType);
                }
                else {
                    processSingleProperty(metaDataDefinition, schema, pageType, factory, propertyDefinition, propertyKey, schemaDefinition);
                }
            }
        }
    }
}
/**
 * Apply post-processing rules as specified in form of "generate" at the syncRule
 * @param schema - given app schema, to be adapted
 * @param schemaDefinition - the current entry point or definition in the app schema
 * @param pageType - page type
 * @param factory - factory for creating metadata instances
 */
function processMetadata(schema, schemaDefinition, metaDataDefinition, pageType, factory) {
    processProperties(schema, schemaDefinition, metaDataDefinition, 'properties', pageType, factory);
    processProperties(schema, schemaDefinition, metaDataDefinition, 'additionalProperties', pageType, factory);
    processProperties(schema, schemaDefinition, metaDataDefinition, 'patternProperties', pageType, factory);
}
exports.processMetadata = processMetadata;
/**
 * Method updates passed 'enum' array by removing passed matching entries.
 * @param {Array<unknown>} values Array of values.
 * @param {Array<unknown>} valuesToRemove Array of values to remove.
 */
function removeElementsFromEnum(values, valuesToRemove) {
    for (const value of valuesToRemove) {
        const index = values.indexOf(value);
        if (index !== -1) {
            // Value exists - remove it
            values.splice(index, 1);
        }
    }
}
exports.removeElementsFromEnum = removeElementsFromEnum;
/**
 * Adds the selection fields to the app schema, as properties of the Filterbar
 * @param entityType - the entity type as part of the AVT ConverterOutput
 * @param appSchema - the app specific schema that shall get enhanced
 * @param selectionFieldsAnnotation - the UI.SelectionField annotation
 */
function addSelectionFields(appSchema, selectionFieldsAnnotation, entityType) {
    const selectionFieldsDefinition = (appSchema['definitions'].SelectionFields = Object.assign(Object.assign({}, appSchema['definitions'].SelectionFields), { properties: {}, additionalProperties: false, annotationPath: common_1.createAnnotationPath(entityType.fullyQualifiedName, "com.sap.vocabularies.UI.v1.SelectionFields" /* SelectionFields */) }));
    if (!selectionFieldsAnnotation) {
        return;
    }
    let i = 0;
    selectionFieldsAnnotation.forEach((selectionField) => {
        let description = selectionField.value;
        const fieldDefinition = `SelectionField<${common_1.prepareRef(selectionField.value)}>`;
        const dataType = common_1.determineDataType(selectionField);
        if (selectionField.type === 'PropertyPath') {
            description = common_1.getLabelForPropertyPath(selectionField, entityType);
        }
        selectionFieldsDefinition['properties'][selectionField.value] = {
            $ref: common_1.DEFINITION_LINK_PREFIX + fieldDefinition,
            propertyIndex: i
        };
        appSchema['definitions'][fieldDefinition] = {
            type: 'object',
            description,
            annotationPath: `${selectionFieldsDefinition.annotationPath}/${i}`,
            isViewNode: true,
            additionalProperties: false,
            annotationType: selectionField === null || selectionField === void 0 ? void 0 : selectionField.type,
            dataType
        };
        if (['Date', 'DateTime', 'DateTimeOffset'].includes(dataType)) {
            appSchema['definitions'][fieldDefinition]['$ref'] = `${common_1.DEFINITION_LINK_PREFIX}SelectionFieldDateSettings`;
        }
        else {
            appSchema['definitions'][fieldDefinition].properties = {};
        }
        i++;
    });
}
exports.addSelectionFields = addSelectionFields;
//# sourceMappingURL=utils.js.map