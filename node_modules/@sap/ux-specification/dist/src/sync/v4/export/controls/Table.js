"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../../../common");
const decorators_1 = require("../../../common/decoration/decorators");
const application_1 = require("../../application");
/**
 * Special edition of the global function getManifestSectionByPathV4 that initializes the views array if empty
 * @param manifest - manifest.json
 * @param path - path to the views array in manifest
 * @param key - key of the view
 * @returns the paths array of the views
 */
const getManifestSectionByPathV4 = (manifest, path) => {
    let manifestSection = manifest;
    for (const element of path.split('/')) {
        if (!manifestSection[element]) {
            if (element === 'paths') {
                manifestSection[element] = [];
            }
            else {
                manifestSection[element] = {};
            }
        }
        manifestSection = manifestSection[element];
    }
    return manifestSection;
};
/**
 * Common function that calculates the path in manifest for table settings of a list report or ALP table view
 * @param pageName - page name in manifest
 * @param manifest - manifest (not used)
 * @param targetAnnotationEncoded - encoded target annotation (not used)
 * @param viewKey - view key (not used)
 * @param targetAnnotation - target annotation, i.e. the line item (with or without qualifier)
 * @returns - path as string
 */
const getTableSettingsPathForView = (pageName, manifest, targetAnnotationEncoded, viewKey, targetAnnotation) => {
    const annotationEncoded = targetAnnotation.replace(/\//gi, '??');
    return application_1.getControlConfigurationPath(pageName) + `/${annotationEncoded}/tableSettings`;
};
/**
 * Common function for determining the path in manifest of a list report view's path
 * @param pageName - page name in manifest
 * @param manifest - manifest.json
 * @param targetAnnotationEncoded - target annotation (not used here)
 * @param viewKey - value of the key property of the view
 * @returns the path to the entry in manifest
 */
function getSettingsPathForLRViewsPath(pageName, manifest, targetAnnotationEncoded, viewKey) {
    const viewsPath = application_1.getSettingsPathForLRViewsPaths(pageName);
    const manifestSection = getManifestSectionByPathV4(JSON.parse(JSON.stringify(manifest)), viewsPath);
    let path;
    for (let index = 0; index < manifestSection.length; index++) {
        const view = manifestSection[index];
        if (view && view['key'] === viewKey) {
            path = `${viewsPath}/${index}`;
            break;
        }
    }
    if (!path) {
        path = `${viewsPath}/[]`;
    }
    return path;
}
/**
 * sync rule function for export of creationMode.name
 * @param manifestSection - section in manifest comprising the table settings
 * @param configObject - section in config.json describing the table settings
 * @param key - key or property in config.json
 * @param manifestKey - key or property in manifest
 */
function exportCreationModeName(manifestSection, configObject, key, manifestKey) {
    if (typeof manifestSection['creationMode'] === 'object') {
        manifestSection['creationMode'][manifestKey] = configObject[key];
    }
    else if (typeof manifestSection['creationMode'] === 'string') {
        manifestSection['creationMode'] = configObject[key];
    }
}
exports.exportCreationModeName = exportCreationModeName;
/**
 * sync rule function for the deletion of creationMode.name
 * @param manifestSection - section in manifest comprising the table settings
 * @param manifestKey - key or property in manifest
 */
function deleteCreationModeName(manifestSection, manifestKey) {
    if (typeof manifestSection['creationMode'] === 'object' &&
        manifestSection['creationMode'][manifestKey] !== undefined) {
        delete manifestSection['creationMode'][manifestKey];
    }
    else if (typeof manifestSection['creationMode'] === 'string' && manifestSection['creationMode'] !== undefined) {
        delete manifestSection['creationMode'];
    }
}
exports.deleteCreationModeName = deleteCreationModeName;
/**
 * sync rule deleting a view if the annotation path gets deleted
 * @param manifestSection - manifest section of the given view
 */
function deleteView(manifestSection) {
    Object.keys(manifestSection).forEach((key) => delete manifestSection[key]);
}
/**
 * sync rule for preventing the deletion of a property
 */
function doNotDelete() {
    return;
}
/**
 * sync rule function for export of creationMode.createAtEnd
 * @param manifestSection - section in manifest comprising the table settings
 * @param configObject - section in config.json describing the table settings
 * @param key - key or property in config.json
 * @param manifestKey - key or property in manifest
 */
function exportCreationModeCreateAtEnd(manifestSection, configObject, key, manifestKey) {
    if (typeof manifestSection['creationMode'] === 'object') {
        manifestSection['creationMode'][manifestKey] = configObject[key];
    }
    else if (typeof manifestSection['creationMode'] === 'string') {
        // If createionAtEnd property is defined in config, then we have to convert manifest property creationMode to an object
        manifestSection['creationMode'] = {
            name: configObject['name'],
            [manifestKey]: configObject[key]
        };
    }
}
exports.exportCreationModeCreateAtEnd = exportCreationModeCreateAtEnd;
/**
 * sync rule function for the deletion of creationMode.createAtEnd
 * @param manifestSection - section in manifest comprising the table settings
 * @param manifestKey - key or property in manifest
 */
function deleteCreationModeCreateAtEnd(manifestSection, manifestKey) {
    if (typeof manifestSection['creationMode'] === 'object' &&
        manifestSection['creationMode'][manifestKey] !== undefined) {
        delete manifestSection['creationMode'][manifestKey];
    }
}
exports.deleteCreationModeCreateAtEnd = deleteCreationModeCreateAtEnd;
/**
 * sync rule for the import of creationMode, does an implicit conversion of the former string value to the new object representation
 * @param tableSettings - table settings in manifest, to be analyzed
 * @returns - object rpresenting the value(s) for the config file
 */
function importCreationMode(tableSettings) {
    const value = tableSettings['creationMode'];
    if (typeof value === 'object') {
        return value;
    }
    else if (typeof value === 'string') {
        return {
            name: value
        };
    }
}
/**********************************
 * Sync class for TableCreationMode
 */
class TableCreationMode {
}
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getTableSettingsPathForLR(entitySet),
            export: (manifestSection, configObject, key, manifestKey) => {
                exportCreationModeName(manifestSection, configObject, key, manifestKey);
            },
            delete: (manifestSection, configObject, key, manifestKey) => {
                deleteCreationModeName(manifestSection, manifestKey);
            }
        }
    })
], TableCreationMode.prototype, "name", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getTableSettingsPathForLR(entitySet),
            export: (manifestSection, configObject, key, manifestKey) => {
                exportCreationModeCreateAtEnd(manifestSection, configObject, key, manifestKey);
            },
            delete: (manifestSection, configObject, key, manifestKey) => {
                deleteCreationModeCreateAtEnd(manifestSection, manifestKey);
            }
        }
    })
], TableCreationMode.prototype, "createAtEnd", void 0);
exports.TableCreationMode = TableCreationMode;
/**********************************
 * Sync class for TableCreationMode
 */
class ViewTableCreationMode {
}
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getTableSettingsPathForView,
            export: (manifestSection, configObject, key, manifestKey) => {
                exportCreationModeName(manifestSection, configObject, key, manifestKey);
            },
            delete: (manifestSection, configObject, key, manifestKey) => {
                deleteCreationModeName(manifestSection, manifestKey);
            }
        }
    })
], ViewTableCreationMode.prototype, "name", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getTableSettingsPathForView,
            export: (manifestSection, configObject, key, manifestKey) => {
                exportCreationModeCreateAtEnd(manifestSection, configObject, key, manifestKey);
            },
            delete: (manifestSection, configObject, key, manifestKey) => {
                deleteCreationModeCreateAtEnd(manifestSection, manifestKey);
            }
        }
    })
], ViewTableCreationMode.prototype, "createAtEnd", void 0);
exports.ViewTableCreationMode = ViewTableCreationMode;
/****************************************
 * Sync class for QuickVariantSelectionV4
 */
class QuickVariantSelectionV4 {
}
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getTableSettingsPathForLR(entitySet) + common_1.QUICKVARPATH
        }
    })
], QuickVariantSelectionV4.prototype, "paths", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getTableSettingsPathForLR(entitySet) + common_1.QUICKVARPATH
        }
    })
], QuickVariantSelectionV4.prototype, "hideTableTitle", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getTableSettingsPathForLR(entitySet) + common_1.QUICKVARPATH
        }
    })
], QuickVariantSelectionV4.prototype, "showCounts", void 0);
exports.QuickVariantSelectionV4 = QuickVariantSelectionV4;
/****************************************
 * Sync class for TableSettings
 */
class TableSettings {
}
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getTableSettingsPathForLR(entitySet)
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableSettings.prototype, "type", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: application_1.getTableSettingsPathForLR,
            import: importCreationMode
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableSettings.prototype, "creationMode", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getTableSettingsPathForLR(entitySet)
        }
    }),
    decorators_1.validity({
        since: '1.86.0'
    })
], TableSettings.prototype, "personalization", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getTableSettingsPathForLR(entitySet)
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableSettings.prototype, "selectionMode", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getTableSettingsPathForLR(entitySet)
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableSettings.prototype, "selectAll", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getTableSettingsPathForLR(entitySet)
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableSettings.prototype, "selectionLimit", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getTableSettingsPathForLR(entitySet)
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableSettings.prototype, "enableExport", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getTableSettingsPathForLR(entitySet)
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableSettings.prototype, "quickVariantSelection", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getTableSettingsPathForLR(entitySet)
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableSettings.prototype, "condensedTableLayout", void 0);
exports.TableSettings = TableSettings;
/****************************************
 * Sync class for ALPChartView (renamed due to indirection in app schema)
 */
class ALPChart {
}
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getSettingsPathForPage(entitySet) + '/views/paths/0/primary/0',
            delete: deleteView
        }
    })
], ALPChart.prototype, "annotationPath", void 0);
exports.ALPChart = ALPChart;
/****************************************
 * Sync class for view table settings
 */
class TableViewSettings {
}
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getTableSettingsPathForView
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableViewSettings.prototype, "type", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getTableSettingsPathForView,
            import: importCreationMode
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableViewSettings.prototype, "creationMode", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getTableSettingsPathForView
        }
    }),
    decorators_1.validity({
        since: '1.86.0'
    })
], TableViewSettings.prototype, "personalization", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getTableSettingsPathForView
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableViewSettings.prototype, "selectionMode", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getTableSettingsPathForView
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableViewSettings.prototype, "selectAll", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getTableSettingsPathForView
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableViewSettings.prototype, "selectionLimit", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getTableSettingsPathForView
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableViewSettings.prototype, "enableExport", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getTableSettingsPathForView
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableViewSettings.prototype, "quickVariantSelection", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getTableSettingsPathForView
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], TableViewSettings.prototype, "condensedTableLayout", void 0);
exports.TableViewSettings = TableViewSettings;
/****************************************
 * Sync class for ALPTableView (renamed due to indirection in app schema)
 */
class ALPTable extends TableViewSettings {
}
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getSettingsPathForPage(entitySet) + '/views/paths/0/secondary/0',
            delete: doNotDelete
        }
    })
], ALPTable.prototype, "annotationPath", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getSettingsPathForPage(entitySet)
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], ALPTable.prototype, "initialLoad", void 0);
exports.ALPTable = ALPTable;
/****************************************
 * Sync class for LRChartView
 */
class LRChartView {
}
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getSettingsPathForLRViewsPath,
            delete: deleteView
        }
    })
], LRChartView.prototype, "annotationPath", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getSettingsPathForLRViewsPath
        }
    })
], LRChartView.prototype, "entitySet", void 0);
exports.LRChartView = LRChartView;
/****************************************
 * Sync class for LRTableView
 */
class LRTableView extends TableViewSettings {
}
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getSettingsPathForLRViewsPath,
            delete: deleteView
        }
    })
], LRTableView.prototype, "annotationPath", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getSettingsPathForLRViewsPath
        }
    })
], LRTableView.prototype, "keepPreviousPersonalization", void 0);
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: getSettingsPathForLRViewsPath
        }
    })
], LRTableView.prototype, "entitySet", void 0);
exports.LRTableView = LRTableView;
/**
 * LR mulit-view: own class for properties on views' level
 */
class MultiTableModeV4 {
}
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getSettingsPathForPage(entitySet) + '/views'
        }
    })
], MultiTableModeV4.prototype, "showCounts", void 0);
exports.MultiTableModeV4 = MultiTableModeV4;
/****************************************
 * Sync class for Table
 */
class Table extends TableSettings {
}
__decorate([
    decorators_1.syncRule({
        manifest: {
            path: (entitySet) => application_1.getSettingsPathForPage(entitySet)
        }
    }),
    decorators_1.validity({
        since: '1.84.0'
    })
], Table.prototype, "initialLoad", void 0);
exports.Table = Table;
//# sourceMappingURL=Table.js.map