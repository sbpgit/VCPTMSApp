"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../../common");
const application_1 = require("../application");
const manifest_1 = require("./manifest");
const flexibleColumnLayout_1 = require("./flexibleColumnLayout");
const v4_1 = require("../../../v4");
const utils_1 = require("../../common/utils");
const factory_1 = require("./factory");
/**
 * Return the skeleton of a exportResultManifest's "sap.ui.generic.app" entry, prefilled with some values
 * @param name - name of the template, e.g. "sap.suite.ui.generic.template.ObjectPage"
 * @param entitySet - the main entity set
 * @param navigationProperty - navigation property
 */
const getV4ManifestPageTemplate = (name, entitySet) => {
    const V4Page = {
        type: 'Component',
        id: '',
        name: name,
        options: {
            settings: {
                entitySet: entitySet,
                navigation: {},
                controlConfiguration: {}
            }
        }
    };
    return V4Page;
};
const defaultExportResult = {
    flexChanges: [],
    manifest: {
        'sap.ui5': {
            flexEnabled: true,
            routing: {
                targets: {}
            }
        },
        'sap.app': {}
    },
    fragments: []
};
/**
 * Applies the sync rule for a flex change during eport
 * @param syncRule - export rule from the object classes decorator
 * @param transferParameters - list of parameters passed from API
 * @param ids - list of parent & child ids
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param configObject - current (sub)object of the configuration file
 * @param key - key of the given property
 */
function exportFlexChange(syncRule, transferParameters, ids, breadcrumbs, configObject, key) {
    const controlId = syncRule.flex.controlId(transferParameters.baseId, ids, breadcrumbs, syncRule.flex.controlType, transferParameters.title);
    const flexChange = common_1.fillFlexChangeContent(configObject, syncRule, transferParameters.ui5Version, key, controlId);
    transferParameters.exportResults.flexChanges.push(syncRule.flex.createFlexChange(flexChange, transferParameters.exportResults.manifest));
}
/**
 * Determines the target annotation that is relevant for the sync rule
 * @param {string[]} ids - list of ids of parent elements
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @param { [key: string]: any } configObject - the given config.json, to be exported
 * @returns { targetAnnotationEncoded, targetAnnotation, custom }
 */
function determineTargetAnnotation(ids, transferParameters, configObject) {
    var _a, _b, _c;
    let targetAnnotation = '', targetAnnotationEncoded = '', custom = false, annoPath;
    if (ids[0] === 'table' && transferParameters.templateType === utils_1.TemplateType.AnalyticalListPageV4) {
        if (ids.length > 1) {
            annoPath = transferParameters.appSchema.definitions[v4_1.DefinitionName.ALPTable]['annotationPath'];
            targetAnnotationEncoded = targetAnnotation = annoPath.substr(annoPath.lastIndexOf('@'));
        }
        else {
            //table level
            targetAnnotationEncoded = targetAnnotation = `@${(_a = configObject.table) === null || _a === void 0 ? void 0 : _a.annotationPath}`;
        }
    }
    else if (ids[0] === 'chart' && transferParameters.templateType === utils_1.TemplateType.AnalyticalListPageV4) {
        if (ids.length > 1) {
            annoPath = transferParameters.appSchema.definitions[v4_1.DefinitionName.ALPChart]['annotationPath'];
            targetAnnotationEncoded = targetAnnotation = annoPath === null || annoPath === void 0 ? void 0 : annoPath.substr(annoPath.lastIndexOf('@'));
        }
        else {
            //chart level
            targetAnnotationEncoded = targetAnnotation = `@${(_b = configObject.chart) === null || _b === void 0 ? void 0 : _b.annotationPath}`;
        }
    }
    else if (ids[0] === 'sections') {
        if (ids[1] === 'custom' && ids[2] !== ids[ids.length - 1]) {
            custom = true;
            targetAnnotationEncoded = ids[2];
            targetAnnotation = targetAnnotationEncoded.replace(/::/g, '/');
        }
        else {
            targetAnnotationEncoded = ids[1] && ids[1].replace(/\//g, '::');
            targetAnnotation = targetAnnotationEncoded.replace(/::/g, '/');
        }
    }
    else if (ids[1] === 'sections') {
        //header sections
        targetAnnotation = targetAnnotationEncoded =
            transferParameters.title && transferParameters.title.indexOf(v4_1.FacetTitlePrefix) > -1
                ? transferParameters.title.split(v4_1.FacetTitlePrefix)[1]
                : targetAnnotationEncoded.replace(/::/g, '/');
    }
    else if (ids[1] === 'views') {
        const parentDefinition = transferParameters.appSchema.definitions['MultiTableModeV4'].properties[ids[2]];
        if (ids.length === 3) {
            //the parent definition comprises the annotation of the visualization of the (Selection)PresentationVariant.
            targetAnnotation = targetAnnotationEncoded =
                parentDefinition['annotationPath'] &&
                    parentDefinition['annotationPath'].substr(parentDefinition['annotationPath'].lastIndexOf('@'));
        }
        else if (ids.length > 3) {
            //the own definitio comprises the lineItem or chart annotation from he visualization
            const ownDefinitionName = (_c = parentDefinition.$ref) === null || _c === void 0 ? void 0 : _c.split(utils_1.DEFINITION_LINK_PREFIX)[1];
            const ownDefinition = ownDefinitionName && transferParameters.appSchema.definitions[ownDefinitionName];
            const annotation = (ownDefinition === null || ownDefinition === void 0 ? void 0 : ownDefinition['annotationPath']) &&
                ownDefinition['annotationPath'].substr(ownDefinition['annotationPath'].lastIndexOf('@'));
            targetAnnotation = targetAnnotationEncoded = ownDefinition['navigationProperty']
                ? `${ownDefinition['navigationProperty']}/${annotation}`
                : annotation;
        }
    }
    return { targetAnnotationEncoded, targetAnnotation, custom };
}
/**
 * Calculates an additional key for the sync rule from the given ID's
 * @param {string[]} ids - list of ids of parent elements
 * @returns the key for the sync rule
 */
function determineKeyForSyncRule(ids) {
    let idIndex = 0;
    for (let index = ids.length - 1; index > -1; index--) {
        const element = ids[index];
        if (element === 'columns' || element === 'actions' || element === 'views') {
            idIndex = index + 1;
            break;
        }
    }
    return idIndex > 0 ? ids[idIndex] : undefined;
}
/**
 * Transfers a property value from config to manifest
 * @param propertyDefinition - schema definiton of a particular property
 * @param nextDefinition - schema definition referred by $ref
 * @param {SyncRule} syncRule - syncRule (metadata)
 * @param manifestSection - actual section n manifest.json
 * @param { [key: string]: any } configObject - the given config.json, to be exported
 * @param {string} configPropertyKey - key of property in the config
 * @param manifestKey - key in manifest (might be different from propertyKey)
 * @param syncRuleKey - specific key, calculated for the export handler
 */
function transferPropertyToManifest(propertyDefinition, nextDefinition, syncRule, manifestSection, configObject, configPropertyKey, manifestKey, syncRuleKey) {
    const exportHandler = syncRule.manifest.export;
    if (!(propertyDefinition['type'] !== 'array' &&
        nextDefinition &&
        nextDefinition['targetDefinition'].type === 'object' &&
        nextDefinition['targetDefinition'].properties)) {
        if (exportHandler !== false) {
            if (exportHandler && typeof exportHandler === 'function') {
                exportHandler(manifestSection, configObject, configPropertyKey, manifestKey, syncRuleKey);
            }
            else if (Array.isArray(configObject[configPropertyKey]) && !configObject[configPropertyKey].length) {
                delete manifestSection[manifestKey];
            }
            else {
                manifestSection[manifestKey] = configObject[configPropertyKey];
            }
        }
    }
    else if (propertyDefinition['type'] !== 'array' && manifestSection[manifestKey] === undefined) {
        if (exportHandler && typeof exportHandler === 'function') {
            exportHandler(manifestSection, configObject, configPropertyKey, manifestKey, syncRuleKey);
        }
        else {
            manifestSection[manifestKey] = {};
        }
    }
}
/**
 * Transfers a change in config.json to manifest
 * @param ids - list of parent & child ids
 * @param {SyncRule} syncRule - syncRule (metadata)
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @param {string} configPropertyKey - key of property in the config
 * @param { [key: string]: any } configObject - the given config.json, to be exported
 * @param propertyDefinition - schema definiton of a particular property
 * @param nextDefinition - schema definition referred by $ref
 */
function exportManifestChange(ids, syncRule, transferParameters, configPropertyKey, configObject, propertyDefinition, nextDefinition) {
    //eliminate subsections' hierarchy
    let index = ids.indexOf('subsections');
    while (index > -1) {
        ids.splice(index - 1, 2);
        index = ids.indexOf('subsections');
    }
    const { targetAnnotationEncoded, targetAnnotation, custom } = determineTargetAnnotation(ids, transferParameters, configObject);
    const syncRuleKey = determineKeyForSyncRule(ids);
    const path = syncRule.manifest.path(transferParameters.pageNameArray, transferParameters.exportResults.manifest, targetAnnotationEncoded, syncRuleKey, targetAnnotation);
    const manifestSection = common_1.getManifestSectionByPathV4(transferParameters.exportResults.manifest, path, targetAnnotation, custom ? undefined : targetAnnotationEncoded);
    const manifestKey = syncRule.manifest.key || configPropertyKey;
    if (configObject[configPropertyKey] !== undefined) {
        // In case of arrays we take over complete array
        transferPropertyToManifest(propertyDefinition, nextDefinition, syncRule, manifestSection, configObject, configPropertyKey, manifestKey, syncRuleKey);
    }
    else if (syncRule.manifest.delete) {
        const deleteHandler = syncRule.manifest.delete;
        if (typeof deleteHandler === 'function') {
            deleteHandler(manifestSection, configObject, configPropertyKey, manifestKey);
        }
    }
    else if (manifestSection[manifestKey] !== undefined) {
        delete manifestSection[manifestKey];
    }
    utils_1.deleteEmptyStructure(transferParameters.exportResults.manifest, path, targetAnnotation, targetAnnotationEncoded);
}
/**
 * Evaluates an export rule for a property or object, transfers to flex change or manifest setting
 * @param transferParameters - list of parameters passed from API
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param key - key of the given property
 * @param configObject - current (sub)object of the configuration file
 * @param ids - list of parent & child ids
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param propertyDefinition - schema definiton of a particular property
 * @param nextDefinition - schema definition referred by $ref
 */
function evaluateExportRule(transferParameters, breadcrumbs, key, configObject, ids, propertyDefinition, nextDefinition) {
    const syncRule = common_1.getReflectMetadata(configObject, key);
    if (syncRule) {
        if (syncRule.flex) {
            exportFlexChange(syncRule, transferParameters, ids, breadcrumbs, configObject, key);
        }
        else if (syncRule.manifest) {
            exportManifestChange(ids, syncRule, transferParameters, key, configObject, propertyDefinition, nextDefinition);
        }
    }
}
function transferSubObject(propertyDefinition, nextDefinition, currentConfigObject, breadcrumbs, key, transferParameters, ids, localIdParts) {
    let objects = [], isArray = false;
    if (propertyDefinition.$ref && nextDefinition) {
        objects.push(nextDefinition.configObject);
    }
    else if (propertyDefinition['anyOf']) {
        objects.push(currentConfigObject);
    }
    else if (propertyDefinition.type === 'array') {
        objects = currentConfigObject;
        isArray = true;
    }
    else {
        objects.push(currentConfigObject);
    }
    for (const innerObject of objects) {
        const additionalIds = [];
        if (breadcrumbs[0] === 'sections' && key === 'custom' && isArray) {
            // We need add custom section 'id' into breadcrumbs to retrieve correct path to manifest
            additionalIds.push(innerObject['id']);
        }
        transferParameters.title = nextDefinition.title;
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        transferManifestEntriesAndFlexChange(transferParameters, innerObject, [...ids, ...additionalIds], localIdParts, [...breadcrumbs, key], nextDefinition.targetDefinition);
    }
}
/**
 * Creates an ALP 'views' entry in the resulting manifest if not yet existing yet.
 * Adds the secondary = table view if missing.
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @param configObject - current object in config.json
 * @returns
 * - a boolean indicating that the views entry got created.
 * - a boolean infcating if the processing of sub-objects shall be stopped
 **/
function createALPTableView(transferParameters, configObject, key) {
    let newElementCreated = false;
    if (!configObject[key] || Object.keys(configObject[key]).length === 0 || !configObject.chart) {
        return { newElementCreated, stopProcessing: true };
    }
    const path = application_1.getSettingsPathForPage(transferParameters.pageNameArray) + `/views`;
    const views = common_1.getManifestSectionByPathV4(transferParameters.exportResults.manifest, path);
    if (!views['paths'] || Object.keys(views['paths']).length === 0) {
        views['paths'] = [
            {
                secondary: [
                    {
                        annotationPath: configObject[key].annotationPath
                    }
                ]
            }
        ];
        newElementCreated = true;
    }
    else if (!views['paths'][0].secondary) {
        views['paths'][0].secondary = [
            {
                annotationPath: configObject[key].annotationPath
            }
        ];
        newElementCreated = true;
    }
    return { newElementCreated, stopProcessing: false };
}
/**
 * Creates an ALP 'views' entry in the resulting manifest if not yet existing yet
 * Adds the primary = chart view if missing.
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @param configObject - current object in config.json
 * @returns
 * - a boolean indicating that the views entry got created.
 * - a boolean infcating if the processing of sub-objects shall be stopped
 */
function createALPChartView(transferParameters, configObject, key) {
    let newElementCreated = false;
    if (!configObject[key] || Object.keys(configObject[key]).length === 0) {
        return { newElementCreated, stopProcessing: true };
    }
    const path = application_1.getSettingsPathForPage(transferParameters.pageNameArray) + `/views`;
    const views = common_1.getManifestSectionByPathV4(transferParameters.exportResults.manifest, path);
    if (!views['paths'] || Object.keys(views['paths']).length === 0) {
        views['paths'] = [
            {
                primary: [
                    {
                        annotationPath: configObject[key].annotationPath
                    }
                ]
            }
        ];
        newElementCreated = true;
    }
    else if (!views['paths'][0].primary) {
        views['paths'][0].primary = [
            {
                annotationPath: configObject[key].annotationPath
            }
        ];
        newElementCreated = true;
    }
    if (!views['paths'][0].secondary) {
        views['paths'][0].secondary = [
            {
                annotationPath: 'com.sap.vocabularies.UI.v1.LineItem'
            }
        ];
    }
    return { newElementCreated, stopProcessing: false };
}
/**
 * Creates an LR 'views' entry in the resulting manifest if not yet existing yet.
 * Adds the current table view if missing.
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @param configObject - current object in config.json
 * @returns a boolean indicating that the views entry got created.
 */
function createLRTableView(transferParameters, key, configObject) {
    if (!configObject || Object.keys(configObject).length === 0) {
        return false;
    }
    let newElementCreated = false;
    const path = application_1.getSettingsPathForPage(transferParameters.pageNameArray) + `/views`;
    const views = common_1.getManifestSectionByPathV4(transferParameters.exportResults.manifest, path);
    if (!views['paths'] || Object.keys(views['paths']).length === 0) {
        views['paths'] = [
            {
                key: key,
                annotationPath: configObject.annotationPath
            }
        ];
        newElementCreated = true;
    }
    else if (!views['paths'].find((view) => view.key === key)) {
        views['paths'].push({
            key: key,
            annotationPath: configObject.annotationPath
        });
        newElementCreated = true;
    }
    return newElementCreated;
}
/**
 * Special logic to create new elements in manifest
 * @param definitionName - schema definition name of the current object
 * @param key - key of the current object
 * @param configObject - current object in config.json
 * @param breadcrumbs - array of sequence of properties that we are currently processing. Required for instance for table column name
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @returns newElementCreated - boolean value to indicate that a new element was created ==> no further sync rule on this level
 */
function createNewElement(definitionName, key, configObject, breadcrumbs, transferParameters) {
    let newElementCreated = false;
    const stopProcessing = false;
    if (definitionName === v4_1.DefinitionName.ALPChartView && key === 'chart' && configObject) {
        return createALPChartView(transferParameters, configObject, key);
    }
    else if (definitionName === v4_1.DefinitionName.ALPTableView && key === 'table' && configObject) {
        return createALPTableView(transferParameters, configObject, key);
    }
    else if (key && ((definitionName === null || definitionName === void 0 ? void 0 : definitionName.startsWith('LRTableView')) || (definitionName === null || definitionName === void 0 ? void 0 : definitionName.startsWith('LRChartView')))) {
        newElementCreated = createLRTableView(transferParameters, key, configObject[key]);
    }
    return { newElementCreated, stopProcessing };
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills exportResultManifest entries and flex changes
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @param configObject - current object to traverse
 * @param parentIds - array of collected parent ids
 * @param stableIdParts - list of parts of the stable ID for flex changes
 * @param breadcrumbs - array of sequence of properties that we are currently processing. Required for instance for table column name
 * @param schemaDefinition - the current entry point or definition in the app schema
 * @param title - the title to be used for the given schema definition
 */
function transferManifestEntriesAndFlexChange(transferParameters, configObject, parentIds, stableIdParts, breadcrumbs, schemaDefinition) {
    var _a;
    let currentConfigObject;
    if (!(schemaDefinition === null || schemaDefinition === void 0 ? void 0 : schemaDefinition['properties'])) {
        return;
    }
    //Sort, if there is a propertyIndex, so that the exported list ends up in manifest in the right order
    let sortedList = Object.entries(schemaDefinition['properties']);
    if (sortedList) {
        if ((_a = sortedList[0]) === null || _a === void 0 ? void 0 : _a[1]['propertyIndex']) {
            sortedList = Object.entries(schemaDefinition['properties']).sort((a, b) => a[1]['propertyIndex'] - b[1]['propertyIndex']);
        }
        sortedList.forEach((element) => {
            var _a;
            const key = element[0];
            currentConfigObject = configObject[key];
            const childId = common_1.getChildId(configObject, key);
            const propertyDefinition = element[1];
            const nextDefinition = utils_1.getNextTargetDefinition(transferParameters.appSchema, transferParameters.title, currentConfigObject, propertyDefinition, key, transferParameters.factory, transferParameters.pageType);
            const definitionInSchema = (_a = propertyDefinition.$ref) === null || _a === void 0 ? void 0 : _a.split(utils_1.DEFINITION_LINK_PREFIX)[1];
            const { newElementCreated, stopProcessing } = createNewElement(definitionInSchema, key, configObject, breadcrumbs, transferParameters);
            const ids = childId ? [...parentIds, childId] : [...parentIds, key];
            if (!newElementCreated) {
                evaluateExportRule(transferParameters, breadcrumbs, key, configObject, ids, propertyDefinition, nextDefinition);
            }
            if (propertyDefinition &&
                (typeof currentConfigObject === 'object' || (propertyDefinition.$ref && nextDefinition.configObject)) &&
                !stopProcessing) {
                const localIdParts = childId ? [...stableIdParts, childId] : stableIdParts;
                transferSubObject(propertyDefinition, nextDefinition, currentConfigObject, breadcrumbs, key, transferParameters, ids, localIdParts);
            }
        });
    }
}
/**
 * Instantiates the export classes for a single object page section
 * @param sectionId - Current section ID
 */
function getClassesForSingleSection(objectPageConfig, sectionId, factory) {
    if (sectionId === 'custom' && Array.isArray(objectPageConfig.sections[sectionId])) {
        // Custom sections
        const customSections = objectPageConfig.sections
            .custom;
        for (let index = 0; index < customSections.length; index++) {
            customSections[index] = factory.createInstance(v4_1.PageType.ObjectPage, 'ObjectPageCustomSectionView', customSections[index], customSections[index].className);
        }
    }
}
/**
 * Recursive sub-function for handling subsections
 * @param section - Object page section in config
 */
function getSubsectionClasses(section, factory) {
    if (section['subsections']) {
        let subSection;
        for (const subSectionId in section['subsections']) {
            subSection = section['subsections'][subSectionId];
            getClassesForSingleSection(subSection, subSectionId, factory);
            getSubsectionClasses(subSection, factory);
        }
    }
}
/**
 * Instantiates the export classes for the object page section
 * @param objectPageConfig - the given object page configuration
 * @param objectPage - the overall object page export class where the sections shall be included
 */
function getExportClassesForSections(objectPageConfig, objectPage, factory) {
    let section;
    for (const sectionId in objectPageConfig.sections) {
        section = objectPage.sections[sectionId];
        getClassesForSingleSection(objectPageConfig, sectionId, factory);
        getSubsectionClasses(section, factory);
    }
}
/**
 * Run through the given ObjectPage config and return respective exportResultManifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param objectPageConfig - content of the src/ObjectPage_<entity_set>.json file
 * @param manifest - manifest of the application
 * @param pageName - routing target defined in manifest
 */
const exportObjectPage = (exportParameters, ui5Version) => {
    var _a;
    const exportResults = defaultExportResult;
    exportResults.manifest = JSON.parse(JSON.stringify(exportParameters.manifest));
    const factory = new factory_1.MetadataInstanceFactoryV4();
    const objectPage = factory.createPageInstance(v4_1.PageType.ObjectPage, exportParameters.page.config);
    const pageLayoutInformation = common_1.getPageLayoutInformation(objectPage);
    const pageName = exportParameters.page.name;
    const baseId = `${exportParameters.appId}::${pageLayoutInformation.id}::${pageName}--`;
    if ((_a = exportParameters.page.config) === null || _a === void 0 ? void 0 : _a['sections']) {
        getExportClassesForSections(exportParameters.page.config, objectPage, factory);
    }
    const transferParameters = {
        exportResults,
        appId: exportParameters.appId,
        appRootPath: exportParameters.appRootPath,
        baseId,
        appSchema: exportParameters.jsonSchema,
        ui5Version,
        factory,
        pageNameArray: [pageName],
        pageType: v4_1.PageType.ObjectPage,
        title: undefined,
        templateType: utils_1.TemplateType.ListReportObjectPageV4
    };
    transferManifestEntriesAndFlexChange(transferParameters, objectPage, [], //no parentIds
    [], // no stableIds
    [], // no breadcrumbs
    exportParameters.jsonSchema //starting point for target definition
    );
    return exportResults;
};
/**
 * Run through the given List Page (LR or ALP) config and return respective exportResultManifest entry and flex changes
 * @param {ExportListReportV4Parameters} exportParameters - all API parameters needed for the export
 * @param config - content of the config file
 * @param {PageTypeV4} - pageType - Page type
 * @param ui5Version - SAP UI5 version
 */
const exportListPage = (exportParameters, factory, config, pageType, ui5Version, templateType) => {
    var _a;
    const exportResults = defaultExportResult;
    exportResults.manifest = JSON.parse(JSON.stringify(exportParameters.manifest));
    config.table = factory.createInstance(pageType, v4_1.DefinitionName.Table, config.table);
    if (((_a = config.table.toolBar) === null || _a === void 0 ? void 0 : _a.actions) && exportParameters.jsonSchema['definitions']['Actions<LineItems>']) {
        for (const actionKey in exportParameters.jsonSchema['definitions']['Actions<LineItems>'].properties) {
            config.table.toolBar.actions[actionKey] = factory.createInstance(pageType, 'ToolBarAction', config.table.toolBar.actions[actionKey]);
        }
    }
    const pageLayoutInformation = common_1.getPageLayoutInformation(config);
    const pageName = exportParameters.page.name;
    const baseId = `${exportParameters.appId}::${pageLayoutInformation.id}::${pageName}--`;
    if (!exportResults.manifest[v4_1.ManifestSection.ui5]['routing']['targets'][pageName]) {
        const newV4Page = getV4ManifestPageTemplate(pageLayoutInformation.pageId, pageName);
        exportResults.manifest[v4_1.ManifestSection.ui5]['routing']['targets'][pageName] = newV4Page;
    }
    const transferParameters = {
        exportResults,
        appId: exportParameters.appId,
        appRootPath: exportParameters.appRootPath,
        baseId,
        appSchema: exportParameters.jsonSchema,
        ui5Version,
        factory,
        pageNameArray: [pageName],
        pageType: v4_1.PageType.ListReport,
        title: undefined,
        logger: exportParameters.logger,
        templateType
    };
    transferManifestEntriesAndFlexChange(transferParameters, config, [], //no parentIds
    [], // no stableIds
    [], // no breadcrumbs
    exportParameters.jsonSchema //starting point for target definition
    );
    return exportResults;
};
/**
 * Run through the given ListReport config and return respective exportResultManifest entry and flex changes
 * @param {ExportListReportV4Parameters} exportParameters - all API parameters needed for the export
 * @param ui5Version - SAP UI5 version
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportListReportPage = (exportParameters, ui5Version, templateType) => {
    const factory = new factory_1.MetadataInstanceFactoryV4();
    const listReport = factory.createPageInstance(v4_1.PageType.ListReport, exportParameters.page.config);
    return exportListPage(exportParameters, factory, listReport, v4_1.PageTypeV4.ListReport, ui5Version, templateType);
};
/**
 * Run through the given Analytical List Page config and return respective exportResultManifest entry and flex changes
 * @param {ExportAnalyticalListPageV4Parameters} exportParameters - all API parameters needed for the export
 * @param ui5Version - SAP UI5 version
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 *
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportAnalyticalListPage = (exportParameters, ui5Version) => {
    return exportListReportPage(exportParameters, ui5Version, utils_1.TemplateType.AnalyticalListPageV4);
};
/**
 * API for the export of a V4 app configuration
 * Export means the transfer of the properties and values of the given config to manifest entries or flex changes
 * @param application - V4 application (app.json config file)
 * @param manifest - Manifest of the given app
 * @param jsonSchema - App schema
 *
 * @returns ExportResults = object comprising the updated manifest and a list of flex changes
 */
const exportApplicationV4 = (application, manifest, jsonSchema) => {
    const exportResults = defaultExportResult;
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    const applicationV4 = Object.assign(new application_1.ApplicationV4(), application);
    //transform application settings
    applicationV4.settings = Object.assign(new application_1.AppSettings(), applicationV4.settings);
    for (const key in jsonSchema['definitions']['AppSettings']['properties']) {
        const syncRule = common_1.getReflectMetadata(applicationV4.settings, key);
        if (syncRule && syncRule.manifest) {
            const path = syncRule.manifest.path();
            const manifestSection = common_1.getManifestSectionByPathV4(exportResults.manifest, path);
            if (application['settings'] && application['settings'][key] !== undefined) {
                manifestSection[key] = application['settings'][key];
            }
            else {
                delete manifestSection[key];
            }
            utils_1.deleteEmptyStructure(exportResults.manifest, path);
        }
    }
    //transform routing
    exportResults.manifest[v4_1.ManifestSection.ui5].routing = manifest_1.transformRoutingV4(application['home'], application['pages'], exportResults.manifest);
    // Update FCL data
    flexibleColumnLayout_1.updateFcl(exportResults.manifest[v4_1.ManifestSection.ui5], application);
    return exportResults;
};
/**
 * General API for the export of a V4 config page
 * Export means the transfer of the properties and values of the given config to manifest entries or flex changes
 * @param appId - Application ID
 * @param page - Current page (config)
 * @param manifest - Manifest of the given app
 * @param jsonSchema - App schema
 *
 * @returns ExportResults = object comprising the updated manifest and a list of flex changes
 */
exports.exportPageV4 = (exportParametersV4, ui5Version) => {
    if (exportParametersV4[v4_1.SchemaType.ListReport]) {
        return exportListReportPage(exportParametersV4[v4_1.SchemaType.ListReport], ui5Version, utils_1.TemplateType.ListReportObjectPageV4);
    }
    else if (exportParametersV4[v4_1.SchemaType.ObjectPage]) {
        return exportObjectPage(exportParametersV4[v4_1.SchemaType.ObjectPage], ui5Version);
    }
    else if (exportParametersV4[v4_1.SchemaType.Application]) {
        const { application, manifest, jsonSchema } = exportParametersV4[v4_1.SchemaType.Application];
        return exportApplicationV4(application, manifest, jsonSchema);
    }
    else if (exportParametersV4[v4_1.SchemaType.AnalyticalListPage]) {
        return exportAnalyticalListPage(exportParametersV4[v4_1.SchemaType.AnalyticalListPage], ui5Version);
    }
};
//# sourceMappingURL=export.js.map