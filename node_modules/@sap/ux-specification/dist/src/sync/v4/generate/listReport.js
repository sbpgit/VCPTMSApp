"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils/utils");
const __1 = require("../../..");
const v4_1 = require("../../../v4");
const i18next_1 = __importDefault(require("i18next"));
const extensionLogger_1 = require("../../../extensionLogger");
const common_1 = require("../../common");
/**
 * Adds the selection fields to the app schema, as properties of the Filterbar
 * @param entityType - the entity type as part of the AVT ConverterOutput
 * @param appSchema - the app specific schema that shall get enhanced
 * @param selectionFieldsAnnotation - the UI.SelectionField annotation
 */
function addSelectionFields(entityType, appSchema, selectionFieldsAnnotation) {
    const selectionFieldsDefinition = appSchema['definitions'].SelectionFields;
    selectionFieldsDefinition.additionalProperties = false;
    selectionFieldsDefinition.properties = {};
    selectionFieldsDefinition.annotationPath = common_1.createAnnotationPath(entityType.fullyQualifiedName, "com.sap.vocabularies.UI.v1.SelectionFields" /* SelectionFields */);
    if (!selectionFieldsAnnotation) {
        return;
    }
    let i = 0;
    selectionFieldsAnnotation.forEach((selectionField) => {
        let description = selectionField.value;
        const fieldDefinition = 'SelectionField::' + common_1.prepareRef(selectionField.value);
        if (selectionField.type === 'PropertyPath') {
            description = common_1.getLabelForPropertyPath(selectionField, entityType);
        }
        selectionFieldsDefinition['properties'][fieldDefinition] = {
            $ref: common_1.DEFINITION_LINK_PREFIX + fieldDefinition,
            propertyIndex: i
        };
        const dataType = common_1.determineDataType(selectionField);
        appSchema['definitions'][fieldDefinition] = Object.assign({ type: 'object', properties: {}, description, annotationPath: `${selectionFieldsDefinition.annotationPath}/${i}`, isViewNode: true, additionalProperties: false, annotationType: selectionField === null || selectionField === void 0 ? void 0 : selectionField.type }, (dataType && { dataType }));
        i++;
    });
}
function convertVisualization(visualization, alias) {
    if (!visualization) {
        return;
    }
    if (visualization.startsWith(`@${common_1.UIVOCABULARY}`)) {
        visualization = visualization.replace(common_1.UIVOCABULARY, '@UI');
    }
    else if (!visualization.startsWith(`@${alias}`)) {
        visualization = visualization.replace(visualization.split('.')[0], '@UI');
    }
    return visualization;
}
function defineActions(appSchema, schemaIdForActions, annotations, targetAnnotation, entityType) {
    const actions = (appSchema.definitions[schemaIdForActions] = JSON.parse(JSON.stringify(appSchema.definitions['Actions'])));
    actions.properties = {};
    actions.additionalProperties = false;
    const chartAnnotation = annotations[targetAnnotation === null || targetAnnotation === void 0 ? void 0 : targetAnnotation.split(`${common_1.UIVOCABULARY}.`)[1]];
    if (chartAnnotation && chartAnnotation.Actions) {
        let i = 0;
        chartAnnotation.Actions.forEach((actionRecord) => {
            const actionDefinition = common_1.prepareRef(`${v4_1.DefinitionName.ChartToolBarAction}<${actionRecord.Action}>`);
            const description = common_1.getDatafieldDescription(actionRecord, entityType);
            const prefix = actionRecord.$Type.split(`${common_1.UIVOCABULARY}.`)[1];
            actions['properties'][`${prefix}::${actionRecord.Action}`] = {
                $ref: common_1.DEFINITION_LINK_PREFIX + actionDefinition,
                description,
                propertyIndex: i,
                annotationType: actionRecord.$Type,
                annotationPath: `/${actionRecord.fullyQualifiedName}`
            };
            //as ChartToolBarAction is an empty objec, copy ViewToolBarAction and remove properties
            appSchema['definitions'][actionDefinition] = JSON.parse(JSON.stringify(appSchema['definitions'][v4_1.DefinitionName.ViewToolBarAction]));
            appSchema['definitions'][actionDefinition]['properties'] = {};
            appSchema['definitions'][actionDefinition]['annotationPath'] = actionRecord.fullyQualifiedName;
            i++;
        });
    }
}
/**
 * Finds the right visualization for the given view
 * @param viewKey - view key (primary, secondary, or anything else)
 * @param allVisualizations - list of visualizations for the given (S)PV
 * @param alias - alias definition for the relevant namespace
 * @param namespace - namespace for the UI annotations
 * @returns the value of the first fitting visualization
 */
function findTheRightVisualization(viewKey, allVisualizations, alias, namespace) {
    var _a;
    let visualization, visualizationObject, targetAnnotation;
    if (allVisualizations) {
        if (viewKey === 'primary') {
            visualizationObject = allVisualizations.find((vis) => {
                return vis['value'].indexOf('Chart') > -1;
            });
        }
        else if (viewKey === 'secondary') {
            visualizationObject = allVisualizations.find((vis) => {
                return vis['value'].indexOf('LineItem') > -1;
            });
        }
        else {
            visualizationObject = allVisualizations[0];
        }
        visualization = convertVisualization(visualizationObject === null || visualizationObject === void 0 ? void 0 : visualizationObject['value'], alias);
        if ((_a = visualizationObject === null || visualizationObject === void 0 ? void 0 : visualizationObject['$target']) === null || _a === void 0 ? void 0 : _a.fullyQualifiedName) {
            targetAnnotation = `/${namespace}/${visualizationObject['$target'].fullyQualifiedName.split(namespace)[1]}`;
        }
        else if (visualization) {
            targetAnnotation = `/${namespace}/` + visualization.replace(`UI`, common_1.UIVOCABULARY);
        }
    }
    return { visualization, targetAnnotation };
}
/**
 * The view annotationPath must be analyzed, to find the right target annotation and visualization
 * @param view - given view entry in manifest
 * @param uIAnnotations - annotations of UI namespace of the given entityType
 * @param viewKey - allows to distinguish the different view or visualization types
 * @returns { visualization: string describing the visualization of the annotation,
 *            targetAnnotation: the target annotation behind the visualization }
 */
function analyzeViewAnnotation(view, uIAnnotations, generateParameters, viewKey) {
    var _a;
    let namespace = undefined;
    const annotationInManifest = (_a = view === null || view === void 0 ? void 0 : view['annotationPath']) === null || _a === void 0 ? void 0 : _a.split(`${common_1.UIVOCABULARY}.`)[1];
    const annotationAVT = uIAnnotations[annotationInManifest];
    if (!annotationAVT) {
        return { visualization: undefined, targetAnnotation: undefined, namespace };
    }
    namespace = annotationAVT.fullyQualifiedName.split('@com.sap.vocabularies.UI.v1.')[0];
    const alias = common_1.findAlias(common_1.UIVOCABULARY, generateParameters.serviceAVT);
    if (annotationInManifest.startsWith('PresentationVariant')) {
        const { visualization, targetAnnotation } = findTheRightVisualization(viewKey, annotationAVT.Visualizations, alias, namespace);
        return { visualization, targetAnnotation, namespace };
    }
    else if (annotationInManifest.startsWith('SelectionPresentationVariant')) {
        const { visualization, targetAnnotation } = findTheRightVisualization(viewKey, annotationAVT.PresentationVariant.Visualizations, alias, namespace);
        return { visualization, targetAnnotation, namespace };
    }
    else if (annotationInManifest.startsWith('LineItem')) {
        const visualization = '@UI.LineItem';
        const targetAnnotation = `/${namespace}/@${view['annotationPath']}`;
        return { visualization, targetAnnotation, namespace };
    }
    else if (annotationInManifest.startsWith('Chart')) {
        const visualization = '@UI.Chart';
        const targetAnnotation = `/${namespace}/@${view['annotationPath']}`;
        return { visualization, targetAnnotation, namespace };
    }
}
/**
 * Add ALP views to the app-specific schema
 * @param {Definition} appSchema - app-specific JSON schema
 * @param {Array<Object>} viewsPaths - views' paths' section in the manifest
 * @param {EntityType} entityType - actual entity type of the page's entitySet
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 */
function addALPViews(appSchema, viewsPaths, entityType, generateParameters) {
    var _a, _b, _c, _d;
    const annotations = entityType.annotations.UI;
    //1. Chart View
    const { visualization, targetAnnotation } = analyzeViewAnnotation((_b = (_a = viewsPaths === null || viewsPaths === void 0 ? void 0 : viewsPaths[0]) === null || _a === void 0 ? void 0 : _a['primary']) === null || _b === void 0 ? void 0 : _b[0], annotations, generateParameters, 'primary');
    if (visualization && visualization.indexOf('Chart') > -1) {
        const chartView = appSchema.definitions[v4_1.DefinitionName.ALPChartView];
        appSchema.definitions[v4_1.DefinitionName.ALPChart] = JSON.parse(JSON.stringify(chartView));
        delete appSchema.definitions[v4_1.DefinitionName.ALPChart]['isViewNode'];
        appSchema.definitions[v4_1.DefinitionName.ALPChart]['annotationPath'] = targetAnnotation;
        appSchema.definitions[v4_1.DefinitionName.ALPChart].properties.annotationPath['hidden'] = true;
        delete chartView.properties;
        chartView.additionalProperties = false;
        chartView.description = `Chart (key: primary)`;
        chartView.title = `Chart`;
        chartView.$ref = `${common_1.DEFINITION_LINK_PREFIX}${v4_1.DefinitionName.ALPChart}`;
        const viewAnnotation = viewsPaths[0]['primary'][0].annotationPath.split('com.sap.vocabularies.UI.v1.')[1];
        const pathParts = annotations[viewAnnotation].fullyQualifiedName.split('@');
        chartView['annotationPath'] = `/${pathParts[0]}/@${pathParts[1]}`;
        chartView['artifactType'] = common_1.ArtifactType.Manifest;
        chartView['key'] = 'primary';
    }
    // Copy toolbar
    const schemaIdForActions = `Actions<ALPChart>`;
    appSchema.definitions[v4_1.DefinitionName.ViewChartToolBar].properties.actions['$ref'] =
        common_1.DEFINITION_LINK_PREFIX + schemaIdForActions;
    defineActions(appSchema, schemaIdForActions, annotations, targetAnnotation, entityType);
    //2. Table View
    const { visualization: tableVisualization, targetAnnotation: target } = analyzeViewAnnotation((_d = (_c = viewsPaths === null || viewsPaths === void 0 ? void 0 : viewsPaths[0]) === null || _c === void 0 ? void 0 : _c['secondary']) === null || _d === void 0 ? void 0 : _d[0], annotations, generateParameters, 'secondary');
    const tableDefinitionName = utils_1.alignSchemaWithTemplateType(appSchema, generateParameters);
    const tableDefinition = appSchema.definitions[tableDefinitionName];
    if (tableVisualization) {
        tableDefinition.properties.toolBar['$ref'] = `${common_1.DEFINITION_LINK_PREFIX}${v4_1.DefinitionName.ToolBarLR}`;
        // Switch from generic column to specific definition
        tableDefinition.properties['columns'] = {
            $ref: common_1.DEFINITION_LINK_PREFIX + 'LineItems'
        };
        tableDefinition.properties.annotationPath['hidden'] = true;
    }
    else {
        tableDefinition.properties = {};
    }
    const tableView = appSchema.definitions[v4_1.DefinitionName.ALPTableView];
    appSchema.definitions[v4_1.DefinitionName.ALPTable] = JSON.parse(JSON.stringify(tableView));
    delete appSchema.definitions[v4_1.DefinitionName.ALPTable]['isViewNode'];
    tableView.additionalProperties = false;
    tableView.description = `Table (key: secondary)`;
    tableView.title = `Table`;
    if (tableVisualization) {
        delete tableView.properties;
        tableView.$ref = `${common_1.DEFINITION_LINK_PREFIX}${v4_1.DefinitionName.ALPTable}`;
    }
    else {
        tableView.properties = {};
    }
    tableView['artifactType'] = common_1.ArtifactType.Manifest;
    if (tableVisualization && tableVisualization.indexOf('LineItem') > -1) {
        const annotationTerm = tableVisualization.split('.')[1];
        utils_1.addLineItemsType(appSchema, entityType.annotations.UI[annotationTerm], entityType, generateParameters.serviceAVT);
        appSchema.definitions[v4_1.DefinitionName.ALPTable]['annotationPath'] = target;
        const viewAnnotation = viewsPaths[0]['secondary'][0].annotationPath.split('com.sap.vocabularies.UI.v1.')[1];
        const pathParts = annotations[viewAnnotation].fullyQualifiedName.split('@');
        tableView['annotationPath'] = `/${pathParts[0]}/@${pathParts[1]}`;
        tableView['key'] = 'secondary';
    }
}
function copyTableDefinitions(viewKey, appSchema, targetAnnotation, navPropName) {
    const idForTable = `${v4_1.DefinitionName.LRTableView}<${viewKey}>`;
    appSchema.definitions[idForTable] = JSON.parse(JSON.stringify(appSchema.definitions[v4_1.DefinitionName.LRTableView]));
    delete appSchema.definitions[idForTable]['isViewNode'];
    appSchema.definitions[idForTable]['annotationPath'] = targetAnnotation;
    if (navPropName) {
        appSchema.definitions[idForTable]['navigationProperty'] = navPropName;
    }
    //Copy toolbar
    //const idForToolbar = `${DefinitionName.ToolBar}<${viewKey}>`;
    //appSchema.definitions[idForToolbar] = JSON.parse(JSON.stringify(appSchema.definitions[DefinitionName.ToolBar]));
    appSchema.definitions[idForTable]['properties'].toolBar.$ref = `${common_1.DEFINITION_LINK_PREFIX}${v4_1.DefinitionName.ToolBar}<LineItemsOfView::${viewKey}>`;
    return idForTable;
}
function copyChartDefinitions(viewKey, appSchema, targetAnnotation, navPropName, annotations, entityType) {
    const idForChart = `${v4_1.DefinitionName.LRChartView}<${viewKey}>`;
    appSchema.definitions[idForChart] = JSON.parse(JSON.stringify(appSchema.definitions[v4_1.DefinitionName.LRChartView]));
    delete appSchema.definitions[idForChart]['isViewNode'];
    appSchema.definitions[idForChart]['annotationPath'] = targetAnnotation;
    if (navPropName) {
        appSchema.definitions[idForChart]['navigationProperty'] = navPropName;
    }
    //Copy toolbar
    const idForToolbar = `${v4_1.DefinitionName.ViewChartToolBar}<${viewKey}>`;
    appSchema.definitions[idForToolbar] = JSON.parse(JSON.stringify(appSchema.definitions[v4_1.DefinitionName.ViewChartToolBar]));
    appSchema.definitions[idForChart]['properties'].toolBar.$ref = `${common_1.DEFINITION_LINK_PREFIX}${idForToolbar}`;
    //Copy actions
    const schemaIdForActions = `${v4_1.DefinitionName.Actions}<${viewKey}>`;
    defineActions(appSchema, schemaIdForActions, annotations, targetAnnotation, entityType);
    appSchema.definitions[idForToolbar]['properties']['actions']['$ref'] = `${common_1.DEFINITION_LINK_PREFIX}${schemaIdForActions}`;
    return idForChart;
}
/**
 * Add list report views to the app-specific schema
 * @param {Definition} appSchema - app-specific JSON schema
 * @param {Array<Object>} viewsPaths - views' paths' section in the manifest
 * @param {EntityType} entityType - actual entity type of the page's entitySet
 * @param {EntitySet} entitySet - actual entity set (AVT information)
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 */
function addLRViews(appSchema, viewsPaths, entityType, entitySet, generateParameters) {
    var _a;
    if (!viewsPaths) {
        return;
    }
    const viewsDefinition = appSchema.definitions.MultiTableModeV4;
    for (let index = 0; index < viewsPaths.length; index++) {
        const view = viewsPaths[index];
        if (!view['key']) {
            continue;
        }
        const viewKey = view['key'].replace('#', '::');
        let targetEntityType = entityType;
        let viewEntitySet = entitySet;
        let navPropName = undefined;
        if (view['entitySet'] && view['entitySet'] !== entitySet.name) {
            viewEntitySet = generateParameters.serviceAVT.entitySets.find((es) => {
                return es.name === view['entitySet'];
            });
            targetEntityType = viewEntitySet.entityType;
        }
        const annotations = targetEntityType.annotations.UI;
        const { visualization, targetAnnotation, namespace } = analyzeViewAnnotation(view, annotations, generateParameters, view['key']);
        if (view['entitySet']) {
            navPropName = (_a = entityType.navigationProperties.find((np) => {
                return np.targetTypeName === namespace;
            })) === null || _a === void 0 ? void 0 : _a.name;
        }
        //Add Line item view
        if (visualization && visualization.indexOf('LineItem') > -1) {
            //Copy table
            const idForTable = copyTableDefinitions(viewKey, appSchema, targetAnnotation, navPropName);
            viewsDefinition.properties[viewKey] = {
                $ref: `${common_1.DEFINITION_LINK_PREFIX}${idForTable}`,
                description: `Table View (key: ${viewKey})`,
                title: `Table View (${viewKey})`
            };
            appSchema['definitions'][idForTable].properties.columns = {
                $ref: `${common_1.DEFINITION_LINK_PREFIX}LineItemsOfView::${viewKey}`
            };
            appSchema['definitions'][idForTable].properties.annotationPath['hidden'] = true;
            appSchema['definitions'][idForTable].properties.entitySet['hidden'] = true;
            const annotationTerm = visualization.split('.')[1];
            utils_1.addLineItemsType(appSchema, targetEntityType.annotations.UI[annotationTerm], targetEntityType, generateParameters.serviceAVT, v4_1.DefinitionName.ViewTableColumn, `LineItemsOfView::${viewKey}`);
        }
        else if (visualization && visualization.indexOf('Chart') > -1) {
            //Add Chart view
            const idForChart = copyChartDefinitions(viewKey, appSchema, targetAnnotation, navPropName, annotations, targetEntityType);
            appSchema['definitions'][idForChart].properties.annotationPath['hidden'] = true;
            appSchema['definitions'][idForChart].properties.entitySet['hidden'] = true;
            viewsDefinition.properties[viewKey] = {
                $ref: `${common_1.DEFINITION_LINK_PREFIX}${idForChart}`,
                description: `Chart View (key: ${viewKey})`,
                title: `Chart View (${viewKey})`
            };
        }
        else {
            viewsDefinition.properties[viewKey] = {
                description: `View (key: ${viewKey})`,
                title: `View (${viewKey})`,
                properties: {},
                additionalProperties: false
            };
        }
        viewsDefinition.properties[viewKey]['isViewNode'] = true;
        viewsDefinition.properties[viewKey]['propertyIndex'] = index;
        viewsDefinition.properties[viewKey]['annotationPath'] = namespace
            ? `/${namespace}/@${view['annotationPath']}`
            : undefined;
        viewsDefinition.properties[viewKey]['artifactType'] = common_1.ArtifactType.Manifest;
        viewsDefinition.properties[viewKey]['key'] = viewKey;
    }
}
/**
 * Add views to schema (LR or ALP)
 * @param {Definition} appSchema - app-specific JSON schema
 * @param {SapUiAppPageV4} v4Page - actual page in the manifest
 * @param {EntityType} entityType - actual entity type (AVT information)
 * @param {EntitySet} entitySet - actual entity set (AVT information)
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 */
function addViews(appSchema, v4Page, entityType, entitySet, generateParameters) {
    var _a, _b, _c;
    const viewsPaths = (_c = (_b = (_a = v4Page.options) === null || _a === void 0 ? void 0 : _a.settings) === null || _b === void 0 ? void 0 : _b.views) === null || _c === void 0 ? void 0 : _c.paths;
    if (generateParameters.templateType === common_1.TemplateType.ListReportObjectPageV4) {
        addLRViews(appSchema, viewsPaths, entityType, entitySet, generateParameters);
        appSchema.properties['chart']['hidden'] = true;
    }
    else if (generateParameters.templateType === common_1.TemplateType.AnalyticalListPageV4) {
        addALPViews(appSchema, viewsPaths, entityType, generateParameters);
    }
}
/**
 * Generates an app specific schema for the FE V4 Listreport from the generic schema.
 * Generic types are replaced by information from the app specific annotations.
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param genericSchema  - generic JSON schema of an object page
 * @param {EntitySet} entitySet - entity set (AVT object) that is relevant for the given page
 * @param {string} templateName - allows to distinguish list report from ALP
 *
 * @returns {object} application-specific schema of the list report
 */
function generateListReportSchemaV4(generateParameters, genericSchema, entitySet, templateName) {
    var _a, _b, _c, _d;
    const appSchema = JSON.parse(JSON.stringify(genericSchema));
    const entityType = entitySet === null || entitySet === void 0 ? void 0 : entitySet.entityType;
    const alias = common_1.findAlias(common_1.UIVOCABULARY, generateParameters.serviceAVT);
    //Add selection fields
    const selectionFieldAnnotation = (_b = (_a = entityType === null || entityType === void 0 ? void 0 : entityType.annotations) === null || _a === void 0 ? void 0 : _a[alias]) === null || _b === void 0 ? void 0 : _b.SelectionFields;
    addSelectionFields(entityType, appSchema, selectionFieldAnnotation);
    common_1.addEnumForSingleTabVariant(entityType, appSchema, v4_1.DefinitionName.AnnotationPathAsObject);
    if (generateParameters.templateType === common_1.TemplateType.ListReportObjectPageV4) {
        utils_1.addLineItemsType(appSchema, (_d = (_c = entityType === null || entityType === void 0 ? void 0 : entityType.annotations) === null || _c === void 0 ? void 0 : _c[alias]) === null || _d === void 0 ? void 0 : _d.LineItem, entityType, generateParameters.serviceAVT);
        const tableDefinitionName = utils_1.alignSchemaWithTemplateType(appSchema, generateParameters);
        const tableDefinition = appSchema.definitions[tableDefinitionName];
        tableDefinition.properties.toolBar['$ref'] = `${common_1.DEFINITION_LINK_PREFIX}${v4_1.DefinitionName.ToolBarLR}`;
        // Switch from generic column to specific definition
        tableDefinition.properties['columns'] = {
            $ref: common_1.DEFINITION_LINK_PREFIX + 'LineItems'
        };
    }
    if (generateParameters.manifest) {
        //Find page in targets
        const pages = generateParameters.manifest[__1.ManifestSection.ui5].routing.targets;
        if (!pages) {
            extensionLogger_1.log(generateParameters.logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOPAGES', { appId: generateParameters.manifest['sap.app']['id'] }),
                location: {
                    path: v4_1.MANIFESTPATH,
                    range: [__1.ManifestSection.generic]
                }
            });
            return appSchema;
        }
        const v4Page = utils_1.findPageV4(pages, templateName, entitySet, generateParameters.logger);
        if (!v4Page) {
            return appSchema;
        }
        // Handle LR & ALP views
        addViews(appSchema, v4Page, entityType, entitySet, generateParameters);
    }
    delete appSchema.definitions['GenericColumns'];
    delete appSchema.definitions['Action'];
    return appSchema;
}
exports.generateListReportSchemaV4 = generateListReportSchemaV4;
//# sourceMappingURL=listReport.js.map