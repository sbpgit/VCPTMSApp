"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const appProvider_1 = require("../../../common/appProvider");
const application_1 = require("../../application");
const common_1 = require("../../../common");
const listReport_1 = require("../pages/listReport");
const objectPage_1 = require("../pages/objectPage");
const v4_1 = require("../../../../specification/v4");
const common_2 = require("../../../../specification/common");
const utils_1 = require("../../import/utils");
const schemaAccess_1 = require("../../../../specification/schemaAccess");
const extensionLogger_1 = require("../../../../extensionLogger");
const i18next_1 = __importDefault(require("i18next"));
var Constants;
(function (Constants) {
    Constants["OptionalQuery"] = ":?query:";
    Constants["Component"] = "sap/fe/AppComponent";
    Constants["Namespace"] = "sap.fe.templates";
})(Constants = exports.Constants || (exports.Constants = {}));
// Store controller names which should be handled latelly
const unhandledControllers = [];
// Store route associations
let associations = {};
/**
 * Sort in following way
 * 1. string targets first
 * 2. Then sort targets as array by elements count - from lowest to highest(ASC)
 * @param {SapUi5RoutingRoute} route1 - First instance of router to compare.
 * @param {SapUi5RoutingRoute} route2 - Second instance of router to compare.
 * @return {number} Compare result.
 */
function routesSorter(route1, route2) {
    const target1 = route1.target;
    const target2 = route2.target;
    const isT1Array = Array.isArray(target1);
    const isT2Array = Array.isArray(target2);
    if (isT1Array && isT2Array) {
        return target1.length - target2.length;
    }
    if (!isT1Array && !isT2Array) {
        return 0;
    }
    return !isT1Array ? -1 : 1;
}
/**
 * Method to resolve target and return target name as string.
 * Thing is that we can receive target as array of targets and we need detect which target is unique target in that array.
 * @param {SapUi5RoutingRouteTarget} target - Target to resolve.
 * @param {Array<string>} usedTargets - Array of resolved targets(which means that those targets are not unique anymore).
 * @return {string} Resolved unique target namet.
 */
function resolveTarget(target, usedTargets = []) {
    if (!Array.isArray(target)) {
        return target;
    }
    let targetParts = target;
    for (const usedTarget of usedTargets) {
        targetParts = targetParts.filter((targetPart) => !usedTarget.includes(targetPart));
    }
    return targetParts[0];
}
/**
 * Method which populates object with routings routes associations.
 * @param {SapUi5RoutingRoute} routes - Routing routes.
 * @return {object} Map object of association routes.
 */
function populateAssociations(routes) {
    const routesAssociations = {};
    routes = routes.concat().sort(routesSorter);
    const resolvedTargets = [];
    for (const route of routes) {
        const parts = route.pattern.split(':')[0].split('/');
        let target;
        if (Array.isArray(route.target)) {
            target = resolveTarget(route.target, resolvedTargets);
            resolvedTargets.push(route.target);
        }
        else {
            target = route.target;
        }
        for (const part of parts) {
            const prop = part.split('(')[0];
            routesAssociations[target] = routesAssociations[target] ? `${routesAssociations[target]}.${prop}` : prop;
        }
    }
    return routesAssociations;
}
/**
 * Determines the page type of a routing target
 * @param target - routing target, as defined in manifest
 * @param logger - logger for error messages
 * @param routingTargetId - ID of the routing target
 * @returns the page type
 */
function determinePageType(target, logger, routingTargetId) {
    let pageType;
    if (target['name']) {
        if (target['name'] === v4_1.FE_TEMPLATE_V4_CUSTOM_PAGE) {
            pageType = common_2.PageTypeV4.CustomPage;
        }
        else if (target['name'].endsWith(common_2.PageTypeV4.ListReport) ||
            target['name'].endsWith(common_2.PageTypeV4.AnalyticalListPage)) {
            pageType = common_2.PageTypeV4.ListReport;
        }
        else if (target['name'].endsWith(common_2.PageTypeV4.ObjectPage)) {
            pageType = common_2.PageTypeV4.ObjectPage;
        }
        else {
            pageType = undefined;
        }
    }
    else if ('viewId' in target) {
        pageType = common_2.PageTypeV4.CustomPage;
    }
    else {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('INVALIDTARGETDEFINITION', { target: JSON.stringify(target) }),
            location: {
                path: common_1.MANIFESTPATH,
                range: [`${v4_1.ManifestSection.ui5}/routing/targets/${routingTargetId}`]
            }
        });
        if (target['viewType'] === 'XML' && 'viewName' in target) {
            pageType = common_2.PageTypeV4.CustomPage;
        }
    }
    return pageType;
}
function convertSettingsToConfig(target, pageType, manifest, schemas, logger, page, id, templateType) {
    const schemaId = common_1.generatePageId(page.pageType, page.entitySet, page.navigationProperty, target['viewId'] || (pageType === common_2.PageTypeV4.CustomPage && target['id']));
    if (!schemaId) {
        return;
    }
    // Get the JSON schema for the page. If no page specific schema exists, fall back top the generic schema for the page type
    const jsonSchema = Object.keys(schemas).find((element) => element.includes(schemaId)) ||
        Object.keys(schemas).find((element) => element.includes(schemaId.slice(0, -1))) ||
        Object.keys(schemas).find((element) => element.includes(page.pageType));
    if (jsonSchema) {
        if (page.pageType === common_2.PageTypeV4.ObjectPage) {
            const importParameters = {
                manifest,
                jsonSchema: schemas[jsonSchema],
                routingId: id,
                logger
            };
            page.config = objectPage_1.createObjectPageConfigV4(importParameters);
        }
        else if (templateType === common_1.TemplateType.ListReportObjectPageV4) {
            const importParameters = {
                manifest,
                jsonSchema: schemas[jsonSchema],
                logger
            };
            page.config = listReport_1.createListReportConfig(importParameters, schemaAccess_1.SchemaType.ListReport);
        }
        else if (templateType === common_1.TemplateType.AnalyticalListPageV4) {
            const importParameters = {
                manifest,
                jsonSchema: schemas[jsonSchema],
                logger
            };
            page.config = listReport_1.createListReportConfig(importParameters, schemaAccess_1.SchemaType.AnalyticalListPage);
        }
    }
}
/**
 * Updates the class variable collecting the unhandled controllers
 * @param target - current routing target
 */
function updateUnhandledControllers(target) {
    if ('viewId' in target) {
        // There no 'options' for custom page target -
        //    we need check target's controller source for navigation
        const viewParts = target.viewName.split('.');
        unhandledControllers.push(viewParts[viewParts.length - 1]);
    }
}
/**
 * Determines the Pages(app.json) using routing configuration from manifest and creates the configuration for each page
 * @param manifest - manifest.json of the app
 * @param schemas - list of JSON schemas of all pages
 */
function getPagesAndConfigs(manifest, schemas, templateType, logger) {
    const pages = {};
    const routing = manifest[v4_1.ManifestSection.ui5].routing;
    associations = populateAssociations(routing.routes);
    for (const id in routing.targets) {
        const target = routing.targets[id];
        const pageType = determinePageType(target, logger, id);
        const page = {
            pageType: pageType
        };
        // Entity set
        if (target.options) {
            page.entitySet = target.options.settings.entitySet;
        }
        if (target.controlAggregation) {
            page.controlAggregation = target.controlAggregation;
        }
        if (associations[id] && associations[id].indexOf('.') !== -1) {
            const parts = associations[id].split('.');
            page.navigationProperty = parts[parts.length - 1];
        }
        // Custom page's view object
        if ('viewId' in target) {
            // Populate view of custom page
            page.view = {
                id: target.viewId,
                name: target.viewName
            };
        }
        else if (pageType === common_2.PageTypeV4.CustomPage) {
            const customPageName = target['viewName'];
            page.view = Object.assign(Object.assign({}, (target.id && { id: target.id })), (customPageName && { name: customPageName }));
        }
        // Page navigation object
        // Please note that it is moved to end as in result it would be stringified into 'json' file as last property
        if (target.options) {
            if (target.options.settings.variantManagement) {
                page.variantManagement = target.options.settings.variantManagement;
            }
            page.navigation = {};
            for (const name in target.options.settings.navigation) {
                const navigationRoute = target.options.settings.navigation[name];
                page.navigation[navigationRoute.detail.route] = associations[navigationRoute.detail.route];
            }
        }
        updateUnhandledControllers(target);
        // Get layout from route
        const route = routing.routes.find((routingRoute) => routingRoute.name === 'BookingObjectPage');
        if (route && 'layout' in route) {
            page.defaultLayoutType = route.layout;
        }
        pages[id] = page;
        // convert settings to config
        convertSettingsToConfig(target, pageType, manifest, schemas, logger, page, id, templateType);
    }
    return pages;
}
exports.getPagesAndConfigs = getPagesAndConfigs;
/**
 * Get the id of the page that is to open when the application is started.
 * @param routing UI5 routing configuration
 */
function getHome(routing) {
    let routeHome;
    for (const route of routing.routes) {
        //find the home, i.e. route which starts with ':?query:' pattern for List Report,
        //resp. doesn't contain '/' for Form Page
        if (route.pattern.startsWith(':?query:')) {
            routeHome = route;
            break;
        }
        else if (route.pattern.indexOf('/') === -1) {
            routeHome = route;
            continue;
        }
    }
    return routeHome ? resolveTarget(routeHome.target) : resolveTarget(routing.routes[0].target);
}
/**
 * Method which detects app settings from manifest.
 * Currently only one setting is detected -Flexible Column Layout
 * @param routing UI5 routing configuration.
 * @return {AppSettings} Application settings.
 */
function getSettings(routing) {
    return routing.config && routing.config.flexibleColumnLayout
        ? {
            flexibleColumnLayout: routing.config.flexibleColumnLayout
        }
        : undefined;
}
class V4AppProvider extends appProvider_1.AppProvider {
    constructor(manifest, schemas, templateType, logger) {
        // Import settings
        const appSettings = new application_1.AppSettings();
        const schemaFile = common_1.getSchemaFilePath(schemaAccess_1.SchemaType.Application);
        const appSchema = schemas[schemaFile.filename];
        utils_1.transferSettingsOfObject(appSettings, manifest, appSchema['definitions']['AppSettings'], '', []);
        super(manifest, schemas, getHome(manifest[v4_1.ManifestSection.ui5].routing), getPagesAndConfigs(manifest, schemas, templateType, logger), common_2.FioriElementsVersion.v4, Object.assign(Object.assign({}, getSettings(manifest[v4_1.ManifestSection.ui5].routing)), appSettings), logger);
        this.unhandledControllers = unhandledControllers;
    }
}
exports.V4AppProvider = V4AppProvider;
function getPages(manifest, targetName) {
    const routing = manifest[v4_1.ManifestSection.ui5].routing;
    const pages = {};
    for (const id in routing.targets) {
        const v4Page = routing.targets[id];
        if (v4Page['name'] === targetName) {
            pages[id] = v4Page;
        }
    }
    return pages;
}
exports.getPages = getPages;
//# sourceMappingURL=appProvider.js.map