"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../../../../specification/common");
const v4_1 = require("../../../../specification/v4");
const common_2 = require("../../../common");
const utils_1 = require("../utils");
const i18n_1 = require("../../../../i18n/i18n");
const i18next_1 = __importDefault(require("i18next"));
const extensionLogger_1 = require("../../../../extensionLogger");
const factory_1 = require("../../export/factory");
/**
 * Imports the content of annotation-based as well as custom columns
 * @param {ListReportConfig | AnalyticalListPageConfig} config - the configuration to be filled
 * @param {ImportListReportV4Parameters} importParameters  - object comprising all input data
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @param {PageTypeV4} pageType - page type
 * @param {SapUiAppPageV4} page - page in manifest
 */
function transferColumns(config, importParameters, factory, pageType, routingId) {
    config.table.columns = {};
    const lineItems = importParameters.jsonSchema['definitions']['LineItems'];
    if (lineItems) {
        for (const columnKey in lineItems.properties) {
            const column = importParameters.jsonSchema['definitions']['LineItems'].properties[columnKey];
            const schemaPropertyName = column.$ref.split(common_2.DEFINITION_LINK_PREFIX)[1];
            config.table.columns[columnKey] = factory.createInstance(pageType, schemaPropertyName);
            utils_1.transferSettingsOfObject(config.table.columns[columnKey], importParameters.manifest, importParameters.jsonSchema['definitions'][schemaPropertyName], routingId, [columnKey]);
            if (Object.keys(config.table.columns[columnKey]).length === 0) {
                delete config.table.columns[columnKey];
            }
        }
    }
    else {
        extensionLogger_1.log(importParameters.logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOLINEITEMS')
        });
    }
}
/**
 * Import table toolbar actions of list report
 * @param {ImportListReportV4Parameters} importParameters  - object comprising all input data
 * @param {ListReportConfigV4} config - the configuration to be filled
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @param {SapUiAppPageV4} page - page in manifest
 * @param {PageTypeV4} pageType - page type
 */
function importActions(importParameters, config, factory, pageType, routingId) {
    if (importParameters.jsonSchema['definitions']['Actions<LineItems>']) {
        for (const actionKey in importParameters.jsonSchema['definitions']['Actions<LineItems>'].properties) {
            config.table.toolBar.actions[actionKey] = factory.createInstance(pageType, 'ToolBarAction');
            const action = actionKey.split('DataFieldForAction::')[1];
            utils_1.transferSettingsOfObject(config.table.toolBar.actions[actionKey], importParameters.manifest, importParameters.jsonSchema['definitions'][`ToolBarAction<${action}>`], routingId, [actionKey]);
            if (Object.keys(config.table.toolBar.actions[actionKey]).length === 0) {
                delete config.table.toolBar.actions[actionKey];
            }
        }
    }
}
/**
 * Import chart & table view of ALP
 * @param {ImportListReportV4Parameters} importParameters  - object comprising all input data
 * @param {ListReportConfigV4} config - the configuration to be filled
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @param {SapUiAppPageV4} page - page in manifest
 * @param {PageTypeV4} pageType - page type
 * @param {string} routingId - page key in manifest
 */
function importALPViews(importParameters, config, factory, pageType, routingId) {
    //chart view
    config.chart = factory.createInstance(pageType, common_2.DefinitionName.ALPChart);
    const chartDefinition = importParameters.jsonSchema['definitions'][common_2.DefinitionName.ALPTable];
    if (chartDefinition.annotationPath) {
        utils_1.transferSettingsOfObject(config.chart, importParameters.manifest, chartDefinition, routingId, [
            chartDefinition.key,
            chartDefinition.annotationPath.substr(chartDefinition.annotationPath.lastIndexOf('@'))
        ]);
    }
    config.chart.toolBar = factory.createInstance(pageType, 'ToolBar', { actions: {} });
    utils_1.transferSettingsOfObject(config.chart.toolBar, importParameters.manifest, importParameters.jsonSchema['definitions'][common_2.DefinitionName.ViewChartToolBar], routingId, []);
    //table view
    config.table = factory.createInstance(pageType, common_2.DefinitionName.ALPTable);
    config.table.toolBar = factory.createInstance(pageType, 'ToolBar', { actions: {} });
    utils_1.transferSettingsOfObject(config.table.toolBar, importParameters.manifest, importParameters.jsonSchema['definitions'][common_2.DefinitionName.ToolBarLR], routingId, []);
    const tableDefinition = importParameters.jsonSchema['definitions'][common_2.DefinitionName.ALPTable];
    if (tableDefinition.annotationPath) {
        utils_1.transferSettingsOfObject(config.table, importParameters.manifest, tableDefinition, routingId, [
            tableDefinition.key,
            tableDefinition.annotationPath.substr(tableDefinition.annotationPath.lastIndexOf('@'))
        ]);
    }
}
/**
 * Import table views of list report
 * @param {ImportListReportV4Parameters} importParameters  - object comprising all input data
 * @param {ListReportConfigV4} config - the configuration to be filled
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @param {PageTypeV4} pageType - page type
 * @param {string} routingId - page key in manifest
 */
function importLRViews(importParameters, config, factory, pageType, routingId) {
    config.table.views = factory.createInstance(pageType, common_2.DefinitionName.MultiTableModeV4);
    const schemaDefinitions = importParameters.jsonSchema['definitions'];
    //Transfer settings on overall views' level
    utils_1.transferSettingsOfObject(config.table.views, importParameters.manifest, schemaDefinitions[common_2.DefinitionName.MultiTableModeV4], routingId, []);
    const properties = schemaDefinitions[common_2.DefinitionName.MultiTableModeV4].properties;
    const sortedList = Object.entries(properties).sort((a, b) => a[1]['propertyIndex'] - b[1]['propertyIndex']);
    for (const element of sortedList) {
        //process single views
        if (element[1]['$ref']) {
            let viewType;
            const nextDefinition = element[1]['$ref'].split(common_2.DEFINITION_LINK_PREFIX)[1];
            if (nextDefinition.indexOf(common_2.DefinitionName.LRTableView) > -1) {
                viewType = common_2.DefinitionName.LRTableView;
            }
            else if (nextDefinition.indexOf(common_2.DefinitionName.LRChartView) > -1) {
                viewType = common_2.DefinitionName.LRChartView;
            }
            else {
                continue;
            }
            config.table['views'][element[0]] = factory.createInstance(pageType, viewType);
            const lineItemAnnotation = schemaDefinitions[nextDefinition].annotationPath;
            let targetAnnotation = lineItemAnnotation.substr(lineItemAnnotation.lastIndexOf('@'));
            if (schemaDefinitions[nextDefinition].navigationProperty) {
                targetAnnotation = `${schemaDefinitions[nextDefinition].navigationProperty}/${targetAnnotation}`;
            }
            utils_1.transferSettingsOfObject(config.table['views'][element[0]], importParameters.manifest, schemaDefinitions[nextDefinition], routingId, [element[0], targetAnnotation]);
            if (Object.keys(config.table['views'][element[0]]).length === 0) {
                delete config.table['views'][element[0]];
            }
        }
    }
}
/**
 * Adds manifest settings to the config.json of LR or ALP V4
 * @param {ImportListReportV4Parameters} importParameters  - object comprising all input data
 * @param {ListReportConfig | AnalyticalListPageConfig} config - the configuration to be filled
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @param {PageTypeV4} pageType - page type
 * @param {string} routingId - page key in manifest
 * @param {SchemaType} schemaType - allows distinction of LR and ALP scenario
 */
function addSettings(importParameters, config, factory, pageType, routingId, schemaType) {
    // Tranfer page level settings with sync rules
    utils_1.transferSettingsOfObject(config, importParameters.manifest, importParameters.jsonSchema, routingId, []);
    //FilterBar:
    config.filterBar = factory.createInstance(pageType, 'FilterBar');
    utils_1.transferSettingsOfObject(config.filterBar, importParameters.manifest, importParameters.jsonSchema['definitions']['FilterBar'], routingId, []);
    //Distinguish ALP table from LR table
    if (schemaType === common_1.SchemaType.ListReport) {
        config.table = factory.createInstance(pageType, common_2.DefinitionName.Table);
        config.table.toolBar = factory.createInstance(pageType, 'ToolBar', { actions: {} });
        utils_1.transferSettingsOfObject(config.table.toolBar, importParameters.manifest, importParameters.jsonSchema['definitions'][common_2.DefinitionName.ToolBarLR], routingId, []);
        utils_1.transferSettingsOfObject(config.table, importParameters.manifest, importParameters.jsonSchema['definitions'][common_2.DefinitionName.Table], routingId, []);
        importLRViews(importParameters, config, factory, pageType, routingId);
    }
    else if (schemaType === common_1.SchemaType.AnalyticalListPage) {
        importALPViews(importParameters, config, factory, pageType, routingId);
    }
    importActions(importParameters, config, factory, pageType, routingId);
    //transfer columns
    transferColumns(config, importParameters, factory, pageType, routingId);
}
exports.addSettings = addSettings;
/**
 * Creates the configuration file content for a list report V4
 * @param {ImportListReportV4Parameters} importParameters  - object comprising all input data
 *
 * @returns {ListReportConfig} - the configuration (JSON) for the list report
 */
function createListReportConfig(importParameters, schemaType) {
    // Initialize i18next
    i18n_1.initI18n();
    if (!importParameters.jsonSchema) {
        return;
    }
    if (!importParameters.manifest[v4_1.ManifestSection.ui5] || !importParameters.manifest[v4_1.ManifestSection.ui5]['routing']) {
        extensionLogger_1.log(importParameters.logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOROUTING'),
            location: {
                path: common_2.MANIFESTPATH,
                range: [v4_1.ManifestSection.ui5]
            }
        });
        return;
    }
    const v4Pages = importParameters.manifest[v4_1.ManifestSection.ui5]['routing']['targets'];
    if (!v4Pages) {
        extensionLogger_1.log(importParameters.logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOTARGETS'),
            location: {
                path: common_2.MANIFESTPATH,
                range: [v4_1.ManifestSection.ui5]
            }
        });
        return;
    }
    const factory = new factory_1.MetadataInstanceFactoryV4();
    //Instantiate Page
    const config = factory.createPageInstance(common_1.PageTypeV4.ListReport);
    for (const key in v4Pages) {
        const v4Page = v4Pages[key];
        const pageType = common_2.getPageTypeV4(v4Page.name);
        if ('name' in v4Page && (pageType === common_1.PageTypeV4.ListReport || pageType === common_1.PageTypeV4.AnalyticalListPage)) {
            addSettings(importParameters, config, factory, common_1.PageTypeV4.ListReport, key, schemaType);
            break;
        }
    }
    return config;
}
exports.createListReportConfig = createListReportConfig;
//# sourceMappingURL=listReport.js.map