"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const v4_1 = require("../../../../specification/v4/");
const common_1 = require("../../../../specification/common");
const utils_1 = require("../utils");
const common_2 = require("../../../common");
const i18next_1 = __importDefault(require("i18next"));
const extensionLogger_1 = require("../../../../extensionLogger");
const i18n_1 = require("../../../../i18n/i18n");
const factory_1 = require("../../export/factory");
/**
 * Fills the section table columns in a V4 config
 * @param {ImportObjectPageV4Parameters} importParameters  - object comprising all input data
 * @param manifestSection - section of the manifest.json
 * @param configPart - the given part of the object page config
 * @param sectionId - converted ID of the given object page section
 * @param manifestSectionId - ID of the given object page section in manifest
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @param v4Page - page definition in V4 format
 */
function fillTableColumnsInConfig(importParameters, manifestSection, configPart, sectionId, manifestSectionId, factory) {
    if (manifestSection['columns']) {
        configPart[sectionId].table.columns = {};
        let tableDefinition;
        const lineItems = importParameters.jsonSchema['definitions'][sectionId.replace(/#/g, '::')];
        if (lineItems) {
            for (const columnKey in lineItems.properties) {
                const columnInSchema = lineItems.properties[columnKey];
                if (columnInSchema.$ref.indexOf(common_2.DefinitionName.CustomColumnOP) > -1) {
                    tableDefinition = common_2.DefinitionName.CustomColumnOP;
                }
                else {
                    tableDefinition = common_2.DefinitionName.ObjectPageTableColumn;
                }
                const columnInConfig = factory.createInstance(common_1.PageTypeV4.ObjectPage, tableDefinition);
                utils_1.transferSettingsOfObject(columnInConfig, importParameters.manifest, importParameters.jsonSchema['definitions'][tableDefinition], importParameters.routingId, [columnKey], manifestSectionId);
                if (Object.keys(columnInConfig).length > 0) {
                    configPart[sectionId].table.columns[columnKey] = columnInConfig;
                }
            }
        }
    }
}
/**
 * Fills the table actions in config.json
 * @param {ImportObjectPageV4Parameters} importParameters  - object comprising all input data
 * @param sectionId - ID of the current section
 * @param configPart - the given part of the object page config
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @param v4Page - current (object) page
 */
function fillTableActionsInConfig(importParameters, sectionId, configPart, factory) {
    if (importParameters.jsonSchema['definitions'][`Actions<${sectionId}>`]) {
        const manifestSectionId = sectionId.replace(/::/g, '/');
        for (const actionKey in importParameters.jsonSchema['definitions'][`Actions<${sectionId}>`].properties) {
            configPart[sectionId].table.toolBar.actions[actionKey] = factory.createInstance(common_1.PageTypeV4.ObjectPage, 'ObjectPageToolBarAction');
            const action = actionKey.split('DataFieldForAction::')[1];
            utils_1.transferSettingsOfObject(configPart[sectionId].table.toolBar.actions[actionKey], importParameters.manifest, importParameters.jsonSchema['definitions'][`ObjectPageToolBarAction<${action}>`], importParameters.routingId, [actionKey], manifestSectionId);
            if (Object.keys(configPart[sectionId].table.toolBar.actions[actionKey]).length === 0) {
                delete configPart[sectionId].table.toolBar.actions[actionKey];
            }
        }
    }
}
/**
 * Fills the table settings in config.json
 * @param {ImportObjectPageV4Parameters} importParameters  - object comprising all input data
 * @param manifestSettings - object page settings section of the manifest
 * @param configPart - the given part of the object page config
 * @param sectionId - ID of the current section
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @param v4Page - current (object) page
 */
function fillTableInConfig(importParameters, manifestSettings, configPart, sectionId, factory) {
    const manifestSectionId = sectionId.replace(/::/g, '/');
    const manifestSection = manifestSettings.controlConfiguration[manifestSectionId];
    if (manifestSection) {
        // Data needs to be transferred
        configPart[sectionId] = {};
        configPart[sectionId].table = factory.createInstance(common_1.PageTypeV4.ObjectPage, 'ObjectPageTable');
        const sectionDefinition = 'ObjectPageTable<' + sectionId + '>';
        utils_1.transferSettingsOfObject(configPart[sectionId].table, importParameters.manifest, importParameters.jsonSchema['definitions'][sectionDefinition], importParameters.routingId, [], manifestSectionId);
        configPart[sectionId].table.toolBar = factory.createInstance(common_1.PageTypeV4.ObjectPage, 'ToolBar', {
            actions: {}
        });
        fillTableActionsInConfig(importParameters, sectionId, configPart, factory);
        fillTableColumnsInConfig(importParameters, manifestSection, configPart, sectionId, manifestSectionId, factory);
    }
}
/**
 * Fills the sections and subsections of the configuration (recursive function)
 * @param {ImportObjectPageV4Parameters} importParameters  - object comprising all input data
 * @param sectionProperties - current properties' list (of sections or subsections)
 * @param manifestSettings - object page settings section of the manifest
 * @param configPart - the given part of the object page config
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @param v4Page - current (object) page
 */
function fillSectionsInConfig(importParameters, sectionProperties, manifestSettings, configPart, factory) {
    for (const sectionId in sectionProperties) {
        const schemaSection = sectionProperties[sectionId];
        if (schemaSection['$ref'] &&
            schemaSection['$ref'].startsWith(common_2.DEFINITION_LINK_PREFIX + 'ObjectPageSectionTableV4')) {
            // Section without subsections
            fillTableInConfig(importParameters, manifestSettings, configPart, sectionId, factory);
        }
        else if (schemaSection['properties'] && schemaSection['properties']['subsections']) {
            configPart[sectionId] = {
                subsections: {}
            };
            fillSectionsInConfig(importParameters, schemaSection['properties']['subsections']['properties'], manifestSettings, configPart[sectionId]['subsections'], factory);
        }
    }
}
/**
 * Fills the header facets in the config file of a V4 object page
 * @param appSchema - app specific schema
 * @param objectPageConfig - configuration, to be enhanced
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @param manifest - manifest.json of the app
 * @param v4Page - current (object) page
 */
function fillHeaderFacets(appSchema, objectPageConfig, factory, manifest, routingId) {
    var _a, _b;
    const headerSections = appSchema['definitions']['HeaderSections'];
    if (headerSections && headerSections.properties) {
        objectPageConfig.header.sections = {};
        for (const sectionId in headerSections.properties) {
            const sectionDefinitionKey = (_a = headerSections.properties[sectionId]['$ref']) === null || _a === void 0 ? void 0 : _a.split(common_2.DEFINITION_LINK_PREFIX)[1];
            const sectionDefinition = sectionDefinitionKey
                ? appSchema['definitions'][sectionDefinitionKey]
                : headerSections.properties[sectionId];
            const factoryKey = sectionDefinitionKey ? sectionDefinitionKey.split('<')[0] : undefined;
            objectPageConfig.header.sections[sectionId] = factoryKey
                ? factory.createInstance(common_1.PageTypeV4.ObjectPage, factoryKey)
                : {};
            utils_1.transferSettingsOfObject(objectPageConfig.header.sections[sectionId], manifest, sectionDefinition, routingId, [], (_b = sectionDefinition === null || sectionDefinition === void 0 ? void 0 : sectionDefinition.title) === null || _b === void 0 ? void 0 : _b.split(common_2.FacetTitlePrefix)[1]);
        }
    }
}
/**
 * Fills the object page configuration from the given manifest
 * @param {ImportObjectPageV4Parameters} importParameters  - object comprising all input data
 * @param v4Page - current (object) page
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @returns {ObjectPageConfig} the object page configuration
 */
function fillObjectPageConfig(importParameters, v4Page, factory) {
    var _a, _b;
    const objectPageConfig = factory.createPageInstance(common_1.PageTypeV4.ObjectPage);
    const manifestSettings = v4Page.options && v4Page.options.settings;
    // Transfer header information
    objectPageConfig.header = factory.createInstance(common_1.PageTypeV4.ObjectPage, 'ObjectPageHeader');
    utils_1.transferSettingsOfObject(objectPageConfig.header, importParameters.manifest, importParameters.jsonSchema['definitions']['ObjectPageHeader'], importParameters.routingId, []);
    // Transfer layout information
    objectPageConfig.layout = factory.createInstance(common_1.PageTypeV4.ObjectPage, 'ObjectPageLayout');
    utils_1.transferSettingsOfObject(objectPageConfig.layout, importParameters.manifest, importParameters.jsonSchema['definitions']['ObjectPageLayout'], importParameters.routingId, []);
    utils_1.transferSettingsOfObject(objectPageConfig, importParameters.manifest, importParameters.jsonSchema, importParameters.routingId, []);
    if (!objectPageConfig.sections) {
        objectPageConfig.sections = {};
    }
    if (manifestSettings) {
        if (manifestSettings.controlConfiguration && importParameters.jsonSchema['definitions']['Sections']) {
            // Fill sections and subsections
            objectPageConfig.sections = {};
            fillSectionsInConfig(importParameters, importParameters.jsonSchema['definitions']['Sections'].properties, manifestSettings, objectPageConfig.sections, factory);
        }
        // Fill Custom sections
        const customSections = (_b = (_a = manifestSettings.content) === null || _a === void 0 ? void 0 : _a.body) === null || _b === void 0 ? void 0 : _b.sections;
        if (customSections) {
            objectPageConfig.sections.custom = [];
            for (const sectionId in customSections) {
                const section = factory.createInstance(common_1.PageTypeV4.ObjectPage, 'ObjectPageCustomSectionFragment');
                utils_1.transferSettingsOfObject(section, importParameters.manifest, importParameters.jsonSchema['definitions']['ObjectPageCustomSectionFragment'], importParameters.routingId, [], sectionId);
                objectPageConfig.sections.custom.push(section);
            }
        }
        // Fill header facets
        fillHeaderFacets(importParameters.jsonSchema, objectPageConfig, factory, importParameters.manifest, importParameters.routingId);
    }
    return objectPageConfig;
}
/**
 * External API: Create configuration (file content) for a V4 object page
 * @param {ImportObjectPageV4Parameters} importParameters  - object comprising all input data
 * @param {ExtensionLogger} logger - Logger class for logging messages
 *
 * @returns {ObjectPageConfig} config - the object page configuration
 */
function createObjectPageConfigV4(importParameters) {
    // Initialize i18next
    i18n_1.initI18n();
    if (!importParameters.manifest[v4_1.ManifestSection.ui5] || !importParameters.manifest[v4_1.ManifestSection.ui5]['routing']) {
        extensionLogger_1.log(importParameters.logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOROUTING'),
            location: {
                path: common_2.MANIFESTPATH,
                range: [v4_1.ManifestSection.ui5]
            }
        });
        return;
    }
    const v4Pages = importParameters.manifest[v4_1.ManifestSection.ui5]['routing']['targets'];
    if (!v4Pages) {
        extensionLogger_1.log(importParameters.logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOTARGETS'),
            location: {
                path: common_2.MANIFESTPATH,
                range: [v4_1.ManifestSection.ui5, 'routing']
            }
        });
        return;
    }
    const v4Page = v4Pages[importParameters.routingId];
    if (!v4Page) {
        extensionLogger_1.log(importParameters.logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOROUTINGID', { routingId: importParameters.routingId }),
            location: {
                path: common_2.MANIFESTPATH,
                range: [v4_1.ManifestSection.ui5, 'routing']
            }
        });
        return;
    }
    const factory = new factory_1.MetadataInstanceFactoryV4();
    //Fill config.json
    return fillObjectPageConfig(importParameters, v4Page, factory);
}
exports.createObjectPageConfigV4 = createObjectPageConfigV4;
//# sourceMappingURL=objectPage.js.map